// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: device_control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_device_5fcontrol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_device_5fcontrol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_device_5fcontrol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_device_5fcontrol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_device_5fcontrol_2eproto;
namespace ams {
namespace device {
namespace grpc {
class AddAudioClipRequest;
struct AddAudioClipRequestDefaultTypeInternal;
extern AddAudioClipRequestDefaultTypeInternal _AddAudioClipRequest_default_instance_;
class AddOnvifUserRequest;
struct AddOnvifUserRequestDefaultTypeInternal;
extern AddOnvifUserRequestDefaultTypeInternal _AddOnvifUserRequest_default_instance_;
class AddScheduleRequest;
struct AddScheduleRequestDefaultTypeInternal;
extern AddScheduleRequestDefaultTypeInternal _AddScheduleRequest_default_instance_;
class AddSipUserRequest;
struct AddSipUserRequestDefaultTypeInternal;
extern AddSipUserRequestDefaultTypeInternal _AddSipUserRequest_default_instance_;
class AudioClip;
struct AudioClipDefaultTypeInternal;
extern AudioClipDefaultTypeInternal _AudioClip_default_instance_;
class DeleteAudioClipRequest;
struct DeleteAudioClipRequestDefaultTypeInternal;
extern DeleteAudioClipRequestDefaultTypeInternal _DeleteAudioClipRequest_default_instance_;
class DeleteOnvifUserRequest;
struct DeleteOnvifUserRequestDefaultTypeInternal;
extern DeleteOnvifUserRequestDefaultTypeInternal _DeleteOnvifUserRequest_default_instance_;
class DeleteScheduleRequest;
struct DeleteScheduleRequestDefaultTypeInternal;
extern DeleteScheduleRequestDefaultTypeInternal _DeleteScheduleRequest_default_instance_;
class DeleteSipUserRequest;
struct DeleteSipUserRequestDefaultTypeInternal;
extern DeleteSipUserRequestDefaultTypeInternal _DeleteSipUserRequest_default_instance_;
class DeviceMessage;
struct DeviceMessageDefaultTypeInternal;
extern DeviceMessageDefaultTypeInternal _DeviceMessage_default_instance_;
class EditAudioClipRequest;
struct EditAudioClipRequestDefaultTypeInternal;
extern EditAudioClipRequestDefaultTypeInternal _EditAudioClipRequest_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ExceptionScheduleRequest;
struct ExceptionScheduleRequestDefaultTypeInternal;
extern ExceptionScheduleRequestDefaultTypeInternal _ExceptionScheduleRequest_default_instance_;
class GetNetworkInterfacesRequest;
struct GetNetworkInterfacesRequestDefaultTypeInternal;
extern GetNetworkInterfacesRequestDefaultTypeInternal _GetNetworkInterfacesRequest_default_instance_;
class GetNetworkInterfacesResponse;
struct GetNetworkInterfacesResponseDefaultTypeInternal;
extern GetNetworkInterfacesResponseDefaultTypeInternal _GetNetworkInterfacesResponse_default_instance_;
class GetOnvifInformationRequest;
struct GetOnvifInformationRequestDefaultTypeInternal;
extern GetOnvifInformationRequestDefaultTypeInternal _GetOnvifInformationRequest_default_instance_;
class GetOnvifInformationResponse;
struct GetOnvifInformationResponseDefaultTypeInternal;
extern GetOnvifInformationResponseDefaultTypeInternal _GetOnvifInformationResponse_default_instance_;
class GetPaAddressRequest;
struct GetPaAddressRequestDefaultTypeInternal;
extern GetPaAddressRequestDefaultTypeInternal _GetPaAddressRequest_default_instance_;
class GetPaAddressResponse;
struct GetPaAddressResponseDefaultTypeInternal;
extern GetPaAddressResponseDefaultTypeInternal _GetPaAddressResponse_default_instance_;
class GetScheduleListRequest;
struct GetScheduleListRequestDefaultTypeInternal;
extern GetScheduleListRequestDefaultTypeInternal _GetScheduleListRequest_default_instance_;
class GetScheduleListResponse;
struct GetScheduleListResponseDefaultTypeInternal;
extern GetScheduleListResponseDefaultTypeInternal _GetScheduleListResponse_default_instance_;
class GetSipInformationRequest;
struct GetSipInformationRequestDefaultTypeInternal;
extern GetSipInformationRequestDefaultTypeInternal _GetSipInformationRequest_default_instance_;
class GetSipInformationResponse;
struct GetSipInformationResponseDefaultTypeInternal;
extern GetSipInformationResponseDefaultTypeInternal _GetSipInformationResponse_default_instance_;
class GetSnapcastAddressRequest;
struct GetSnapcastAddressRequestDefaultTypeInternal;
extern GetSnapcastAddressRequestDefaultTypeInternal _GetSnapcastAddressRequest_default_instance_;
class GetSnapcastAddressResponse;
struct GetSnapcastAddressResponseDefaultTypeInternal;
extern GetSnapcastAddressResponseDefaultTypeInternal _GetSnapcastAddressResponse_default_instance_;
class GetSystemDateAndTimeRequest;
struct GetSystemDateAndTimeRequestDefaultTypeInternal;
extern GetSystemDateAndTimeRequestDefaultTypeInternal _GetSystemDateAndTimeRequest_default_instance_;
class GetSystemDateAndTimeResponse;
struct GetSystemDateAndTimeResponseDefaultTypeInternal;
extern GetSystemDateAndTimeResponseDefaultTypeInternal _GetSystemDateAndTimeResponse_default_instance_;
class GetVolumeRequest;
struct GetVolumeRequestDefaultTypeInternal;
extern GetVolumeRequestDefaultTypeInternal _GetVolumeRequest_default_instance_;
class GetVolumeResponse;
struct GetVolumeResponseDefaultTypeInternal;
extern GetVolumeResponseDefaultTypeInternal _GetVolumeResponse_default_instance_;
class InitSessionNotify;
struct InitSessionNotifyDefaultTypeInternal;
extern InitSessionNotifyDefaultTypeInternal _InitSessionNotify_default_instance_;
class OnvifUser;
struct OnvifUserDefaultTypeInternal;
extern OnvifUserDefaultTypeInternal _OnvifUser_default_instance_;
class Schedule;
struct ScheduleDefaultTypeInternal;
extern ScheduleDefaultTypeInternal _Schedule_default_instance_;
class ServerMessage;
struct ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
class SetDeviceInformationRequest;
struct SetDeviceInformationRequestDefaultTypeInternal;
extern SetDeviceInformationRequestDefaultTypeInternal _SetDeviceInformationRequest_default_instance_;
class SetNetworkInterfacesRequest;
struct SetNetworkInterfacesRequestDefaultTypeInternal;
extern SetNetworkInterfacesRequestDefaultTypeInternal _SetNetworkInterfacesRequest_default_instance_;
class SetOnvifUserRequest;
struct SetOnvifUserRequestDefaultTypeInternal;
extern SetOnvifUserRequestDefaultTypeInternal _SetOnvifUserRequest_default_instance_;
class SetPaAddressRequest;
struct SetPaAddressRequestDefaultTypeInternal;
extern SetPaAddressRequestDefaultTypeInternal _SetPaAddressRequest_default_instance_;
class SetScheduleRequest;
struct SetScheduleRequestDefaultTypeInternal;
extern SetScheduleRequestDefaultTypeInternal _SetScheduleRequest_default_instance_;
class SetSipUserRequest;
struct SetSipUserRequestDefaultTypeInternal;
extern SetSipUserRequestDefaultTypeInternal _SetSipUserRequest_default_instance_;
class SetSnapcastAddressRequest;
struct SetSnapcastAddressRequestDefaultTypeInternal;
extern SetSnapcastAddressRequestDefaultTypeInternal _SetSnapcastAddressRequest_default_instance_;
class SetSystemDateAndTimeRequest;
struct SetSystemDateAndTimeRequestDefaultTypeInternal;
extern SetSystemDateAndTimeRequestDefaultTypeInternal _SetSystemDateAndTimeRequest_default_instance_;
class SetVolumeRequest;
struct SetVolumeRequestDefaultTypeInternal;
extern SetVolumeRequestDefaultTypeInternal _SetVolumeRequest_default_instance_;
class SipAccount;
struct SipAccountDefaultTypeInternal;
extern SipAccountDefaultTypeInternal _SipAccount_default_instance_;
class StartBroadcastRequest;
struct StartBroadcastRequestDefaultTypeInternal;
extern StartBroadcastRequestDefaultTypeInternal _StartBroadcastRequest_default_instance_;
class StopBroadcastRequest;
struct StopBroadcastRequestDefaultTypeInternal;
extern StopBroadcastRequestDefaultTypeInternal _StopBroadcastRequest_default_instance_;
class SystemRebootRequest;
struct SystemRebootRequestDefaultTypeInternal;
extern SystemRebootRequestDefaultTypeInternal _SystemRebootRequest_default_instance_;
class SystemRebootResponse;
struct SystemRebootResponseDefaultTypeInternal;
extern SystemRebootResponseDefaultTypeInternal _SystemRebootResponse_default_instance_;
}  // namespace grpc
}  // namespace device
}  // namespace ams
PROTOBUF_NAMESPACE_OPEN
template<> ::ams::device::grpc::AddAudioClipRequest* Arena::CreateMaybeMessage<::ams::device::grpc::AddAudioClipRequest>(Arena*);
template<> ::ams::device::grpc::AddOnvifUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::AddOnvifUserRequest>(Arena*);
template<> ::ams::device::grpc::AddScheduleRequest* Arena::CreateMaybeMessage<::ams::device::grpc::AddScheduleRequest>(Arena*);
template<> ::ams::device::grpc::AddSipUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::AddSipUserRequest>(Arena*);
template<> ::ams::device::grpc::AudioClip* Arena::CreateMaybeMessage<::ams::device::grpc::AudioClip>(Arena*);
template<> ::ams::device::grpc::DeleteAudioClipRequest* Arena::CreateMaybeMessage<::ams::device::grpc::DeleteAudioClipRequest>(Arena*);
template<> ::ams::device::grpc::DeleteOnvifUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::DeleteOnvifUserRequest>(Arena*);
template<> ::ams::device::grpc::DeleteScheduleRequest* Arena::CreateMaybeMessage<::ams::device::grpc::DeleteScheduleRequest>(Arena*);
template<> ::ams::device::grpc::DeleteSipUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::DeleteSipUserRequest>(Arena*);
template<> ::ams::device::grpc::DeviceMessage* Arena::CreateMaybeMessage<::ams::device::grpc::DeviceMessage>(Arena*);
template<> ::ams::device::grpc::EditAudioClipRequest* Arena::CreateMaybeMessage<::ams::device::grpc::EditAudioClipRequest>(Arena*);
template<> ::ams::device::grpc::Error* Arena::CreateMaybeMessage<::ams::device::grpc::Error>(Arena*);
template<> ::ams::device::grpc::ExceptionScheduleRequest* Arena::CreateMaybeMessage<::ams::device::grpc::ExceptionScheduleRequest>(Arena*);
template<> ::ams::device::grpc::GetNetworkInterfacesRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetNetworkInterfacesRequest>(Arena*);
template<> ::ams::device::grpc::GetNetworkInterfacesResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetNetworkInterfacesResponse>(Arena*);
template<> ::ams::device::grpc::GetOnvifInformationRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetOnvifInformationRequest>(Arena*);
template<> ::ams::device::grpc::GetOnvifInformationResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetOnvifInformationResponse>(Arena*);
template<> ::ams::device::grpc::GetPaAddressRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetPaAddressRequest>(Arena*);
template<> ::ams::device::grpc::GetPaAddressResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetPaAddressResponse>(Arena*);
template<> ::ams::device::grpc::GetScheduleListRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetScheduleListRequest>(Arena*);
template<> ::ams::device::grpc::GetScheduleListResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetScheduleListResponse>(Arena*);
template<> ::ams::device::grpc::GetSipInformationRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetSipInformationRequest>(Arena*);
template<> ::ams::device::grpc::GetSipInformationResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetSipInformationResponse>(Arena*);
template<> ::ams::device::grpc::GetSnapcastAddressRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetSnapcastAddressRequest>(Arena*);
template<> ::ams::device::grpc::GetSnapcastAddressResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetSnapcastAddressResponse>(Arena*);
template<> ::ams::device::grpc::GetSystemDateAndTimeRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetSystemDateAndTimeRequest>(Arena*);
template<> ::ams::device::grpc::GetSystemDateAndTimeResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetSystemDateAndTimeResponse>(Arena*);
template<> ::ams::device::grpc::GetVolumeRequest* Arena::CreateMaybeMessage<::ams::device::grpc::GetVolumeRequest>(Arena*);
template<> ::ams::device::grpc::GetVolumeResponse* Arena::CreateMaybeMessage<::ams::device::grpc::GetVolumeResponse>(Arena*);
template<> ::ams::device::grpc::InitSessionNotify* Arena::CreateMaybeMessage<::ams::device::grpc::InitSessionNotify>(Arena*);
template<> ::ams::device::grpc::OnvifUser* Arena::CreateMaybeMessage<::ams::device::grpc::OnvifUser>(Arena*);
template<> ::ams::device::grpc::Schedule* Arena::CreateMaybeMessage<::ams::device::grpc::Schedule>(Arena*);
template<> ::ams::device::grpc::ServerMessage* Arena::CreateMaybeMessage<::ams::device::grpc::ServerMessage>(Arena*);
template<> ::ams::device::grpc::SetDeviceInformationRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetDeviceInformationRequest>(Arena*);
template<> ::ams::device::grpc::SetNetworkInterfacesRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetNetworkInterfacesRequest>(Arena*);
template<> ::ams::device::grpc::SetOnvifUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetOnvifUserRequest>(Arena*);
template<> ::ams::device::grpc::SetPaAddressRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetPaAddressRequest>(Arena*);
template<> ::ams::device::grpc::SetScheduleRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetScheduleRequest>(Arena*);
template<> ::ams::device::grpc::SetSipUserRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetSipUserRequest>(Arena*);
template<> ::ams::device::grpc::SetSnapcastAddressRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetSnapcastAddressRequest>(Arena*);
template<> ::ams::device::grpc::SetSystemDateAndTimeRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetSystemDateAndTimeRequest>(Arena*);
template<> ::ams::device::grpc::SetVolumeRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SetVolumeRequest>(Arena*);
template<> ::ams::device::grpc::SipAccount* Arena::CreateMaybeMessage<::ams::device::grpc::SipAccount>(Arena*);
template<> ::ams::device::grpc::StartBroadcastRequest* Arena::CreateMaybeMessage<::ams::device::grpc::StartBroadcastRequest>(Arena*);
template<> ::ams::device::grpc::StopBroadcastRequest* Arena::CreateMaybeMessage<::ams::device::grpc::StopBroadcastRequest>(Arena*);
template<> ::ams::device::grpc::SystemRebootRequest* Arena::CreateMaybeMessage<::ams::device::grpc::SystemRebootRequest>(Arena*);
template<> ::ams::device::grpc::SystemRebootResponse* Arena::CreateMaybeMessage<::ams::device::grpc::SystemRebootResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ams {
namespace device {
namespace grpc {

enum Status : int {
  STATUS_UNSPECIFIED = 0,
  OK = 1,
  ERROR = 2,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = STATUS_UNSPECIFIED;
constexpr Status Status_MAX = ERROR;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum DateTimeType : int {
  DATE_TIME_TYPE_UNSPECIFIED = 0,
  MANUAL = 1,
  NTP = 2,
  DateTimeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DateTimeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DateTimeType_IsValid(int value);
constexpr DateTimeType DateTimeType_MIN = DATE_TIME_TYPE_UNSPECIFIED;
constexpr DateTimeType DateTimeType_MAX = NTP;
constexpr int DateTimeType_ARRAYSIZE = DateTimeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DateTimeType_descriptor();
template<typename T>
inline const std::string& DateTimeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DateTimeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DateTimeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DateTimeType_descriptor(), enum_t_value);
}
inline bool DateTimeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DateTimeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DateTimeType>(
    DateTimeType_descriptor(), name, value);
}
enum NetworkMode : int {
  NETWORK_MODE_UNSPECIFIED = 0,
  DHCP = 1,
  STATIC = 2,
  NetworkMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetworkMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetworkMode_IsValid(int value);
constexpr NetworkMode NetworkMode_MIN = NETWORK_MODE_UNSPECIFIED;
constexpr NetworkMode NetworkMode_MAX = STATIC;
constexpr int NetworkMode_ARRAYSIZE = NetworkMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetworkMode_descriptor();
template<typename T>
inline const std::string& NetworkMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetworkMode_descriptor(), enum_t_value);
}
inline bool NetworkMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkMode>(
    NetworkMode_descriptor(), name, value);
}
enum DayOfWeek : int {
  DAY_OF_WEEK_UNSPECIFIED = 0,
  MON = 1,
  TUE = 2,
  WED = 3,
  THI = 4,
  FRI = 5,
  SAT = 6,
  SUN = 7,
  DayOfWeek_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DayOfWeek_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DayOfWeek_IsValid(int value);
constexpr DayOfWeek DayOfWeek_MIN = DAY_OF_WEEK_UNSPECIFIED;
constexpr DayOfWeek DayOfWeek_MAX = SUN;
constexpr int DayOfWeek_ARRAYSIZE = DayOfWeek_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DayOfWeek_descriptor();
template<typename T>
inline const std::string& DayOfWeek_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DayOfWeek>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DayOfWeek_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DayOfWeek_descriptor(), enum_t_value);
}
inline bool DayOfWeek_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DayOfWeek* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DayOfWeek>(
    DayOfWeek_descriptor(), name, value);
}
enum OnvifAccessLevel : int {
  ONVIF_ACCESS_LEVEL_UNSPECIFIED = 0,
  ADMIN = 1,
  OPERATOR = 2,
  USER = 3,
  OnvifAccessLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OnvifAccessLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OnvifAccessLevel_IsValid(int value);
constexpr OnvifAccessLevel OnvifAccessLevel_MIN = ONVIF_ACCESS_LEVEL_UNSPECIFIED;
constexpr OnvifAccessLevel OnvifAccessLevel_MAX = USER;
constexpr int OnvifAccessLevel_ARRAYSIZE = OnvifAccessLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OnvifAccessLevel_descriptor();
template<typename T>
inline const std::string& OnvifAccessLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OnvifAccessLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OnvifAccessLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OnvifAccessLevel_descriptor(), enum_t_value);
}
inline bool OnvifAccessLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OnvifAccessLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OnvifAccessLevel>(
    OnvifAccessLevel_descriptor(), name, value);
}
// ===================================================================

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit PROTOBUF_CONSTEXPR Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Error& from) {
    Error::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string code = 1;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetDeviceInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetDeviceInformationRequest) */ {
 public:
  inline SetDeviceInformationRequest() : SetDeviceInformationRequest(nullptr) {}
  ~SetDeviceInformationRequest() override;
  explicit PROTOBUF_CONSTEXPR SetDeviceInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetDeviceInformationRequest(const SetDeviceInformationRequest& from);
  SetDeviceInformationRequest(SetDeviceInformationRequest&& from) noexcept
    : SetDeviceInformationRequest() {
    *this = ::std::move(from);
  }

  inline SetDeviceInformationRequest& operator=(const SetDeviceInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDeviceInformationRequest& operator=(SetDeviceInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDeviceInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDeviceInformationRequest* internal_default_instance() {
    return reinterpret_cast<const SetDeviceInformationRequest*>(
               &_SetDeviceInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetDeviceInformationRequest& a, SetDeviceInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDeviceInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDeviceInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDeviceInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDeviceInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetDeviceInformationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetDeviceInformationRequest& from) {
    SetDeviceInformationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetDeviceInformationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetDeviceInformationRequest";
  }
  protected:
  explicit SetDeviceInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kLocationFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string location = 2;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetDeviceInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSystemDateAndTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSystemDateAndTimeRequest) */ {
 public:
  inline GetSystemDateAndTimeRequest() : GetSystemDateAndTimeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSystemDateAndTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSystemDateAndTimeRequest(const GetSystemDateAndTimeRequest& from);
  GetSystemDateAndTimeRequest(GetSystemDateAndTimeRequest&& from) noexcept
    : GetSystemDateAndTimeRequest() {
    *this = ::std::move(from);
  }

  inline GetSystemDateAndTimeRequest& operator=(const GetSystemDateAndTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSystemDateAndTimeRequest& operator=(GetSystemDateAndTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSystemDateAndTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSystemDateAndTimeRequest* internal_default_instance() {
    return reinterpret_cast<const GetSystemDateAndTimeRequest*>(
               &_GetSystemDateAndTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetSystemDateAndTimeRequest& a, GetSystemDateAndTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSystemDateAndTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSystemDateAndTimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSystemDateAndTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSystemDateAndTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSystemDateAndTimeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSystemDateAndTimeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSystemDateAndTimeRequest";
  }
  protected:
  explicit GetSystemDateAndTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSystemDateAndTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetSystemDateAndTimeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetSystemDateAndTimeRequest) */ {
 public:
  inline SetSystemDateAndTimeRequest() : SetSystemDateAndTimeRequest(nullptr) {}
  ~SetSystemDateAndTimeRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSystemDateAndTimeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSystemDateAndTimeRequest(const SetSystemDateAndTimeRequest& from);
  SetSystemDateAndTimeRequest(SetSystemDateAndTimeRequest&& from) noexcept
    : SetSystemDateAndTimeRequest() {
    *this = ::std::move(from);
  }

  inline SetSystemDateAndTimeRequest& operator=(const SetSystemDateAndTimeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSystemDateAndTimeRequest& operator=(SetSystemDateAndTimeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSystemDateAndTimeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSystemDateAndTimeRequest* internal_default_instance() {
    return reinterpret_cast<const SetSystemDateAndTimeRequest*>(
               &_SetSystemDateAndTimeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SetSystemDateAndTimeRequest& a, SetSystemDateAndTimeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSystemDateAndTimeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSystemDateAndTimeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSystemDateAndTimeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSystemDateAndTimeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSystemDateAndTimeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSystemDateAndTimeRequest& from) {
    SetSystemDateAndTimeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSystemDateAndTimeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetSystemDateAndTimeRequest";
  }
  protected:
  explicit SetSystemDateAndTimeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeZoneFieldNumber = 2,
    kUtcTimeFieldNumber = 3,
    kNtpServerFieldNumber = 4,
    kDateTimeTypeFieldNumber = 1,
  };
  // string time_zone = 2;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string utc_time = 3;
  void clear_utc_time();
  const std::string& utc_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utc_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utc_time();
  PROTOBUF_NODISCARD std::string* release_utc_time();
  void set_allocated_utc_time(std::string* utc_time);
  private:
  const std::string& _internal_utc_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utc_time(const std::string& value);
  std::string* _internal_mutable_utc_time();
  public:

  // string ntp_server = 4;
  void clear_ntp_server();
  const std::string& ntp_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ntp_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ntp_server();
  PROTOBUF_NODISCARD std::string* release_ntp_server();
  void set_allocated_ntp_server(std::string* ntp_server);
  private:
  const std::string& _internal_ntp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ntp_server(const std::string& value);
  std::string* _internal_mutable_ntp_server();
  public:

  // .ams.device.grpc.DateTimeType date_time_type = 1;
  void clear_date_time_type();
  ::ams::device::grpc::DateTimeType date_time_type() const;
  void set_date_time_type(::ams::device::grpc::DateTimeType value);
  private:
  ::ams::device::grpc::DateTimeType _internal_date_time_type() const;
  void _internal_set_date_time_type(::ams::device::grpc::DateTimeType value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetSystemDateAndTimeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utc_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ntp_server_;
    int date_time_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkInterfacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetNetworkInterfacesRequest) */ {
 public:
  inline GetNetworkInterfacesRequest() : GetNetworkInterfacesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetNetworkInterfacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkInterfacesRequest(const GetNetworkInterfacesRequest& from);
  GetNetworkInterfacesRequest(GetNetworkInterfacesRequest&& from) noexcept
    : GetNetworkInterfacesRequest() {
    *this = ::std::move(from);
  }

  inline GetNetworkInterfacesRequest& operator=(const GetNetworkInterfacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkInterfacesRequest& operator=(GetNetworkInterfacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkInterfacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkInterfacesRequest* internal_default_instance() {
    return reinterpret_cast<const GetNetworkInterfacesRequest*>(
               &_GetNetworkInterfacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetNetworkInterfacesRequest& a, GetNetworkInterfacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkInterfacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkInterfacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNetworkInterfacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNetworkInterfacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetNetworkInterfacesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetNetworkInterfacesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetNetworkInterfacesRequest";
  }
  protected:
  explicit GetNetworkInterfacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetNetworkInterfacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetNetworkInterfacesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetNetworkInterfacesRequest) */ {
 public:
  inline SetNetworkInterfacesRequest() : SetNetworkInterfacesRequest(nullptr) {}
  ~SetNetworkInterfacesRequest() override;
  explicit PROTOBUF_CONSTEXPR SetNetworkInterfacesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetNetworkInterfacesRequest(const SetNetworkInterfacesRequest& from);
  SetNetworkInterfacesRequest(SetNetworkInterfacesRequest&& from) noexcept
    : SetNetworkInterfacesRequest() {
    *this = ::std::move(from);
  }

  inline SetNetworkInterfacesRequest& operator=(const SetNetworkInterfacesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetNetworkInterfacesRequest& operator=(SetNetworkInterfacesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetNetworkInterfacesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetNetworkInterfacesRequest* internal_default_instance() {
    return reinterpret_cast<const SetNetworkInterfacesRequest*>(
               &_SetNetworkInterfacesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetNetworkInterfacesRequest& a, SetNetworkInterfacesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetNetworkInterfacesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetNetworkInterfacesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetNetworkInterfacesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetNetworkInterfacesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetNetworkInterfacesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetNetworkInterfacesRequest& from) {
    SetNetworkInterfacesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetNetworkInterfacesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetNetworkInterfacesRequest";
  }
  protected:
  explicit SetNetworkInterfacesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnsFieldNumber = 5,
    kIpv4AddressFieldNumber = 2,
    kNetmaskFieldNumber = 3,
    kGatewayFieldNumber = 4,
    kHostnameFieldNumber = 6,
    kModeFieldNumber = 1,
  };
  // repeated string dns = 5;
  int dns_size() const;
  private:
  int _internal_dns_size() const;
  public:
  void clear_dns();
  const std::string& dns(int index) const;
  std::string* mutable_dns(int index);
  void set_dns(int index, const std::string& value);
  void set_dns(int index, std::string&& value);
  void set_dns(int index, const char* value);
  void set_dns(int index, const char* value, size_t size);
  std::string* add_dns();
  void add_dns(const std::string& value);
  void add_dns(std::string&& value);
  void add_dns(const char* value);
  void add_dns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dns();
  private:
  const std::string& _internal_dns(int index) const;
  std::string* _internal_add_dns();
  public:

  // string ipv4_address = 2;
  void clear_ipv4_address();
  const std::string& ipv4_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv4_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv4_address();
  PROTOBUF_NODISCARD std::string* release_ipv4_address();
  void set_allocated_ipv4_address(std::string* ipv4_address);
  private:
  const std::string& _internal_ipv4_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv4_address(const std::string& value);
  std::string* _internal_mutable_ipv4_address();
  public:

  // string netmask = 3;
  void clear_netmask();
  const std::string& netmask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_netmask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_netmask();
  PROTOBUF_NODISCARD std::string* release_netmask();
  void set_allocated_netmask(std::string* netmask);
  private:
  const std::string& _internal_netmask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_netmask(const std::string& value);
  std::string* _internal_mutable_netmask();
  public:

  // string gateway = 4;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // string hostname = 6;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .ams.device.grpc.NetworkMode mode = 1;
  void clear_mode();
  ::ams::device::grpc::NetworkMode mode() const;
  void set_mode(::ams::device::grpc::NetworkMode value);
  private:
  ::ams::device::grpc::NetworkMode _internal_mode() const;
  void _internal_set_mode(::ams::device::grpc::NetworkMode value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetNetworkInterfacesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv4_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr netmask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SipAccount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SipAccount) */ {
 public:
  inline SipAccount() : SipAccount(nullptr) {}
  ~SipAccount() override;
  explicit PROTOBUF_CONSTEXPR SipAccount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SipAccount(const SipAccount& from);
  SipAccount(SipAccount&& from) noexcept
    : SipAccount() {
    *this = ::std::move(from);
  }

  inline SipAccount& operator=(const SipAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline SipAccount& operator=(SipAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SipAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const SipAccount* internal_default_instance() {
    return reinterpret_cast<const SipAccount*>(
               &_SipAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SipAccount& a, SipAccount& b) {
    a.Swap(&b);
  }
  inline void Swap(SipAccount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SipAccount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SipAccount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SipAccount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SipAccount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SipAccount& from) {
    SipAccount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SipAccount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SipAccount";
  }
  protected:
  explicit SipAccount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAuthIdFieldNumber = 2,
    kAuthPasswordFieldNumber = 3,
    kServerFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string auth_id = 2;
  void clear_auth_id();
  const std::string& auth_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_id();
  PROTOBUF_NODISCARD std::string* release_auth_id();
  void set_allocated_auth_id(std::string* auth_id);
  private:
  const std::string& _internal_auth_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_id(const std::string& value);
  std::string* _internal_mutable_auth_id();
  public:

  // string auth_password = 3;
  void clear_auth_password();
  const std::string& auth_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_password();
  PROTOBUF_NODISCARD std::string* release_auth_password();
  void set_allocated_auth_password(std::string* auth_password);
  private:
  const std::string& _internal_auth_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_password(const std::string& value);
  std::string* _internal_mutable_auth_password();
  public:

  // string server = 4;
  void clear_server();
  const std::string& server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server();
  PROTOBUF_NODISCARD std::string* release_server();
  void set_allocated_server(std::string* server);
  private:
  const std::string& _internal_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server(const std::string& value);
  std::string* _internal_mutable_server();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SipAccount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSipInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSipInformationRequest) */ {
 public:
  inline GetSipInformationRequest() : GetSipInformationRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSipInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSipInformationRequest(const GetSipInformationRequest& from);
  GetSipInformationRequest(GetSipInformationRequest&& from) noexcept
    : GetSipInformationRequest() {
    *this = ::std::move(from);
  }

  inline GetSipInformationRequest& operator=(const GetSipInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSipInformationRequest& operator=(GetSipInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSipInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSipInformationRequest* internal_default_instance() {
    return reinterpret_cast<const GetSipInformationRequest*>(
               &_GetSipInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetSipInformationRequest& a, GetSipInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSipInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSipInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSipInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSipInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSipInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSipInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSipInformationRequest";
  }
  protected:
  explicit GetSipInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSipInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AddSipUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.AddSipUserRequest) */ {
 public:
  inline AddSipUserRequest() : AddSipUserRequest(nullptr) {}
  ~AddSipUserRequest() override;
  explicit PROTOBUF_CONSTEXPR AddSipUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddSipUserRequest(const AddSipUserRequest& from);
  AddSipUserRequest(AddSipUserRequest&& from) noexcept
    : AddSipUserRequest() {
    *this = ::std::move(from);
  }

  inline AddSipUserRequest& operator=(const AddSipUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddSipUserRequest& operator=(AddSipUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddSipUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddSipUserRequest* internal_default_instance() {
    return reinterpret_cast<const AddSipUserRequest*>(
               &_AddSipUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddSipUserRequest& a, AddSipUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddSipUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddSipUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddSipUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddSipUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddSipUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddSipUserRequest& from) {
    AddSipUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddSipUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.AddSipUserRequest";
  }
  protected:
  explicit AddSipUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .ams.device.grpc.SipAccount account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::ams::device::grpc::SipAccount& account() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SipAccount* release_account();
  ::ams::device::grpc::SipAccount* mutable_account();
  void set_allocated_account(::ams::device::grpc::SipAccount* account);
  private:
  const ::ams::device::grpc::SipAccount& _internal_account() const;
  ::ams::device::grpc::SipAccount* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::ams::device::grpc::SipAccount* account);
  ::ams::device::grpc::SipAccount* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.AddSipUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::SipAccount* account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DeleteSipUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.DeleteSipUserRequest) */ {
 public:
  inline DeleteSipUserRequest() : DeleteSipUserRequest(nullptr) {}
  ~DeleteSipUserRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteSipUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSipUserRequest(const DeleteSipUserRequest& from);
  DeleteSipUserRequest(DeleteSipUserRequest&& from) noexcept
    : DeleteSipUserRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSipUserRequest& operator=(const DeleteSipUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSipUserRequest& operator=(DeleteSipUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSipUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSipUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSipUserRequest*>(
               &_DeleteSipUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DeleteSipUserRequest& a, DeleteSipUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSipUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSipUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSipUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSipUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSipUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteSipUserRequest& from) {
    DeleteSipUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSipUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.DeleteSipUserRequest";
  }
  protected:
  explicit DeleteSipUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.DeleteSipUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetSipUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetSipUserRequest) */ {
 public:
  inline SetSipUserRequest() : SetSipUserRequest(nullptr) {}
  ~SetSipUserRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSipUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSipUserRequest(const SetSipUserRequest& from);
  SetSipUserRequest(SetSipUserRequest&& from) noexcept
    : SetSipUserRequest() {
    *this = ::std::move(from);
  }

  inline SetSipUserRequest& operator=(const SetSipUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSipUserRequest& operator=(SetSipUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSipUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSipUserRequest* internal_default_instance() {
    return reinterpret_cast<const SetSipUserRequest*>(
               &_SetSipUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetSipUserRequest& a, SetSipUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSipUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSipUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSipUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSipUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSipUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSipUserRequest& from) {
    SetSipUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSipUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetSipUserRequest";
  }
  protected:
  explicit SetSipUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .ams.device.grpc.SipAccount account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::ams::device::grpc::SipAccount& account() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SipAccount* release_account();
  ::ams::device::grpc::SipAccount* mutable_account();
  void set_allocated_account(::ams::device::grpc::SipAccount* account);
  private:
  const ::ams::device::grpc::SipAccount& _internal_account() const;
  ::ams::device::grpc::SipAccount* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::ams::device::grpc::SipAccount* account);
  ::ams::device::grpc::SipAccount* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetSipUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::SipAccount* account_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class OnvifUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.OnvifUser) */ {
 public:
  inline OnvifUser() : OnvifUser(nullptr) {}
  ~OnvifUser() override;
  explicit PROTOBUF_CONSTEXPR OnvifUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OnvifUser(const OnvifUser& from);
  OnvifUser(OnvifUser&& from) noexcept
    : OnvifUser() {
    *this = ::std::move(from);
  }

  inline OnvifUser& operator=(const OnvifUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnvifUser& operator=(OnvifUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnvifUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnvifUser* internal_default_instance() {
    return reinterpret_cast<const OnvifUser*>(
               &_OnvifUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(OnvifUser& a, OnvifUser& b) {
    a.Swap(&b);
  }
  inline void Swap(OnvifUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnvifUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnvifUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OnvifUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OnvifUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OnvifUser& from) {
    OnvifUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OnvifUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.OnvifUser";
  }
  protected:
  explicit OnvifUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kAccessLevelFieldNumber = 3,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .ams.device.grpc.OnvifAccessLevel access_level = 3;
  void clear_access_level();
  ::ams::device::grpc::OnvifAccessLevel access_level() const;
  void set_access_level(::ams::device::grpc::OnvifAccessLevel value);
  private:
  ::ams::device::grpc::OnvifAccessLevel _internal_access_level() const;
  void _internal_set_access_level(::ams::device::grpc::OnvifAccessLevel value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.OnvifUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    int access_level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetOnvifInformationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetOnvifInformationRequest) */ {
 public:
  inline GetOnvifInformationRequest() : GetOnvifInformationRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetOnvifInformationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnvifInformationRequest(const GetOnvifInformationRequest& from);
  GetOnvifInformationRequest(GetOnvifInformationRequest&& from) noexcept
    : GetOnvifInformationRequest() {
    *this = ::std::move(from);
  }

  inline GetOnvifInformationRequest& operator=(const GetOnvifInformationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnvifInformationRequest& operator=(GetOnvifInformationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnvifInformationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnvifInformationRequest* internal_default_instance() {
    return reinterpret_cast<const GetOnvifInformationRequest*>(
               &_GetOnvifInformationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetOnvifInformationRequest& a, GetOnvifInformationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnvifInformationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnvifInformationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOnvifInformationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOnvifInformationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetOnvifInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetOnvifInformationRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetOnvifInformationRequest";
  }
  protected:
  explicit GetOnvifInformationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetOnvifInformationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AddOnvifUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.AddOnvifUserRequest) */ {
 public:
  inline AddOnvifUserRequest() : AddOnvifUserRequest(nullptr) {}
  ~AddOnvifUserRequest() override;
  explicit PROTOBUF_CONSTEXPR AddOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddOnvifUserRequest(const AddOnvifUserRequest& from);
  AddOnvifUserRequest(AddOnvifUserRequest&& from) noexcept
    : AddOnvifUserRequest() {
    *this = ::std::move(from);
  }

  inline AddOnvifUserRequest& operator=(const AddOnvifUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddOnvifUserRequest& operator=(AddOnvifUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddOnvifUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddOnvifUserRequest* internal_default_instance() {
    return reinterpret_cast<const AddOnvifUserRequest*>(
               &_AddOnvifUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddOnvifUserRequest& a, AddOnvifUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddOnvifUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddOnvifUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddOnvifUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddOnvifUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddOnvifUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddOnvifUserRequest& from) {
    AddOnvifUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddOnvifUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.AddOnvifUserRequest";
  }
  protected:
  explicit AddOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .ams.device.grpc.OnvifUser user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ams::device::grpc::OnvifUser& user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::OnvifUser* release_user();
  ::ams::device::grpc::OnvifUser* mutable_user();
  void set_allocated_user(::ams::device::grpc::OnvifUser* user);
  private:
  const ::ams::device::grpc::OnvifUser& _internal_user() const;
  ::ams::device::grpc::OnvifUser* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ams::device::grpc::OnvifUser* user);
  ::ams::device::grpc::OnvifUser* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.AddOnvifUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::OnvifUser* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DeleteOnvifUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.DeleteOnvifUserRequest) */ {
 public:
  inline DeleteOnvifUserRequest() : DeleteOnvifUserRequest(nullptr) {}
  ~DeleteOnvifUserRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteOnvifUserRequest(const DeleteOnvifUserRequest& from);
  DeleteOnvifUserRequest(DeleteOnvifUserRequest&& from) noexcept
    : DeleteOnvifUserRequest() {
    *this = ::std::move(from);
  }

  inline DeleteOnvifUserRequest& operator=(const DeleteOnvifUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteOnvifUserRequest& operator=(DeleteOnvifUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteOnvifUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteOnvifUserRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteOnvifUserRequest*>(
               &_DeleteOnvifUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeleteOnvifUserRequest& a, DeleteOnvifUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteOnvifUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteOnvifUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteOnvifUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteOnvifUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteOnvifUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteOnvifUserRequest& from) {
    DeleteOnvifUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteOnvifUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.DeleteOnvifUserRequest";
  }
  protected:
  explicit DeleteOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.DeleteOnvifUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetOnvifUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetOnvifUserRequest) */ {
 public:
  inline SetOnvifUserRequest() : SetOnvifUserRequest(nullptr) {}
  ~SetOnvifUserRequest() override;
  explicit PROTOBUF_CONSTEXPR SetOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetOnvifUserRequest(const SetOnvifUserRequest& from);
  SetOnvifUserRequest(SetOnvifUserRequest&& from) noexcept
    : SetOnvifUserRequest() {
    *this = ::std::move(from);
  }

  inline SetOnvifUserRequest& operator=(const SetOnvifUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetOnvifUserRequest& operator=(SetOnvifUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetOnvifUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetOnvifUserRequest* internal_default_instance() {
    return reinterpret_cast<const SetOnvifUserRequest*>(
               &_SetOnvifUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SetOnvifUserRequest& a, SetOnvifUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetOnvifUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetOnvifUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetOnvifUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetOnvifUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetOnvifUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetOnvifUserRequest& from) {
    SetOnvifUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetOnvifUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetOnvifUserRequest";
  }
  protected:
  explicit SetOnvifUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
  };
  // .ams.device.grpc.OnvifUser user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::ams::device::grpc::OnvifUser& user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::OnvifUser* release_user();
  ::ams::device::grpc::OnvifUser* mutable_user();
  void set_allocated_user(::ams::device::grpc::OnvifUser* user);
  private:
  const ::ams::device::grpc::OnvifUser& _internal_user() const;
  ::ams::device::grpc::OnvifUser* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::ams::device::grpc::OnvifUser* user);
  ::ams::device::grpc::OnvifUser* unsafe_arena_release_user();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetOnvifUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::OnvifUser* user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetPaAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetPaAddressRequest) */ {
 public:
  inline GetPaAddressRequest() : GetPaAddressRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetPaAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaAddressRequest(const GetPaAddressRequest& from);
  GetPaAddressRequest(GetPaAddressRequest&& from) noexcept
    : GetPaAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetPaAddressRequest& operator=(const GetPaAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaAddressRequest& operator=(GetPaAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetPaAddressRequest*>(
               &_GetPaAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetPaAddressRequest& a, GetPaAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPaAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPaAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetPaAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetPaAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetPaAddressRequest";
  }
  protected:
  explicit GetPaAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetPaAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetPaAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetPaAddressRequest) */ {
 public:
  inline SetPaAddressRequest() : SetPaAddressRequest(nullptr) {}
  ~SetPaAddressRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPaAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPaAddressRequest(const SetPaAddressRequest& from);
  SetPaAddressRequest(SetPaAddressRequest&& from) noexcept
    : SetPaAddressRequest() {
    *this = ::std::move(from);
  }

  inline SetPaAddressRequest& operator=(const SetPaAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPaAddressRequest& operator=(SetPaAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPaAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPaAddressRequest* internal_default_instance() {
    return reinterpret_cast<const SetPaAddressRequest*>(
               &_SetPaAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetPaAddressRequest& a, SetPaAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPaAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPaAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPaAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPaAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPaAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPaAddressRequest& from) {
    SetPaAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPaAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetPaAddressRequest";
  }
  protected:
  explicit SetPaAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetPaAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSnapcastAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSnapcastAddressRequest) */ {
 public:
  inline GetSnapcastAddressRequest() : GetSnapcastAddressRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetSnapcastAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSnapcastAddressRequest(const GetSnapcastAddressRequest& from);
  GetSnapcastAddressRequest(GetSnapcastAddressRequest&& from) noexcept
    : GetSnapcastAddressRequest() {
    *this = ::std::move(from);
  }

  inline GetSnapcastAddressRequest& operator=(const GetSnapcastAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSnapcastAddressRequest& operator=(GetSnapcastAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSnapcastAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSnapcastAddressRequest* internal_default_instance() {
    return reinterpret_cast<const GetSnapcastAddressRequest*>(
               &_GetSnapcastAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetSnapcastAddressRequest& a, GetSnapcastAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSnapcastAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSnapcastAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSnapcastAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSnapcastAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetSnapcastAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetSnapcastAddressRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSnapcastAddressRequest";
  }
  protected:
  explicit GetSnapcastAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSnapcastAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetSnapcastAddressRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetSnapcastAddressRequest) */ {
 public:
  inline SetSnapcastAddressRequest() : SetSnapcastAddressRequest(nullptr) {}
  ~SetSnapcastAddressRequest() override;
  explicit PROTOBUF_CONSTEXPR SetSnapcastAddressRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetSnapcastAddressRequest(const SetSnapcastAddressRequest& from);
  SetSnapcastAddressRequest(SetSnapcastAddressRequest&& from) noexcept
    : SetSnapcastAddressRequest() {
    *this = ::std::move(from);
  }

  inline SetSnapcastAddressRequest& operator=(const SetSnapcastAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetSnapcastAddressRequest& operator=(SetSnapcastAddressRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetSnapcastAddressRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetSnapcastAddressRequest* internal_default_instance() {
    return reinterpret_cast<const SetSnapcastAddressRequest*>(
               &_SetSnapcastAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(SetSnapcastAddressRequest& a, SetSnapcastAddressRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetSnapcastAddressRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetSnapcastAddressRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetSnapcastAddressRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetSnapcastAddressRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetSnapcastAddressRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetSnapcastAddressRequest& from) {
    SetSnapcastAddressRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetSnapcastAddressRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetSnapcastAddressRequest";
  }
  protected:
  explicit SetSnapcastAddressRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetSnapcastAddressRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetVolumeRequest) */ {
 public:
  inline GetVolumeRequest() : GetVolumeRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVolumeRequest(const GetVolumeRequest& from);
  GetVolumeRequest(GetVolumeRequest&& from) noexcept
    : GetVolumeRequest() {
    *this = ::std::move(from);
  }

  inline GetVolumeRequest& operator=(const GetVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVolumeRequest& operator=(GetVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const GetVolumeRequest*>(
               &_GetVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetVolumeRequest& a, GetVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetVolumeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetVolumeRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetVolumeRequest";
  }
  protected:
  explicit GetVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetVolumeRequest) */ {
 public:
  inline SetVolumeRequest() : SetVolumeRequest(nullptr) {}
  ~SetVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR SetVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVolumeRequest(const SetVolumeRequest& from);
  SetVolumeRequest(SetVolumeRequest&& from) noexcept
    : SetVolumeRequest() {
    *this = ::std::move(from);
  }

  inline SetVolumeRequest& operator=(const SetVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVolumeRequest& operator=(SetVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const SetVolumeRequest*>(
               &_SetVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SetVolumeRequest& a, SetVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVolumeRequest& from) {
    SetVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetVolumeRequest";
  }
  protected:
  explicit SetVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakerVolumeFieldNumber = 1,
    kMicVolumeFieldNumber = 2,
  };
  // int32 speaker_volume = 1;
  void clear_speaker_volume();
  int32_t speaker_volume() const;
  void set_speaker_volume(int32_t value);
  private:
  int32_t _internal_speaker_volume() const;
  void _internal_set_speaker_volume(int32_t value);
  public:

  // int32 mic_volume = 2;
  void clear_mic_volume();
  int32_t mic_volume() const;
  void set_mic_volume(int32_t value);
  private:
  int32_t _internal_mic_volume() const;
  void _internal_set_mic_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t speaker_volume_;
    int32_t mic_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Schedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.Schedule) */ {
 public:
  inline Schedule() : Schedule(nullptr) {}
  ~Schedule() override;
  explicit PROTOBUF_CONSTEXPR Schedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schedule(const Schedule& from);
  Schedule(Schedule&& from) noexcept
    : Schedule() {
    *this = ::std::move(from);
  }

  inline Schedule& operator=(const Schedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schedule& operator=(Schedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schedule* internal_default_instance() {
    return reinterpret_cast<const Schedule*>(
               &_Schedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Schedule& a, Schedule& b) {
    a.Swap(&b);
  }
  inline void Swap(Schedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Schedule& from) {
    Schedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.Schedule";
  }
  protected:
  explicit Schedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDayOfWeekFieldNumber = 5,
    kExceptionDateFieldNumber = 11,
    kExceptionDatetimeFieldNumber = 12,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kEndDateFieldNumber = 4,
    kStartTimeFieldNumber = 6,
    kEndTimeFieldNumber = 7,
    kSoundIdFieldNumber = 9,
    kDisplayTextFieldNumber = 10,
    kTimeIntervalFieldNumber = 8,
    kEnabledFieldNumber = 13,
    kVolumeFieldNumber = 14,
  };
  // repeated .ams.device.grpc.DayOfWeek day_of_week = 5;
  int day_of_week_size() const;
  private:
  int _internal_day_of_week_size() const;
  public:
  void clear_day_of_week();
  private:
  ::ams::device::grpc::DayOfWeek _internal_day_of_week(int index) const;
  void _internal_add_day_of_week(::ams::device::grpc::DayOfWeek value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_day_of_week();
  public:
  ::ams::device::grpc::DayOfWeek day_of_week(int index) const;
  void set_day_of_week(int index, ::ams::device::grpc::DayOfWeek value);
  void add_day_of_week(::ams::device::grpc::DayOfWeek value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& day_of_week() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_day_of_week();

  // repeated string exception_date = 11;
  int exception_date_size() const;
  private:
  int _internal_exception_date_size() const;
  public:
  void clear_exception_date();
  const std::string& exception_date(int index) const;
  std::string* mutable_exception_date(int index);
  void set_exception_date(int index, const std::string& value);
  void set_exception_date(int index, std::string&& value);
  void set_exception_date(int index, const char* value);
  void set_exception_date(int index, const char* value, size_t size);
  std::string* add_exception_date();
  void add_exception_date(const std::string& value);
  void add_exception_date(std::string&& value);
  void add_exception_date(const char* value);
  void add_exception_date(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exception_date() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exception_date();
  private:
  const std::string& _internal_exception_date(int index) const;
  std::string* _internal_add_exception_date();
  public:

  // repeated string exception_datetime = 12;
  int exception_datetime_size() const;
  private:
  int _internal_exception_datetime_size() const;
  public:
  void clear_exception_datetime();
  const std::string& exception_datetime(int index) const;
  std::string* mutable_exception_datetime(int index);
  void set_exception_datetime(int index, const std::string& value);
  void set_exception_datetime(int index, std::string&& value);
  void set_exception_datetime(int index, const char* value);
  void set_exception_datetime(int index, const char* value, size_t size);
  std::string* add_exception_datetime();
  void add_exception_datetime(const std::string& value);
  void add_exception_datetime(std::string&& value);
  void add_exception_datetime(const char* value);
  void add_exception_datetime(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exception_datetime() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exception_datetime();
  private:
  const std::string& _internal_exception_datetime(int index) const;
  std::string* _internal_add_exception_datetime();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string start_date = 3;
  void clear_start_date();
  const std::string& start_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* start_date);
  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(const std::string& value);
  std::string* _internal_mutable_start_date();
  public:

  // optional string end_date = 4;
  bool has_end_date() const;
  private:
  bool _internal_has_end_date() const;
  public:
  void clear_end_date();
  const std::string& end_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_date();
  PROTOBUF_NODISCARD std::string* release_end_date();
  void set_allocated_end_date(std::string* end_date);
  private:
  const std::string& _internal_end_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_date(const std::string& value);
  std::string* _internal_mutable_end_date();
  public:

  // string start_time = 6;
  void clear_start_time();
  const std::string& start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* start_time);
  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(const std::string& value);
  std::string* _internal_mutable_start_time();
  public:

  // optional string end_time = 7;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  const std::string& end_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_time();
  PROTOBUF_NODISCARD std::string* release_end_time();
  void set_allocated_end_time(std::string* end_time);
  private:
  const std::string& _internal_end_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_time(const std::string& value);
  std::string* _internal_mutable_end_time();
  public:

  // string sound_id = 9;
  void clear_sound_id();
  const std::string& sound_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sound_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sound_id();
  PROTOBUF_NODISCARD std::string* release_sound_id();
  void set_allocated_sound_id(std::string* sound_id);
  private:
  const std::string& _internal_sound_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sound_id(const std::string& value);
  std::string* _internal_mutable_sound_id();
  public:

  // string display_text = 10;
  void clear_display_text();
  const std::string& display_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_text();
  PROTOBUF_NODISCARD std::string* release_display_text();
  void set_allocated_display_text(std::string* display_text);
  private:
  const std::string& _internal_display_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_text(const std::string& value);
  std::string* _internal_mutable_display_text();
  public:

  // int32 time_interval = 8;
  void clear_time_interval();
  int32_t time_interval() const;
  void set_time_interval(int32_t value);
  private:
  int32_t _internal_time_interval() const;
  void _internal_set_time_interval(int32_t value);
  public:

  // bool enabled = 13;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // int32 volume = 14;
  void clear_volume();
  int32_t volume() const;
  void set_volume(int32_t value);
  private:
  int32_t _internal_volume() const;
  void _internal_set_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.Schedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> day_of_week_;
    mutable std::atomic<int> _day_of_week_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exception_date_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exception_datetime_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sound_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_text_;
    int32_t time_interval_;
    bool enabled_;
    int32_t volume_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetScheduleListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetScheduleListRequest) */ {
 public:
  inline GetScheduleListRequest() : GetScheduleListRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetScheduleListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetScheduleListRequest(const GetScheduleListRequest& from);
  GetScheduleListRequest(GetScheduleListRequest&& from) noexcept
    : GetScheduleListRequest() {
    *this = ::std::move(from);
  }

  inline GetScheduleListRequest& operator=(const GetScheduleListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetScheduleListRequest& operator=(GetScheduleListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetScheduleListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetScheduleListRequest* internal_default_instance() {
    return reinterpret_cast<const GetScheduleListRequest*>(
               &_GetScheduleListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetScheduleListRequest& a, GetScheduleListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetScheduleListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetScheduleListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetScheduleListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetScheduleListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetScheduleListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetScheduleListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetScheduleListRequest";
  }
  protected:
  explicit GetScheduleListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetScheduleListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AddScheduleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.AddScheduleRequest) */ {
 public:
  inline AddScheduleRequest() : AddScheduleRequest(nullptr) {}
  ~AddScheduleRequest() override;
  explicit PROTOBUF_CONSTEXPR AddScheduleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddScheduleRequest(const AddScheduleRequest& from);
  AddScheduleRequest(AddScheduleRequest&& from) noexcept
    : AddScheduleRequest() {
    *this = ::std::move(from);
  }

  inline AddScheduleRequest& operator=(const AddScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddScheduleRequest& operator=(AddScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const AddScheduleRequest*>(
               &_AddScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AddScheduleRequest& a, AddScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddScheduleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddScheduleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddScheduleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddScheduleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddScheduleRequest& from) {
    AddScheduleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddScheduleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.AddScheduleRequest";
  }
  protected:
  explicit AddScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScheduleFieldNumber = 1,
  };
  // .ams.device.grpc.Schedule schedule = 1;
  bool has_schedule() const;
  private:
  bool _internal_has_schedule() const;
  public:
  void clear_schedule();
  const ::ams::device::grpc::Schedule& schedule() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::Schedule* release_schedule();
  ::ams::device::grpc::Schedule* mutable_schedule();
  void set_allocated_schedule(::ams::device::grpc::Schedule* schedule);
  private:
  const ::ams::device::grpc::Schedule& _internal_schedule() const;
  ::ams::device::grpc::Schedule* _internal_mutable_schedule();
  public:
  void unsafe_arena_set_allocated_schedule(
      ::ams::device::grpc::Schedule* schedule);
  ::ams::device::grpc::Schedule* unsafe_arena_release_schedule();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.AddScheduleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::Schedule* schedule_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DeleteScheduleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.DeleteScheduleRequest) */ {
 public:
  inline DeleteScheduleRequest() : DeleteScheduleRequest(nullptr) {}
  ~DeleteScheduleRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteScheduleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteScheduleRequest(const DeleteScheduleRequest& from);
  DeleteScheduleRequest(DeleteScheduleRequest&& from) noexcept
    : DeleteScheduleRequest() {
    *this = ::std::move(from);
  }

  inline DeleteScheduleRequest& operator=(const DeleteScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteScheduleRequest& operator=(DeleteScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteScheduleRequest*>(
               &_DeleteScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteScheduleRequest& a, DeleteScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteScheduleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteScheduleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteScheduleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteScheduleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteScheduleRequest& from) {
    DeleteScheduleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteScheduleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.DeleteScheduleRequest";
  }
  protected:
  explicit DeleteScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.DeleteScheduleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SetScheduleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SetScheduleRequest) */ {
 public:
  inline SetScheduleRequest() : SetScheduleRequest(nullptr) {}
  ~SetScheduleRequest() override;
  explicit PROTOBUF_CONSTEXPR SetScheduleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetScheduleRequest(const SetScheduleRequest& from);
  SetScheduleRequest(SetScheduleRequest&& from) noexcept
    : SetScheduleRequest() {
    *this = ::std::move(from);
  }

  inline SetScheduleRequest& operator=(const SetScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetScheduleRequest& operator=(SetScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const SetScheduleRequest*>(
               &_SetScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetScheduleRequest& a, SetScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetScheduleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetScheduleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetScheduleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetScheduleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetScheduleRequest& from) {
    SetScheduleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetScheduleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SetScheduleRequest";
  }
  protected:
  explicit SetScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kEnabledFieldNumber = 2,
    kVolumeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bool enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // int32 volume = 3;
  void clear_volume();
  int32_t volume() const;
  void set_volume(int32_t value);
  private:
  int32_t _internal_volume() const;
  void _internal_set_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SetScheduleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    bool enabled_;
    int32_t volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class ExceptionScheduleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.ExceptionScheduleRequest) */ {
 public:
  inline ExceptionScheduleRequest() : ExceptionScheduleRequest(nullptr) {}
  ~ExceptionScheduleRequest() override;
  explicit PROTOBUF_CONSTEXPR ExceptionScheduleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExceptionScheduleRequest(const ExceptionScheduleRequest& from);
  ExceptionScheduleRequest(ExceptionScheduleRequest&& from) noexcept
    : ExceptionScheduleRequest() {
    *this = ::std::move(from);
  }

  inline ExceptionScheduleRequest& operator=(const ExceptionScheduleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionScheduleRequest& operator=(ExceptionScheduleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExceptionScheduleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExceptionScheduleRequest* internal_default_instance() {
    return reinterpret_cast<const ExceptionScheduleRequest*>(
               &_ExceptionScheduleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ExceptionScheduleRequest& a, ExceptionScheduleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExceptionScheduleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionScheduleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExceptionScheduleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExceptionScheduleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExceptionScheduleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExceptionScheduleRequest& from) {
    ExceptionScheduleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExceptionScheduleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.ExceptionScheduleRequest";
  }
  protected:
  explicit ExceptionScheduleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kExceptionDateFieldNumber = 2,
    kExceptionTimeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string exception_date = 2;
  void clear_exception_date();
  const std::string& exception_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exception_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exception_date();
  PROTOBUF_NODISCARD std::string* release_exception_date();
  void set_allocated_exception_date(std::string* exception_date);
  private:
  const std::string& _internal_exception_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exception_date(const std::string& value);
  std::string* _internal_mutable_exception_date();
  public:

  // optional string exception_time = 3;
  bool has_exception_time() const;
  private:
  bool _internal_has_exception_time() const;
  public:
  void clear_exception_time();
  const std::string& exception_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exception_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exception_time();
  PROTOBUF_NODISCARD std::string* release_exception_time();
  void set_allocated_exception_time(std::string* exception_time);
  private:
  const std::string& _internal_exception_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exception_time(const std::string& value);
  std::string* _internal_mutable_exception_time();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.ExceptionScheduleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exception_date_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exception_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class StartBroadcastRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.StartBroadcastRequest) */ {
 public:
  inline StartBroadcastRequest() : StartBroadcastRequest(nullptr) {}
  ~StartBroadcastRequest() override;
  explicit PROTOBUF_CONSTEXPR StartBroadcastRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartBroadcastRequest(const StartBroadcastRequest& from);
  StartBroadcastRequest(StartBroadcastRequest&& from) noexcept
    : StartBroadcastRequest() {
    *this = ::std::move(from);
  }

  inline StartBroadcastRequest& operator=(const StartBroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartBroadcastRequest& operator=(StartBroadcastRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartBroadcastRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartBroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const StartBroadcastRequest*>(
               &_StartBroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(StartBroadcastRequest& a, StartBroadcastRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartBroadcastRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartBroadcastRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartBroadcastRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartBroadcastRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartBroadcastRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartBroadcastRequest& from) {
    StartBroadcastRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartBroadcastRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.StartBroadcastRequest";
  }
  protected:
  explicit StartBroadcastRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDisplayTextFieldNumber = 2,
    kVolumeFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string display_text = 2;
  void clear_display_text();
  const std::string& display_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_text();
  PROTOBUF_NODISCARD std::string* release_display_text();
  void set_allocated_display_text(std::string* display_text);
  private:
  const std::string& _internal_display_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_text(const std::string& value);
  std::string* _internal_mutable_display_text();
  public:

  // int32 volume = 3;
  void clear_volume();
  int32_t volume() const;
  void set_volume(int32_t value);
  private:
  int32_t _internal_volume() const;
  void _internal_set_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.StartBroadcastRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_text_;
    int32_t volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class StopBroadcastRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.StopBroadcastRequest) */ {
 public:
  inline StopBroadcastRequest() : StopBroadcastRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopBroadcastRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopBroadcastRequest(const StopBroadcastRequest& from);
  StopBroadcastRequest(StopBroadcastRequest&& from) noexcept
    : StopBroadcastRequest() {
    *this = ::std::move(from);
  }

  inline StopBroadcastRequest& operator=(const StopBroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopBroadcastRequest& operator=(StopBroadcastRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopBroadcastRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopBroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const StopBroadcastRequest*>(
               &_StopBroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(StopBroadcastRequest& a, StopBroadcastRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopBroadcastRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopBroadcastRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopBroadcastRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopBroadcastRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopBroadcastRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopBroadcastRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.StopBroadcastRequest";
  }
  protected:
  explicit StopBroadcastRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.StopBroadcastRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AudioClip final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.AudioClip) */ {
 public:
  inline AudioClip() : AudioClip(nullptr) {}
  ~AudioClip() override;
  explicit PROTOBUF_CONSTEXPR AudioClip(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioClip(const AudioClip& from);
  AudioClip(AudioClip&& from) noexcept
    : AudioClip() {
    *this = ::std::move(from);
  }

  inline AudioClip& operator=(const AudioClip& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioClip& operator=(AudioClip&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioClip& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioClip* internal_default_instance() {
    return reinterpret_cast<const AudioClip*>(
               &_AudioClip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AudioClip& a, AudioClip& b) {
    a.Swap(&b);
  }
  inline void Swap(AudioClip* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioClip* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioClip* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioClip>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AudioClip& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AudioClip& from) {
    AudioClip::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AudioClip* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.AudioClip";
  }
  protected:
  explicit AudioClip(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFilenameFieldNumber = 3,
    kPresignedUrlFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string filename = 3;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string presigned_url = 4;
  void clear_presigned_url();
  const std::string& presigned_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_presigned_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_presigned_url();
  PROTOBUF_NODISCARD std::string* release_presigned_url();
  void set_allocated_presigned_url(std::string* presigned_url);
  private:
  const std::string& _internal_presigned_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_presigned_url(const std::string& value);
  std::string* _internal_mutable_presigned_url();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.AudioClip)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr presigned_url_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class AddAudioClipRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.AddAudioClipRequest) */ {
 public:
  inline AddAudioClipRequest() : AddAudioClipRequest(nullptr) {}
  ~AddAudioClipRequest() override;
  explicit PROTOBUF_CONSTEXPR AddAudioClipRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddAudioClipRequest(const AddAudioClipRequest& from);
  AddAudioClipRequest(AddAudioClipRequest&& from) noexcept
    : AddAudioClipRequest() {
    *this = ::std::move(from);
  }

  inline AddAudioClipRequest& operator=(const AddAudioClipRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddAudioClipRequest& operator=(AddAudioClipRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddAudioClipRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddAudioClipRequest* internal_default_instance() {
    return reinterpret_cast<const AddAudioClipRequest*>(
               &_AddAudioClipRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AddAudioClipRequest& a, AddAudioClipRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddAudioClipRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddAudioClipRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddAudioClipRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddAudioClipRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddAudioClipRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddAudioClipRequest& from) {
    AddAudioClipRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddAudioClipRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.AddAudioClipRequest";
  }
  protected:
  explicit AddAudioClipRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClipFieldNumber = 1,
  };
  // .ams.device.grpc.AudioClip clip = 1;
  bool has_clip() const;
  private:
  bool _internal_has_clip() const;
  public:
  void clear_clip();
  const ::ams::device::grpc::AudioClip& clip() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::AudioClip* release_clip();
  ::ams::device::grpc::AudioClip* mutable_clip();
  void set_allocated_clip(::ams::device::grpc::AudioClip* clip);
  private:
  const ::ams::device::grpc::AudioClip& _internal_clip() const;
  ::ams::device::grpc::AudioClip* _internal_mutable_clip();
  public:
  void unsafe_arena_set_allocated_clip(
      ::ams::device::grpc::AudioClip* clip);
  ::ams::device::grpc::AudioClip* unsafe_arena_release_clip();

  // @@protoc_insertion_point(class_scope:ams.device.grpc.AddAudioClipRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::ams::device::grpc::AudioClip* clip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class EditAudioClipRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.EditAudioClipRequest) */ {
 public:
  inline EditAudioClipRequest() : EditAudioClipRequest(nullptr) {}
  ~EditAudioClipRequest() override;
  explicit PROTOBUF_CONSTEXPR EditAudioClipRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EditAudioClipRequest(const EditAudioClipRequest& from);
  EditAudioClipRequest(EditAudioClipRequest&& from) noexcept
    : EditAudioClipRequest() {
    *this = ::std::move(from);
  }

  inline EditAudioClipRequest& operator=(const EditAudioClipRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditAudioClipRequest& operator=(EditAudioClipRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EditAudioClipRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EditAudioClipRequest* internal_default_instance() {
    return reinterpret_cast<const EditAudioClipRequest*>(
               &_EditAudioClipRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(EditAudioClipRequest& a, EditAudioClipRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EditAudioClipRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EditAudioClipRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EditAudioClipRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EditAudioClipRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EditAudioClipRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EditAudioClipRequest& from) {
    EditAudioClipRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditAudioClipRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.EditAudioClipRequest";
  }
  protected:
  explicit EditAudioClipRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.EditAudioClipRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DeleteAudioClipRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.DeleteAudioClipRequest) */ {
 public:
  inline DeleteAudioClipRequest() : DeleteAudioClipRequest(nullptr) {}
  ~DeleteAudioClipRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteAudioClipRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteAudioClipRequest(const DeleteAudioClipRequest& from);
  DeleteAudioClipRequest(DeleteAudioClipRequest&& from) noexcept
    : DeleteAudioClipRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAudioClipRequest& operator=(const DeleteAudioClipRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAudioClipRequest& operator=(DeleteAudioClipRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAudioClipRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAudioClipRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAudioClipRequest*>(
               &_DeleteAudioClipRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DeleteAudioClipRequest& a, DeleteAudioClipRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAudioClipRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAudioClipRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAudioClipRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAudioClipRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteAudioClipRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteAudioClipRequest& from) {
    DeleteAudioClipRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAudioClipRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.DeleteAudioClipRequest";
  }
  protected:
  explicit DeleteAudioClipRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.DeleteAudioClipRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SystemRebootRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ams.device.grpc.SystemRebootRequest) */ {
 public:
  inline SystemRebootRequest() : SystemRebootRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SystemRebootRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemRebootRequest(const SystemRebootRequest& from);
  SystemRebootRequest(SystemRebootRequest&& from) noexcept
    : SystemRebootRequest() {
    *this = ::std::move(from);
  }

  inline SystemRebootRequest& operator=(const SystemRebootRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemRebootRequest& operator=(SystemRebootRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemRebootRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemRebootRequest* internal_default_instance() {
    return reinterpret_cast<const SystemRebootRequest*>(
               &_SystemRebootRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SystemRebootRequest& a, SystemRebootRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemRebootRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemRebootRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemRebootRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemRebootRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SystemRebootRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SystemRebootRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SystemRebootRequest";
  }
  protected:
  explicit SystemRebootRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SystemRebootRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSystemDateAndTimeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSystemDateAndTimeResponse) */ {
 public:
  inline GetSystemDateAndTimeResponse() : GetSystemDateAndTimeResponse(nullptr) {}
  ~GetSystemDateAndTimeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSystemDateAndTimeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSystemDateAndTimeResponse(const GetSystemDateAndTimeResponse& from);
  GetSystemDateAndTimeResponse(GetSystemDateAndTimeResponse&& from) noexcept
    : GetSystemDateAndTimeResponse() {
    *this = ::std::move(from);
  }

  inline GetSystemDateAndTimeResponse& operator=(const GetSystemDateAndTimeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSystemDateAndTimeResponse& operator=(GetSystemDateAndTimeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSystemDateAndTimeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSystemDateAndTimeResponse* internal_default_instance() {
    return reinterpret_cast<const GetSystemDateAndTimeResponse*>(
               &_GetSystemDateAndTimeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GetSystemDateAndTimeResponse& a, GetSystemDateAndTimeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSystemDateAndTimeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSystemDateAndTimeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSystemDateAndTimeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSystemDateAndTimeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSystemDateAndTimeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSystemDateAndTimeResponse& from) {
    GetSystemDateAndTimeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSystemDateAndTimeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSystemDateAndTimeResponse";
  }
  protected:
  explicit GetSystemDateAndTimeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeZoneFieldNumber = 2,
    kUtcTimeFieldNumber = 3,
    kLocalTimeFieldNumber = 4,
    kNtpServerFieldNumber = 5,
    kDateTimeTypeFieldNumber = 1,
  };
  // string time_zone = 2;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // string utc_time = 3;
  void clear_utc_time();
  const std::string& utc_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_utc_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_utc_time();
  PROTOBUF_NODISCARD std::string* release_utc_time();
  void set_allocated_utc_time(std::string* utc_time);
  private:
  const std::string& _internal_utc_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_utc_time(const std::string& value);
  std::string* _internal_mutable_utc_time();
  public:

  // string local_time = 4;
  void clear_local_time();
  const std::string& local_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_time();
  PROTOBUF_NODISCARD std::string* release_local_time();
  void set_allocated_local_time(std::string* local_time);
  private:
  const std::string& _internal_local_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_time(const std::string& value);
  std::string* _internal_mutable_local_time();
  public:

  // string ntp_server = 5;
  void clear_ntp_server();
  const std::string& ntp_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ntp_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ntp_server();
  PROTOBUF_NODISCARD std::string* release_ntp_server();
  void set_allocated_ntp_server(std::string* ntp_server);
  private:
  const std::string& _internal_ntp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ntp_server(const std::string& value);
  std::string* _internal_mutable_ntp_server();
  public:

  // .ams.device.grpc.DateTimeType date_time_type = 1;
  void clear_date_time_type();
  ::ams::device::grpc::DateTimeType date_time_type() const;
  void set_date_time_type(::ams::device::grpc::DateTimeType value);
  private:
  ::ams::device::grpc::DateTimeType _internal_date_time_type() const;
  void _internal_set_date_time_type(::ams::device::grpc::DateTimeType value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSystemDateAndTimeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utc_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ntp_server_;
    int date_time_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkInterfacesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetNetworkInterfacesResponse) */ {
 public:
  inline GetNetworkInterfacesResponse() : GetNetworkInterfacesResponse(nullptr) {}
  ~GetNetworkInterfacesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetNetworkInterfacesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkInterfacesResponse(const GetNetworkInterfacesResponse& from);
  GetNetworkInterfacesResponse(GetNetworkInterfacesResponse&& from) noexcept
    : GetNetworkInterfacesResponse() {
    *this = ::std::move(from);
  }

  inline GetNetworkInterfacesResponse& operator=(const GetNetworkInterfacesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkInterfacesResponse& operator=(GetNetworkInterfacesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkInterfacesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkInterfacesResponse* internal_default_instance() {
    return reinterpret_cast<const GetNetworkInterfacesResponse*>(
               &_GetNetworkInterfacesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GetNetworkInterfacesResponse& a, GetNetworkInterfacesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkInterfacesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkInterfacesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNetworkInterfacesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNetworkInterfacesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNetworkInterfacesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetNetworkInterfacesResponse& from) {
    GetNetworkInterfacesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkInterfacesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetNetworkInterfacesResponse";
  }
  protected:
  explicit GetNetworkInterfacesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDnsFieldNumber = 5,
    kIpv4AddressFieldNumber = 2,
    kNetmaskFieldNumber = 3,
    kGatewayFieldNumber = 4,
    kHostnameFieldNumber = 6,
    kModeFieldNumber = 1,
  };
  // repeated string dns = 5;
  int dns_size() const;
  private:
  int _internal_dns_size() const;
  public:
  void clear_dns();
  const std::string& dns(int index) const;
  std::string* mutable_dns(int index);
  void set_dns(int index, const std::string& value);
  void set_dns(int index, std::string&& value);
  void set_dns(int index, const char* value);
  void set_dns(int index, const char* value, size_t size);
  std::string* add_dns();
  void add_dns(const std::string& value);
  void add_dns(std::string&& value);
  void add_dns(const char* value);
  void add_dns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dns();
  private:
  const std::string& _internal_dns(int index) const;
  std::string* _internal_add_dns();
  public:

  // string ipv4_address = 2;
  void clear_ipv4_address();
  const std::string& ipv4_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ipv4_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ipv4_address();
  PROTOBUF_NODISCARD std::string* release_ipv4_address();
  void set_allocated_ipv4_address(std::string* ipv4_address);
  private:
  const std::string& _internal_ipv4_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipv4_address(const std::string& value);
  std::string* _internal_mutable_ipv4_address();
  public:

  // string netmask = 3;
  void clear_netmask();
  const std::string& netmask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_netmask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_netmask();
  PROTOBUF_NODISCARD std::string* release_netmask();
  void set_allocated_netmask(std::string* netmask);
  private:
  const std::string& _internal_netmask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_netmask(const std::string& value);
  std::string* _internal_mutable_netmask();
  public:

  // string gateway = 4;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // string hostname = 6;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // .ams.device.grpc.NetworkMode mode = 1;
  void clear_mode();
  ::ams::device::grpc::NetworkMode mode() const;
  void set_mode(::ams::device::grpc::NetworkMode value);
  private:
  ::ams::device::grpc::NetworkMode _internal_mode() const;
  void _internal_set_mode(::ams::device::grpc::NetworkMode value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetNetworkInterfacesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipv4_address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr netmask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSipInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSipInformationResponse) */ {
 public:
  inline GetSipInformationResponse() : GetSipInformationResponse(nullptr) {}
  ~GetSipInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSipInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSipInformationResponse(const GetSipInformationResponse& from);
  GetSipInformationResponse(GetSipInformationResponse&& from) noexcept
    : GetSipInformationResponse() {
    *this = ::std::move(from);
  }

  inline GetSipInformationResponse& operator=(const GetSipInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSipInformationResponse& operator=(GetSipInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSipInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSipInformationResponse* internal_default_instance() {
    return reinterpret_cast<const GetSipInformationResponse*>(
               &_GetSipInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(GetSipInformationResponse& a, GetSipInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSipInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSipInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSipInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSipInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSipInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSipInformationResponse& from) {
    GetSipInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSipInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSipInformationResponse";
  }
  protected:
  explicit GetSipInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
  };
  // repeated .ams.device.grpc.SipAccount accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::ams::device::grpc::SipAccount* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::SipAccount >*
      mutable_accounts();
  private:
  const ::ams::device::grpc::SipAccount& _internal_accounts(int index) const;
  ::ams::device::grpc::SipAccount* _internal_add_accounts();
  public:
  const ::ams::device::grpc::SipAccount& accounts(int index) const;
  ::ams::device::grpc::SipAccount* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::SipAccount >&
      accounts() const;

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSipInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::SipAccount > accounts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetOnvifInformationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetOnvifInformationResponse) */ {
 public:
  inline GetOnvifInformationResponse() : GetOnvifInformationResponse(nullptr) {}
  ~GetOnvifInformationResponse() override;
  explicit PROTOBUF_CONSTEXPR GetOnvifInformationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetOnvifInformationResponse(const GetOnvifInformationResponse& from);
  GetOnvifInformationResponse(GetOnvifInformationResponse&& from) noexcept
    : GetOnvifInformationResponse() {
    *this = ::std::move(from);
  }

  inline GetOnvifInformationResponse& operator=(const GetOnvifInformationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetOnvifInformationResponse& operator=(GetOnvifInformationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetOnvifInformationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetOnvifInformationResponse* internal_default_instance() {
    return reinterpret_cast<const GetOnvifInformationResponse*>(
               &_GetOnvifInformationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetOnvifInformationResponse& a, GetOnvifInformationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetOnvifInformationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetOnvifInformationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetOnvifInformationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetOnvifInformationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetOnvifInformationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetOnvifInformationResponse& from) {
    GetOnvifInformationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOnvifInformationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetOnvifInformationResponse";
  }
  protected:
  explicit GetOnvifInformationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .ams.device.grpc.OnvifUser users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::ams::device::grpc::OnvifUser* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::OnvifUser >*
      mutable_users();
  private:
  const ::ams::device::grpc::OnvifUser& _internal_users(int index) const;
  ::ams::device::grpc::OnvifUser* _internal_add_users();
  public:
  const ::ams::device::grpc::OnvifUser& users(int index) const;
  ::ams::device::grpc::OnvifUser* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::OnvifUser >&
      users() const;

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetOnvifInformationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::OnvifUser > users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetPaAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetPaAddressResponse) */ {
 public:
  inline GetPaAddressResponse() : GetPaAddressResponse(nullptr) {}
  ~GetPaAddressResponse() override;
  explicit PROTOBUF_CONSTEXPR GetPaAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPaAddressResponse(const GetPaAddressResponse& from);
  GetPaAddressResponse(GetPaAddressResponse&& from) noexcept
    : GetPaAddressResponse() {
    *this = ::std::move(from);
  }

  inline GetPaAddressResponse& operator=(const GetPaAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPaAddressResponse& operator=(GetPaAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPaAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPaAddressResponse* internal_default_instance() {
    return reinterpret_cast<const GetPaAddressResponse*>(
               &_GetPaAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetPaAddressResponse& a, GetPaAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPaAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPaAddressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPaAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPaAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPaAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetPaAddressResponse& from) {
    GetPaAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPaAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetPaAddressResponse";
  }
  protected:
  explicit GetPaAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetPaAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetSnapcastAddressResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetSnapcastAddressResponse) */ {
 public:
  inline GetSnapcastAddressResponse() : GetSnapcastAddressResponse(nullptr) {}
  ~GetSnapcastAddressResponse() override;
  explicit PROTOBUF_CONSTEXPR GetSnapcastAddressResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSnapcastAddressResponse(const GetSnapcastAddressResponse& from);
  GetSnapcastAddressResponse(GetSnapcastAddressResponse&& from) noexcept
    : GetSnapcastAddressResponse() {
    *this = ::std::move(from);
  }

  inline GetSnapcastAddressResponse& operator=(const GetSnapcastAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSnapcastAddressResponse& operator=(GetSnapcastAddressResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSnapcastAddressResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSnapcastAddressResponse* internal_default_instance() {
    return reinterpret_cast<const GetSnapcastAddressResponse*>(
               &_GetSnapcastAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(GetSnapcastAddressResponse& a, GetSnapcastAddressResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSnapcastAddressResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSnapcastAddressResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSnapcastAddressResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSnapcastAddressResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSnapcastAddressResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSnapcastAddressResponse& from) {
    GetSnapcastAddressResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSnapcastAddressResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetSnapcastAddressResponse";
  }
  protected:
  explicit GetSnapcastAddressResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetSnapcastAddressResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetVolumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetVolumeResponse) */ {
 public:
  inline GetVolumeResponse() : GetVolumeResponse(nullptr) {}
  ~GetVolumeResponse() override;
  explicit PROTOBUF_CONSTEXPR GetVolumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetVolumeResponse(const GetVolumeResponse& from);
  GetVolumeResponse(GetVolumeResponse&& from) noexcept
    : GetVolumeResponse() {
    *this = ::std::move(from);
  }

  inline GetVolumeResponse& operator=(const GetVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetVolumeResponse& operator=(GetVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const GetVolumeResponse*>(
               &_GetVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(GetVolumeResponse& a, GetVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetVolumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetVolumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetVolumeResponse& from) {
    GetVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVolumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetVolumeResponse";
  }
  protected:
  explicit GetVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpeakerVolumeFieldNumber = 1,
    kMicVolumeFieldNumber = 2,
  };
  // int32 speaker_volume = 1;
  void clear_speaker_volume();
  int32_t speaker_volume() const;
  void set_speaker_volume(int32_t value);
  private:
  int32_t _internal_speaker_volume() const;
  void _internal_set_speaker_volume(int32_t value);
  public:

  // int32 mic_volume = 2;
  void clear_mic_volume();
  int32_t mic_volume() const;
  void set_mic_volume(int32_t value);
  private:
  int32_t _internal_mic_volume() const;
  void _internal_set_mic_volume(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t speaker_volume_;
    int32_t mic_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GetScheduleListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.GetScheduleListResponse) */ {
 public:
  inline GetScheduleListResponse() : GetScheduleListResponse(nullptr) {}
  ~GetScheduleListResponse() override;
  explicit PROTOBUF_CONSTEXPR GetScheduleListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetScheduleListResponse(const GetScheduleListResponse& from);
  GetScheduleListResponse(GetScheduleListResponse&& from) noexcept
    : GetScheduleListResponse() {
    *this = ::std::move(from);
  }

  inline GetScheduleListResponse& operator=(const GetScheduleListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetScheduleListResponse& operator=(GetScheduleListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetScheduleListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetScheduleListResponse* internal_default_instance() {
    return reinterpret_cast<const GetScheduleListResponse*>(
               &_GetScheduleListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(GetScheduleListResponse& a, GetScheduleListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetScheduleListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetScheduleListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetScheduleListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetScheduleListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetScheduleListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetScheduleListResponse& from) {
    GetScheduleListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetScheduleListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.GetScheduleListResponse";
  }
  protected:
  explicit GetScheduleListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchedulesFieldNumber = 1,
  };
  // repeated .ams.device.grpc.Schedule schedules = 1;
  int schedules_size() const;
  private:
  int _internal_schedules_size() const;
  public:
  void clear_schedules();
  ::ams::device::grpc::Schedule* mutable_schedules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::Schedule >*
      mutable_schedules();
  private:
  const ::ams::device::grpc::Schedule& _internal_schedules(int index) const;
  ::ams::device::grpc::Schedule* _internal_add_schedules();
  public:
  const ::ams::device::grpc::Schedule& schedules(int index) const;
  ::ams::device::grpc::Schedule* add_schedules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::Schedule >&
      schedules() const;

  // @@protoc_insertion_point(class_scope:ams.device.grpc.GetScheduleListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::Schedule > schedules_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SystemRebootResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.SystemRebootResponse) */ {
 public:
  inline SystemRebootResponse() : SystemRebootResponse(nullptr) {}
  ~SystemRebootResponse() override;
  explicit PROTOBUF_CONSTEXPR SystemRebootResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemRebootResponse(const SystemRebootResponse& from);
  SystemRebootResponse(SystemRebootResponse&& from) noexcept
    : SystemRebootResponse() {
    *this = ::std::move(from);
  }

  inline SystemRebootResponse& operator=(const SystemRebootResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemRebootResponse& operator=(SystemRebootResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemRebootResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemRebootResponse* internal_default_instance() {
    return reinterpret_cast<const SystemRebootResponse*>(
               &_SystemRebootResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SystemRebootResponse& a, SystemRebootResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemRebootResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemRebootResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemRebootResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemRebootResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemRebootResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemRebootResponse& from) {
    SystemRebootResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemRebootResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.SystemRebootResponse";
  }
  protected:
  explicit SystemRebootResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.SystemRebootResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class InitSessionNotify final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.InitSessionNotify) */ {
 public:
  inline InitSessionNotify() : InitSessionNotify(nullptr) {}
  ~InitSessionNotify() override;
  explicit PROTOBUF_CONSTEXPR InitSessionNotify(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitSessionNotify(const InitSessionNotify& from);
  InitSessionNotify(InitSessionNotify&& from) noexcept
    : InitSessionNotify() {
    *this = ::std::move(from);
  }

  inline InitSessionNotify& operator=(const InitSessionNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitSessionNotify& operator=(InitSessionNotify&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitSessionNotify& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitSessionNotify* internal_default_instance() {
    return reinterpret_cast<const InitSessionNotify*>(
               &_InitSessionNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(InitSessionNotify& a, InitSessionNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(InitSessionNotify* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitSessionNotify* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitSessionNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitSessionNotify>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitSessionNotify& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitSessionNotify& from) {
    InitSessionNotify::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitSessionNotify* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.InitSessionNotify";
  }
  protected:
  explicit InitSessionNotify(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 1,
  };
  // string mac_address = 1;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // @@protoc_insertion_point(class_scope:ams.device.grpc.InitSessionNotify)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class ServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.ServerMessage) */ {
 public:
  inline ServerMessage() : ServerMessage(nullptr) {}
  ~ServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMessage(const ServerMessage& from);
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kSetDeviceInformation = 2,
    kGetSystemDateAndTime = 3,
    kSetSystemDateAndTime = 4,
    kGetNetworkInterfaces = 5,
    kSetNetworkInterfaces = 6,
    kGetSipInformation = 7,
    kAddSipUser = 8,
    kDeleteSipUser = 9,
    kSetSipUser = 10,
    kGetOnvifInformation = 11,
    kAddOnvifUser = 12,
    kDeleteOnvifUser = 13,
    kSetOnvifUser = 14,
    kGetPaAddress = 15,
    kSetPaAddress = 16,
    kGetSnapcastAddress = 17,
    kSetSnapcastAddress = 18,
    kGetVolume = 19,
    kSetVolume = 20,
    kGetScheduleList = 21,
    kAddSchedule = 22,
    kDeleteSchedule = 23,
    kSetSchedule = 24,
    kExceptionSchedule = 25,
    kStartBroadcast = 26,
    kStopBroadcast = 27,
    kAddAudioClip = 28,
    kEditAudioClip = 29,
    kDeleteAudioClip = 30,
    kSystemReboot = 31,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMessage& from) {
    ServerMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.ServerMessage";
  }
  protected:
  explicit ServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kSetDeviceInformationFieldNumber = 2,
    kGetSystemDateAndTimeFieldNumber = 3,
    kSetSystemDateAndTimeFieldNumber = 4,
    kGetNetworkInterfacesFieldNumber = 5,
    kSetNetworkInterfacesFieldNumber = 6,
    kGetSipInformationFieldNumber = 7,
    kAddSipUserFieldNumber = 8,
    kDeleteSipUserFieldNumber = 9,
    kSetSipUserFieldNumber = 10,
    kGetOnvifInformationFieldNumber = 11,
    kAddOnvifUserFieldNumber = 12,
    kDeleteOnvifUserFieldNumber = 13,
    kSetOnvifUserFieldNumber = 14,
    kGetPaAddressFieldNumber = 15,
    kSetPaAddressFieldNumber = 16,
    kGetSnapcastAddressFieldNumber = 17,
    kSetSnapcastAddressFieldNumber = 18,
    kGetVolumeFieldNumber = 19,
    kSetVolumeFieldNumber = 20,
    kGetScheduleListFieldNumber = 21,
    kAddScheduleFieldNumber = 22,
    kDeleteScheduleFieldNumber = 23,
    kSetScheduleFieldNumber = 24,
    kExceptionScheduleFieldNumber = 25,
    kStartBroadcastFieldNumber = 26,
    kStopBroadcastFieldNumber = 27,
    kAddAudioClipFieldNumber = 28,
    kEditAudioClipFieldNumber = 29,
    kDeleteAudioClipFieldNumber = 30,
    kSystemRebootFieldNumber = 31,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .ams.device.grpc.SetDeviceInformationRequest set_device_information = 2;
  bool has_set_device_information() const;
  private:
  bool _internal_has_set_device_information() const;
  public:
  void clear_set_device_information();
  const ::ams::device::grpc::SetDeviceInformationRequest& set_device_information() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetDeviceInformationRequest* release_set_device_information();
  ::ams::device::grpc::SetDeviceInformationRequest* mutable_set_device_information();
  void set_allocated_set_device_information(::ams::device::grpc::SetDeviceInformationRequest* set_device_information);
  private:
  const ::ams::device::grpc::SetDeviceInformationRequest& _internal_set_device_information() const;
  ::ams::device::grpc::SetDeviceInformationRequest* _internal_mutable_set_device_information();
  public:
  void unsafe_arena_set_allocated_set_device_information(
      ::ams::device::grpc::SetDeviceInformationRequest* set_device_information);
  ::ams::device::grpc::SetDeviceInformationRequest* unsafe_arena_release_set_device_information();

  // .ams.device.grpc.GetSystemDateAndTimeRequest get_system_date_and_time = 3;
  bool has_get_system_date_and_time() const;
  private:
  bool _internal_has_get_system_date_and_time() const;
  public:
  void clear_get_system_date_and_time();
  const ::ams::device::grpc::GetSystemDateAndTimeRequest& get_system_date_and_time() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSystemDateAndTimeRequest* release_get_system_date_and_time();
  ::ams::device::grpc::GetSystemDateAndTimeRequest* mutable_get_system_date_and_time();
  void set_allocated_get_system_date_and_time(::ams::device::grpc::GetSystemDateAndTimeRequest* get_system_date_and_time);
  private:
  const ::ams::device::grpc::GetSystemDateAndTimeRequest& _internal_get_system_date_and_time() const;
  ::ams::device::grpc::GetSystemDateAndTimeRequest* _internal_mutable_get_system_date_and_time();
  public:
  void unsafe_arena_set_allocated_get_system_date_and_time(
      ::ams::device::grpc::GetSystemDateAndTimeRequest* get_system_date_and_time);
  ::ams::device::grpc::GetSystemDateAndTimeRequest* unsafe_arena_release_get_system_date_and_time();

  // .ams.device.grpc.SetSystemDateAndTimeRequest set_system_date_and_time = 4;
  bool has_set_system_date_and_time() const;
  private:
  bool _internal_has_set_system_date_and_time() const;
  public:
  void clear_set_system_date_and_time();
  const ::ams::device::grpc::SetSystemDateAndTimeRequest& set_system_date_and_time() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetSystemDateAndTimeRequest* release_set_system_date_and_time();
  ::ams::device::grpc::SetSystemDateAndTimeRequest* mutable_set_system_date_and_time();
  void set_allocated_set_system_date_and_time(::ams::device::grpc::SetSystemDateAndTimeRequest* set_system_date_and_time);
  private:
  const ::ams::device::grpc::SetSystemDateAndTimeRequest& _internal_set_system_date_and_time() const;
  ::ams::device::grpc::SetSystemDateAndTimeRequest* _internal_mutable_set_system_date_and_time();
  public:
  void unsafe_arena_set_allocated_set_system_date_and_time(
      ::ams::device::grpc::SetSystemDateAndTimeRequest* set_system_date_and_time);
  ::ams::device::grpc::SetSystemDateAndTimeRequest* unsafe_arena_release_set_system_date_and_time();

  // .ams.device.grpc.GetNetworkInterfacesRequest get_network_interfaces = 5;
  bool has_get_network_interfaces() const;
  private:
  bool _internal_has_get_network_interfaces() const;
  public:
  void clear_get_network_interfaces();
  const ::ams::device::grpc::GetNetworkInterfacesRequest& get_network_interfaces() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetNetworkInterfacesRequest* release_get_network_interfaces();
  ::ams::device::grpc::GetNetworkInterfacesRequest* mutable_get_network_interfaces();
  void set_allocated_get_network_interfaces(::ams::device::grpc::GetNetworkInterfacesRequest* get_network_interfaces);
  private:
  const ::ams::device::grpc::GetNetworkInterfacesRequest& _internal_get_network_interfaces() const;
  ::ams::device::grpc::GetNetworkInterfacesRequest* _internal_mutable_get_network_interfaces();
  public:
  void unsafe_arena_set_allocated_get_network_interfaces(
      ::ams::device::grpc::GetNetworkInterfacesRequest* get_network_interfaces);
  ::ams::device::grpc::GetNetworkInterfacesRequest* unsafe_arena_release_get_network_interfaces();

  // .ams.device.grpc.SetNetworkInterfacesRequest set_network_interfaces = 6;
  bool has_set_network_interfaces() const;
  private:
  bool _internal_has_set_network_interfaces() const;
  public:
  void clear_set_network_interfaces();
  const ::ams::device::grpc::SetNetworkInterfacesRequest& set_network_interfaces() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetNetworkInterfacesRequest* release_set_network_interfaces();
  ::ams::device::grpc::SetNetworkInterfacesRequest* mutable_set_network_interfaces();
  void set_allocated_set_network_interfaces(::ams::device::grpc::SetNetworkInterfacesRequest* set_network_interfaces);
  private:
  const ::ams::device::grpc::SetNetworkInterfacesRequest& _internal_set_network_interfaces() const;
  ::ams::device::grpc::SetNetworkInterfacesRequest* _internal_mutable_set_network_interfaces();
  public:
  void unsafe_arena_set_allocated_set_network_interfaces(
      ::ams::device::grpc::SetNetworkInterfacesRequest* set_network_interfaces);
  ::ams::device::grpc::SetNetworkInterfacesRequest* unsafe_arena_release_set_network_interfaces();

  // .ams.device.grpc.GetSipInformationRequest get_sip_information = 7;
  bool has_get_sip_information() const;
  private:
  bool _internal_has_get_sip_information() const;
  public:
  void clear_get_sip_information();
  const ::ams::device::grpc::GetSipInformationRequest& get_sip_information() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSipInformationRequest* release_get_sip_information();
  ::ams::device::grpc::GetSipInformationRequest* mutable_get_sip_information();
  void set_allocated_get_sip_information(::ams::device::grpc::GetSipInformationRequest* get_sip_information);
  private:
  const ::ams::device::grpc::GetSipInformationRequest& _internal_get_sip_information() const;
  ::ams::device::grpc::GetSipInformationRequest* _internal_mutable_get_sip_information();
  public:
  void unsafe_arena_set_allocated_get_sip_information(
      ::ams::device::grpc::GetSipInformationRequest* get_sip_information);
  ::ams::device::grpc::GetSipInformationRequest* unsafe_arena_release_get_sip_information();

  // .ams.device.grpc.AddSipUserRequest add_sip_user = 8;
  bool has_add_sip_user() const;
  private:
  bool _internal_has_add_sip_user() const;
  public:
  void clear_add_sip_user();
  const ::ams::device::grpc::AddSipUserRequest& add_sip_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::AddSipUserRequest* release_add_sip_user();
  ::ams::device::grpc::AddSipUserRequest* mutable_add_sip_user();
  void set_allocated_add_sip_user(::ams::device::grpc::AddSipUserRequest* add_sip_user);
  private:
  const ::ams::device::grpc::AddSipUserRequest& _internal_add_sip_user() const;
  ::ams::device::grpc::AddSipUserRequest* _internal_mutable_add_sip_user();
  public:
  void unsafe_arena_set_allocated_add_sip_user(
      ::ams::device::grpc::AddSipUserRequest* add_sip_user);
  ::ams::device::grpc::AddSipUserRequest* unsafe_arena_release_add_sip_user();

  // .ams.device.grpc.DeleteSipUserRequest delete_sip_user = 9;
  bool has_delete_sip_user() const;
  private:
  bool _internal_has_delete_sip_user() const;
  public:
  void clear_delete_sip_user();
  const ::ams::device::grpc::DeleteSipUserRequest& delete_sip_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::DeleteSipUserRequest* release_delete_sip_user();
  ::ams::device::grpc::DeleteSipUserRequest* mutable_delete_sip_user();
  void set_allocated_delete_sip_user(::ams::device::grpc::DeleteSipUserRequest* delete_sip_user);
  private:
  const ::ams::device::grpc::DeleteSipUserRequest& _internal_delete_sip_user() const;
  ::ams::device::grpc::DeleteSipUserRequest* _internal_mutable_delete_sip_user();
  public:
  void unsafe_arena_set_allocated_delete_sip_user(
      ::ams::device::grpc::DeleteSipUserRequest* delete_sip_user);
  ::ams::device::grpc::DeleteSipUserRequest* unsafe_arena_release_delete_sip_user();

  // .ams.device.grpc.SetSipUserRequest set_sip_user = 10;
  bool has_set_sip_user() const;
  private:
  bool _internal_has_set_sip_user() const;
  public:
  void clear_set_sip_user();
  const ::ams::device::grpc::SetSipUserRequest& set_sip_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetSipUserRequest* release_set_sip_user();
  ::ams::device::grpc::SetSipUserRequest* mutable_set_sip_user();
  void set_allocated_set_sip_user(::ams::device::grpc::SetSipUserRequest* set_sip_user);
  private:
  const ::ams::device::grpc::SetSipUserRequest& _internal_set_sip_user() const;
  ::ams::device::grpc::SetSipUserRequest* _internal_mutable_set_sip_user();
  public:
  void unsafe_arena_set_allocated_set_sip_user(
      ::ams::device::grpc::SetSipUserRequest* set_sip_user);
  ::ams::device::grpc::SetSipUserRequest* unsafe_arena_release_set_sip_user();

  // .ams.device.grpc.GetOnvifInformationRequest get_onvif_information = 11;
  bool has_get_onvif_information() const;
  private:
  bool _internal_has_get_onvif_information() const;
  public:
  void clear_get_onvif_information();
  const ::ams::device::grpc::GetOnvifInformationRequest& get_onvif_information() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetOnvifInformationRequest* release_get_onvif_information();
  ::ams::device::grpc::GetOnvifInformationRequest* mutable_get_onvif_information();
  void set_allocated_get_onvif_information(::ams::device::grpc::GetOnvifInformationRequest* get_onvif_information);
  private:
  const ::ams::device::grpc::GetOnvifInformationRequest& _internal_get_onvif_information() const;
  ::ams::device::grpc::GetOnvifInformationRequest* _internal_mutable_get_onvif_information();
  public:
  void unsafe_arena_set_allocated_get_onvif_information(
      ::ams::device::grpc::GetOnvifInformationRequest* get_onvif_information);
  ::ams::device::grpc::GetOnvifInformationRequest* unsafe_arena_release_get_onvif_information();

  // .ams.device.grpc.AddOnvifUserRequest add_onvif_user = 12;
  bool has_add_onvif_user() const;
  private:
  bool _internal_has_add_onvif_user() const;
  public:
  void clear_add_onvif_user();
  const ::ams::device::grpc::AddOnvifUserRequest& add_onvif_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::AddOnvifUserRequest* release_add_onvif_user();
  ::ams::device::grpc::AddOnvifUserRequest* mutable_add_onvif_user();
  void set_allocated_add_onvif_user(::ams::device::grpc::AddOnvifUserRequest* add_onvif_user);
  private:
  const ::ams::device::grpc::AddOnvifUserRequest& _internal_add_onvif_user() const;
  ::ams::device::grpc::AddOnvifUserRequest* _internal_mutable_add_onvif_user();
  public:
  void unsafe_arena_set_allocated_add_onvif_user(
      ::ams::device::grpc::AddOnvifUserRequest* add_onvif_user);
  ::ams::device::grpc::AddOnvifUserRequest* unsafe_arena_release_add_onvif_user();

  // .ams.device.grpc.DeleteOnvifUserRequest delete_onvif_user = 13;
  bool has_delete_onvif_user() const;
  private:
  bool _internal_has_delete_onvif_user() const;
  public:
  void clear_delete_onvif_user();
  const ::ams::device::grpc::DeleteOnvifUserRequest& delete_onvif_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::DeleteOnvifUserRequest* release_delete_onvif_user();
  ::ams::device::grpc::DeleteOnvifUserRequest* mutable_delete_onvif_user();
  void set_allocated_delete_onvif_user(::ams::device::grpc::DeleteOnvifUserRequest* delete_onvif_user);
  private:
  const ::ams::device::grpc::DeleteOnvifUserRequest& _internal_delete_onvif_user() const;
  ::ams::device::grpc::DeleteOnvifUserRequest* _internal_mutable_delete_onvif_user();
  public:
  void unsafe_arena_set_allocated_delete_onvif_user(
      ::ams::device::grpc::DeleteOnvifUserRequest* delete_onvif_user);
  ::ams::device::grpc::DeleteOnvifUserRequest* unsafe_arena_release_delete_onvif_user();

  // .ams.device.grpc.SetOnvifUserRequest set_onvif_user = 14;
  bool has_set_onvif_user() const;
  private:
  bool _internal_has_set_onvif_user() const;
  public:
  void clear_set_onvif_user();
  const ::ams::device::grpc::SetOnvifUserRequest& set_onvif_user() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetOnvifUserRequest* release_set_onvif_user();
  ::ams::device::grpc::SetOnvifUserRequest* mutable_set_onvif_user();
  void set_allocated_set_onvif_user(::ams::device::grpc::SetOnvifUserRequest* set_onvif_user);
  private:
  const ::ams::device::grpc::SetOnvifUserRequest& _internal_set_onvif_user() const;
  ::ams::device::grpc::SetOnvifUserRequest* _internal_mutable_set_onvif_user();
  public:
  void unsafe_arena_set_allocated_set_onvif_user(
      ::ams::device::grpc::SetOnvifUserRequest* set_onvif_user);
  ::ams::device::grpc::SetOnvifUserRequest* unsafe_arena_release_set_onvif_user();

  // .ams.device.grpc.GetPaAddressRequest get_pa_address = 15;
  bool has_get_pa_address() const;
  private:
  bool _internal_has_get_pa_address() const;
  public:
  void clear_get_pa_address();
  const ::ams::device::grpc::GetPaAddressRequest& get_pa_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetPaAddressRequest* release_get_pa_address();
  ::ams::device::grpc::GetPaAddressRequest* mutable_get_pa_address();
  void set_allocated_get_pa_address(::ams::device::grpc::GetPaAddressRequest* get_pa_address);
  private:
  const ::ams::device::grpc::GetPaAddressRequest& _internal_get_pa_address() const;
  ::ams::device::grpc::GetPaAddressRequest* _internal_mutable_get_pa_address();
  public:
  void unsafe_arena_set_allocated_get_pa_address(
      ::ams::device::grpc::GetPaAddressRequest* get_pa_address);
  ::ams::device::grpc::GetPaAddressRequest* unsafe_arena_release_get_pa_address();

  // .ams.device.grpc.SetPaAddressRequest set_pa_address = 16;
  bool has_set_pa_address() const;
  private:
  bool _internal_has_set_pa_address() const;
  public:
  void clear_set_pa_address();
  const ::ams::device::grpc::SetPaAddressRequest& set_pa_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetPaAddressRequest* release_set_pa_address();
  ::ams::device::grpc::SetPaAddressRequest* mutable_set_pa_address();
  void set_allocated_set_pa_address(::ams::device::grpc::SetPaAddressRequest* set_pa_address);
  private:
  const ::ams::device::grpc::SetPaAddressRequest& _internal_set_pa_address() const;
  ::ams::device::grpc::SetPaAddressRequest* _internal_mutable_set_pa_address();
  public:
  void unsafe_arena_set_allocated_set_pa_address(
      ::ams::device::grpc::SetPaAddressRequest* set_pa_address);
  ::ams::device::grpc::SetPaAddressRequest* unsafe_arena_release_set_pa_address();

  // .ams.device.grpc.GetSnapcastAddressRequest get_snapcast_address = 17;
  bool has_get_snapcast_address() const;
  private:
  bool _internal_has_get_snapcast_address() const;
  public:
  void clear_get_snapcast_address();
  const ::ams::device::grpc::GetSnapcastAddressRequest& get_snapcast_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSnapcastAddressRequest* release_get_snapcast_address();
  ::ams::device::grpc::GetSnapcastAddressRequest* mutable_get_snapcast_address();
  void set_allocated_get_snapcast_address(::ams::device::grpc::GetSnapcastAddressRequest* get_snapcast_address);
  private:
  const ::ams::device::grpc::GetSnapcastAddressRequest& _internal_get_snapcast_address() const;
  ::ams::device::grpc::GetSnapcastAddressRequest* _internal_mutable_get_snapcast_address();
  public:
  void unsafe_arena_set_allocated_get_snapcast_address(
      ::ams::device::grpc::GetSnapcastAddressRequest* get_snapcast_address);
  ::ams::device::grpc::GetSnapcastAddressRequest* unsafe_arena_release_get_snapcast_address();

  // .ams.device.grpc.SetSnapcastAddressRequest set_snapcast_address = 18;
  bool has_set_snapcast_address() const;
  private:
  bool _internal_has_set_snapcast_address() const;
  public:
  void clear_set_snapcast_address();
  const ::ams::device::grpc::SetSnapcastAddressRequest& set_snapcast_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetSnapcastAddressRequest* release_set_snapcast_address();
  ::ams::device::grpc::SetSnapcastAddressRequest* mutable_set_snapcast_address();
  void set_allocated_set_snapcast_address(::ams::device::grpc::SetSnapcastAddressRequest* set_snapcast_address);
  private:
  const ::ams::device::grpc::SetSnapcastAddressRequest& _internal_set_snapcast_address() const;
  ::ams::device::grpc::SetSnapcastAddressRequest* _internal_mutable_set_snapcast_address();
  public:
  void unsafe_arena_set_allocated_set_snapcast_address(
      ::ams::device::grpc::SetSnapcastAddressRequest* set_snapcast_address);
  ::ams::device::grpc::SetSnapcastAddressRequest* unsafe_arena_release_set_snapcast_address();

  // .ams.device.grpc.GetVolumeRequest get_volume = 19;
  bool has_get_volume() const;
  private:
  bool _internal_has_get_volume() const;
  public:
  void clear_get_volume();
  const ::ams::device::grpc::GetVolumeRequest& get_volume() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetVolumeRequest* release_get_volume();
  ::ams::device::grpc::GetVolumeRequest* mutable_get_volume();
  void set_allocated_get_volume(::ams::device::grpc::GetVolumeRequest* get_volume);
  private:
  const ::ams::device::grpc::GetVolumeRequest& _internal_get_volume() const;
  ::ams::device::grpc::GetVolumeRequest* _internal_mutable_get_volume();
  public:
  void unsafe_arena_set_allocated_get_volume(
      ::ams::device::grpc::GetVolumeRequest* get_volume);
  ::ams::device::grpc::GetVolumeRequest* unsafe_arena_release_get_volume();

  // .ams.device.grpc.SetVolumeRequest set_volume = 20;
  bool has_set_volume() const;
  private:
  bool _internal_has_set_volume() const;
  public:
  void clear_set_volume();
  const ::ams::device::grpc::SetVolumeRequest& set_volume() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetVolumeRequest* release_set_volume();
  ::ams::device::grpc::SetVolumeRequest* mutable_set_volume();
  void set_allocated_set_volume(::ams::device::grpc::SetVolumeRequest* set_volume);
  private:
  const ::ams::device::grpc::SetVolumeRequest& _internal_set_volume() const;
  ::ams::device::grpc::SetVolumeRequest* _internal_mutable_set_volume();
  public:
  void unsafe_arena_set_allocated_set_volume(
      ::ams::device::grpc::SetVolumeRequest* set_volume);
  ::ams::device::grpc::SetVolumeRequest* unsafe_arena_release_set_volume();

  // .ams.device.grpc.GetScheduleListRequest get_schedule_list = 21;
  bool has_get_schedule_list() const;
  private:
  bool _internal_has_get_schedule_list() const;
  public:
  void clear_get_schedule_list();
  const ::ams::device::grpc::GetScheduleListRequest& get_schedule_list() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetScheduleListRequest* release_get_schedule_list();
  ::ams::device::grpc::GetScheduleListRequest* mutable_get_schedule_list();
  void set_allocated_get_schedule_list(::ams::device::grpc::GetScheduleListRequest* get_schedule_list);
  private:
  const ::ams::device::grpc::GetScheduleListRequest& _internal_get_schedule_list() const;
  ::ams::device::grpc::GetScheduleListRequest* _internal_mutable_get_schedule_list();
  public:
  void unsafe_arena_set_allocated_get_schedule_list(
      ::ams::device::grpc::GetScheduleListRequest* get_schedule_list);
  ::ams::device::grpc::GetScheduleListRequest* unsafe_arena_release_get_schedule_list();

  // .ams.device.grpc.AddScheduleRequest add_schedule = 22;
  bool has_add_schedule() const;
  private:
  bool _internal_has_add_schedule() const;
  public:
  void clear_add_schedule();
  const ::ams::device::grpc::AddScheduleRequest& add_schedule() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::AddScheduleRequest* release_add_schedule();
  ::ams::device::grpc::AddScheduleRequest* mutable_add_schedule();
  void set_allocated_add_schedule(::ams::device::grpc::AddScheduleRequest* add_schedule);
  private:
  const ::ams::device::grpc::AddScheduleRequest& _internal_add_schedule() const;
  ::ams::device::grpc::AddScheduleRequest* _internal_mutable_add_schedule();
  public:
  void unsafe_arena_set_allocated_add_schedule(
      ::ams::device::grpc::AddScheduleRequest* add_schedule);
  ::ams::device::grpc::AddScheduleRequest* unsafe_arena_release_add_schedule();

  // .ams.device.grpc.DeleteScheduleRequest delete_schedule = 23;
  bool has_delete_schedule() const;
  private:
  bool _internal_has_delete_schedule() const;
  public:
  void clear_delete_schedule();
  const ::ams::device::grpc::DeleteScheduleRequest& delete_schedule() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::DeleteScheduleRequest* release_delete_schedule();
  ::ams::device::grpc::DeleteScheduleRequest* mutable_delete_schedule();
  void set_allocated_delete_schedule(::ams::device::grpc::DeleteScheduleRequest* delete_schedule);
  private:
  const ::ams::device::grpc::DeleteScheduleRequest& _internal_delete_schedule() const;
  ::ams::device::grpc::DeleteScheduleRequest* _internal_mutable_delete_schedule();
  public:
  void unsafe_arena_set_allocated_delete_schedule(
      ::ams::device::grpc::DeleteScheduleRequest* delete_schedule);
  ::ams::device::grpc::DeleteScheduleRequest* unsafe_arena_release_delete_schedule();

  // .ams.device.grpc.SetScheduleRequest set_schedule = 24;
  bool has_set_schedule() const;
  private:
  bool _internal_has_set_schedule() const;
  public:
  void clear_set_schedule();
  const ::ams::device::grpc::SetScheduleRequest& set_schedule() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SetScheduleRequest* release_set_schedule();
  ::ams::device::grpc::SetScheduleRequest* mutable_set_schedule();
  void set_allocated_set_schedule(::ams::device::grpc::SetScheduleRequest* set_schedule);
  private:
  const ::ams::device::grpc::SetScheduleRequest& _internal_set_schedule() const;
  ::ams::device::grpc::SetScheduleRequest* _internal_mutable_set_schedule();
  public:
  void unsafe_arena_set_allocated_set_schedule(
      ::ams::device::grpc::SetScheduleRequest* set_schedule);
  ::ams::device::grpc::SetScheduleRequest* unsafe_arena_release_set_schedule();

  // .ams.device.grpc.ExceptionScheduleRequest exception_schedule = 25;
  bool has_exception_schedule() const;
  private:
  bool _internal_has_exception_schedule() const;
  public:
  void clear_exception_schedule();
  const ::ams::device::grpc::ExceptionScheduleRequest& exception_schedule() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::ExceptionScheduleRequest* release_exception_schedule();
  ::ams::device::grpc::ExceptionScheduleRequest* mutable_exception_schedule();
  void set_allocated_exception_schedule(::ams::device::grpc::ExceptionScheduleRequest* exception_schedule);
  private:
  const ::ams::device::grpc::ExceptionScheduleRequest& _internal_exception_schedule() const;
  ::ams::device::grpc::ExceptionScheduleRequest* _internal_mutable_exception_schedule();
  public:
  void unsafe_arena_set_allocated_exception_schedule(
      ::ams::device::grpc::ExceptionScheduleRequest* exception_schedule);
  ::ams::device::grpc::ExceptionScheduleRequest* unsafe_arena_release_exception_schedule();

  // .ams.device.grpc.StartBroadcastRequest start_broadcast = 26;
  bool has_start_broadcast() const;
  private:
  bool _internal_has_start_broadcast() const;
  public:
  void clear_start_broadcast();
  const ::ams::device::grpc::StartBroadcastRequest& start_broadcast() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::StartBroadcastRequest* release_start_broadcast();
  ::ams::device::grpc::StartBroadcastRequest* mutable_start_broadcast();
  void set_allocated_start_broadcast(::ams::device::grpc::StartBroadcastRequest* start_broadcast);
  private:
  const ::ams::device::grpc::StartBroadcastRequest& _internal_start_broadcast() const;
  ::ams::device::grpc::StartBroadcastRequest* _internal_mutable_start_broadcast();
  public:
  void unsafe_arena_set_allocated_start_broadcast(
      ::ams::device::grpc::StartBroadcastRequest* start_broadcast);
  ::ams::device::grpc::StartBroadcastRequest* unsafe_arena_release_start_broadcast();

  // .ams.device.grpc.StopBroadcastRequest stop_broadcast = 27;
  bool has_stop_broadcast() const;
  private:
  bool _internal_has_stop_broadcast() const;
  public:
  void clear_stop_broadcast();
  const ::ams::device::grpc::StopBroadcastRequest& stop_broadcast() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::StopBroadcastRequest* release_stop_broadcast();
  ::ams::device::grpc::StopBroadcastRequest* mutable_stop_broadcast();
  void set_allocated_stop_broadcast(::ams::device::grpc::StopBroadcastRequest* stop_broadcast);
  private:
  const ::ams::device::grpc::StopBroadcastRequest& _internal_stop_broadcast() const;
  ::ams::device::grpc::StopBroadcastRequest* _internal_mutable_stop_broadcast();
  public:
  void unsafe_arena_set_allocated_stop_broadcast(
      ::ams::device::grpc::StopBroadcastRequest* stop_broadcast);
  ::ams::device::grpc::StopBroadcastRequest* unsafe_arena_release_stop_broadcast();

  // .ams.device.grpc.AddAudioClipRequest add_audio_clip = 28;
  bool has_add_audio_clip() const;
  private:
  bool _internal_has_add_audio_clip() const;
  public:
  void clear_add_audio_clip();
  const ::ams::device::grpc::AddAudioClipRequest& add_audio_clip() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::AddAudioClipRequest* release_add_audio_clip();
  ::ams::device::grpc::AddAudioClipRequest* mutable_add_audio_clip();
  void set_allocated_add_audio_clip(::ams::device::grpc::AddAudioClipRequest* add_audio_clip);
  private:
  const ::ams::device::grpc::AddAudioClipRequest& _internal_add_audio_clip() const;
  ::ams::device::grpc::AddAudioClipRequest* _internal_mutable_add_audio_clip();
  public:
  void unsafe_arena_set_allocated_add_audio_clip(
      ::ams::device::grpc::AddAudioClipRequest* add_audio_clip);
  ::ams::device::grpc::AddAudioClipRequest* unsafe_arena_release_add_audio_clip();

  // .ams.device.grpc.EditAudioClipRequest edit_audio_clip = 29;
  bool has_edit_audio_clip() const;
  private:
  bool _internal_has_edit_audio_clip() const;
  public:
  void clear_edit_audio_clip();
  const ::ams::device::grpc::EditAudioClipRequest& edit_audio_clip() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::EditAudioClipRequest* release_edit_audio_clip();
  ::ams::device::grpc::EditAudioClipRequest* mutable_edit_audio_clip();
  void set_allocated_edit_audio_clip(::ams::device::grpc::EditAudioClipRequest* edit_audio_clip);
  private:
  const ::ams::device::grpc::EditAudioClipRequest& _internal_edit_audio_clip() const;
  ::ams::device::grpc::EditAudioClipRequest* _internal_mutable_edit_audio_clip();
  public:
  void unsafe_arena_set_allocated_edit_audio_clip(
      ::ams::device::grpc::EditAudioClipRequest* edit_audio_clip);
  ::ams::device::grpc::EditAudioClipRequest* unsafe_arena_release_edit_audio_clip();

  // .ams.device.grpc.DeleteAudioClipRequest delete_audio_clip = 30;
  bool has_delete_audio_clip() const;
  private:
  bool _internal_has_delete_audio_clip() const;
  public:
  void clear_delete_audio_clip();
  const ::ams::device::grpc::DeleteAudioClipRequest& delete_audio_clip() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::DeleteAudioClipRequest* release_delete_audio_clip();
  ::ams::device::grpc::DeleteAudioClipRequest* mutable_delete_audio_clip();
  void set_allocated_delete_audio_clip(::ams::device::grpc::DeleteAudioClipRequest* delete_audio_clip);
  private:
  const ::ams::device::grpc::DeleteAudioClipRequest& _internal_delete_audio_clip() const;
  ::ams::device::grpc::DeleteAudioClipRequest* _internal_mutable_delete_audio_clip();
  public:
  void unsafe_arena_set_allocated_delete_audio_clip(
      ::ams::device::grpc::DeleteAudioClipRequest* delete_audio_clip);
  ::ams::device::grpc::DeleteAudioClipRequest* unsafe_arena_release_delete_audio_clip();

  // .ams.device.grpc.SystemRebootRequest system_reboot = 31;
  bool has_system_reboot() const;
  private:
  bool _internal_has_system_reboot() const;
  public:
  void clear_system_reboot();
  const ::ams::device::grpc::SystemRebootRequest& system_reboot() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SystemRebootRequest* release_system_reboot();
  ::ams::device::grpc::SystemRebootRequest* mutable_system_reboot();
  void set_allocated_system_reboot(::ams::device::grpc::SystemRebootRequest* system_reboot);
  private:
  const ::ams::device::grpc::SystemRebootRequest& _internal_system_reboot() const;
  ::ams::device::grpc::SystemRebootRequest* _internal_mutable_system_reboot();
  public:
  void unsafe_arena_set_allocated_system_reboot(
      ::ams::device::grpc::SystemRebootRequest* system_reboot);
  ::ams::device::grpc::SystemRebootRequest* unsafe_arena_release_system_reboot();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ams.device.grpc.ServerMessage)
 private:
  class _Internal;
  void set_has_set_device_information();
  void set_has_get_system_date_and_time();
  void set_has_set_system_date_and_time();
  void set_has_get_network_interfaces();
  void set_has_set_network_interfaces();
  void set_has_get_sip_information();
  void set_has_add_sip_user();
  void set_has_delete_sip_user();
  void set_has_set_sip_user();
  void set_has_get_onvif_information();
  void set_has_add_onvif_user();
  void set_has_delete_onvif_user();
  void set_has_set_onvif_user();
  void set_has_get_pa_address();
  void set_has_set_pa_address();
  void set_has_get_snapcast_address();
  void set_has_set_snapcast_address();
  void set_has_get_volume();
  void set_has_set_volume();
  void set_has_get_schedule_list();
  void set_has_add_schedule();
  void set_has_delete_schedule();
  void set_has_set_schedule();
  void set_has_exception_schedule();
  void set_has_start_broadcast();
  void set_has_stop_broadcast();
  void set_has_add_audio_clip();
  void set_has_edit_audio_clip();
  void set_has_delete_audio_clip();
  void set_has_system_reboot();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ams::device::grpc::SetDeviceInformationRequest* set_device_information_;
      ::ams::device::grpc::GetSystemDateAndTimeRequest* get_system_date_and_time_;
      ::ams::device::grpc::SetSystemDateAndTimeRequest* set_system_date_and_time_;
      ::ams::device::grpc::GetNetworkInterfacesRequest* get_network_interfaces_;
      ::ams::device::grpc::SetNetworkInterfacesRequest* set_network_interfaces_;
      ::ams::device::grpc::GetSipInformationRequest* get_sip_information_;
      ::ams::device::grpc::AddSipUserRequest* add_sip_user_;
      ::ams::device::grpc::DeleteSipUserRequest* delete_sip_user_;
      ::ams::device::grpc::SetSipUserRequest* set_sip_user_;
      ::ams::device::grpc::GetOnvifInformationRequest* get_onvif_information_;
      ::ams::device::grpc::AddOnvifUserRequest* add_onvif_user_;
      ::ams::device::grpc::DeleteOnvifUserRequest* delete_onvif_user_;
      ::ams::device::grpc::SetOnvifUserRequest* set_onvif_user_;
      ::ams::device::grpc::GetPaAddressRequest* get_pa_address_;
      ::ams::device::grpc::SetPaAddressRequest* set_pa_address_;
      ::ams::device::grpc::GetSnapcastAddressRequest* get_snapcast_address_;
      ::ams::device::grpc::SetSnapcastAddressRequest* set_snapcast_address_;
      ::ams::device::grpc::GetVolumeRequest* get_volume_;
      ::ams::device::grpc::SetVolumeRequest* set_volume_;
      ::ams::device::grpc::GetScheduleListRequest* get_schedule_list_;
      ::ams::device::grpc::AddScheduleRequest* add_schedule_;
      ::ams::device::grpc::DeleteScheduleRequest* delete_schedule_;
      ::ams::device::grpc::SetScheduleRequest* set_schedule_;
      ::ams::device::grpc::ExceptionScheduleRequest* exception_schedule_;
      ::ams::device::grpc::StartBroadcastRequest* start_broadcast_;
      ::ams::device::grpc::StopBroadcastRequest* stop_broadcast_;
      ::ams::device::grpc::AddAudioClipRequest* add_audio_clip_;
      ::ams::device::grpc::EditAudioClipRequest* edit_audio_clip_;
      ::ams::device::grpc::DeleteAudioClipRequest* delete_audio_clip_;
      ::ams::device::grpc::SystemRebootRequest* system_reboot_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// -------------------------------------------------------------------

class DeviceMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ams.device.grpc.DeviceMessage) */ {
 public:
  inline DeviceMessage() : DeviceMessage(nullptr) {}
  ~DeviceMessage() override;
  explicit PROTOBUF_CONSTEXPR DeviceMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceMessage(const DeviceMessage& from);
  DeviceMessage(DeviceMessage&& from) noexcept
    : DeviceMessage() {
    *this = ::std::move(from);
  }

  inline DeviceMessage& operator=(const DeviceMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceMessage& operator=(DeviceMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kGetSystemDateAndTime = 4,
    kGetNetworkInterfaces = 5,
    kGetSipInformation = 6,
    kGetOnvifInformation = 7,
    kGetPaAddress = 8,
    kGetSnapcastAddress = 9,
    kGetVolume = 10,
    kGetScheduleList = 11,
    kSystemReboot = 12,
    kInitSessionNotify = 13,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const DeviceMessage* internal_default_instance() {
    return reinterpret_cast<const DeviceMessage*>(
               &_DeviceMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(DeviceMessage& a, DeviceMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceMessage& from) {
    DeviceMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ams.device.grpc.DeviceMessage";
  }
  protected:
  explicit DeviceMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 2,
    kGetSystemDateAndTimeFieldNumber = 4,
    kGetNetworkInterfacesFieldNumber = 5,
    kGetSipInformationFieldNumber = 6,
    kGetOnvifInformationFieldNumber = 7,
    kGetPaAddressFieldNumber = 8,
    kGetSnapcastAddressFieldNumber = 9,
    kGetVolumeFieldNumber = 10,
    kGetScheduleListFieldNumber = 11,
    kSystemRebootFieldNumber = 12,
    kInitSessionNotifyFieldNumber = 13,
  };
  // string message_id = 1;
  void clear_message_id();
  const std::string& message_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_id();
  PROTOBUF_NODISCARD std::string* release_message_id();
  void set_allocated_message_id(std::string* message_id);
  private:
  const std::string& _internal_message_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_id(const std::string& value);
  std::string* _internal_mutable_message_id();
  public:

  // .ams.device.grpc.Error error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::ams::device::grpc::Error& error() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::Error* release_error();
  ::ams::device::grpc::Error* mutable_error();
  void set_allocated_error(::ams::device::grpc::Error* error);
  private:
  const ::ams::device::grpc::Error& _internal_error() const;
  ::ams::device::grpc::Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::ams::device::grpc::Error* error);
  ::ams::device::grpc::Error* unsafe_arena_release_error();

  // .ams.device.grpc.Status status = 2;
  void clear_status();
  ::ams::device::grpc::Status status() const;
  void set_status(::ams::device::grpc::Status value);
  private:
  ::ams::device::grpc::Status _internal_status() const;
  void _internal_set_status(::ams::device::grpc::Status value);
  public:

  // .ams.device.grpc.GetSystemDateAndTimeResponse get_system_date_and_time = 4;
  bool has_get_system_date_and_time() const;
  private:
  bool _internal_has_get_system_date_and_time() const;
  public:
  void clear_get_system_date_and_time();
  const ::ams::device::grpc::GetSystemDateAndTimeResponse& get_system_date_and_time() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSystemDateAndTimeResponse* release_get_system_date_and_time();
  ::ams::device::grpc::GetSystemDateAndTimeResponse* mutable_get_system_date_and_time();
  void set_allocated_get_system_date_and_time(::ams::device::grpc::GetSystemDateAndTimeResponse* get_system_date_and_time);
  private:
  const ::ams::device::grpc::GetSystemDateAndTimeResponse& _internal_get_system_date_and_time() const;
  ::ams::device::grpc::GetSystemDateAndTimeResponse* _internal_mutable_get_system_date_and_time();
  public:
  void unsafe_arena_set_allocated_get_system_date_and_time(
      ::ams::device::grpc::GetSystemDateAndTimeResponse* get_system_date_and_time);
  ::ams::device::grpc::GetSystemDateAndTimeResponse* unsafe_arena_release_get_system_date_and_time();

  // .ams.device.grpc.GetNetworkInterfacesResponse get_network_interfaces = 5;
  bool has_get_network_interfaces() const;
  private:
  bool _internal_has_get_network_interfaces() const;
  public:
  void clear_get_network_interfaces();
  const ::ams::device::grpc::GetNetworkInterfacesResponse& get_network_interfaces() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetNetworkInterfacesResponse* release_get_network_interfaces();
  ::ams::device::grpc::GetNetworkInterfacesResponse* mutable_get_network_interfaces();
  void set_allocated_get_network_interfaces(::ams::device::grpc::GetNetworkInterfacesResponse* get_network_interfaces);
  private:
  const ::ams::device::grpc::GetNetworkInterfacesResponse& _internal_get_network_interfaces() const;
  ::ams::device::grpc::GetNetworkInterfacesResponse* _internal_mutable_get_network_interfaces();
  public:
  void unsafe_arena_set_allocated_get_network_interfaces(
      ::ams::device::grpc::GetNetworkInterfacesResponse* get_network_interfaces);
  ::ams::device::grpc::GetNetworkInterfacesResponse* unsafe_arena_release_get_network_interfaces();

  // .ams.device.grpc.GetSipInformationResponse get_sip_information = 6;
  bool has_get_sip_information() const;
  private:
  bool _internal_has_get_sip_information() const;
  public:
  void clear_get_sip_information();
  const ::ams::device::grpc::GetSipInformationResponse& get_sip_information() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSipInformationResponse* release_get_sip_information();
  ::ams::device::grpc::GetSipInformationResponse* mutable_get_sip_information();
  void set_allocated_get_sip_information(::ams::device::grpc::GetSipInformationResponse* get_sip_information);
  private:
  const ::ams::device::grpc::GetSipInformationResponse& _internal_get_sip_information() const;
  ::ams::device::grpc::GetSipInformationResponse* _internal_mutable_get_sip_information();
  public:
  void unsafe_arena_set_allocated_get_sip_information(
      ::ams::device::grpc::GetSipInformationResponse* get_sip_information);
  ::ams::device::grpc::GetSipInformationResponse* unsafe_arena_release_get_sip_information();

  // .ams.device.grpc.GetOnvifInformationResponse get_onvif_information = 7;
  bool has_get_onvif_information() const;
  private:
  bool _internal_has_get_onvif_information() const;
  public:
  void clear_get_onvif_information();
  const ::ams::device::grpc::GetOnvifInformationResponse& get_onvif_information() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetOnvifInformationResponse* release_get_onvif_information();
  ::ams::device::grpc::GetOnvifInformationResponse* mutable_get_onvif_information();
  void set_allocated_get_onvif_information(::ams::device::grpc::GetOnvifInformationResponse* get_onvif_information);
  private:
  const ::ams::device::grpc::GetOnvifInformationResponse& _internal_get_onvif_information() const;
  ::ams::device::grpc::GetOnvifInformationResponse* _internal_mutable_get_onvif_information();
  public:
  void unsafe_arena_set_allocated_get_onvif_information(
      ::ams::device::grpc::GetOnvifInformationResponse* get_onvif_information);
  ::ams::device::grpc::GetOnvifInformationResponse* unsafe_arena_release_get_onvif_information();

  // .ams.device.grpc.GetPaAddressResponse get_pa_address = 8;
  bool has_get_pa_address() const;
  private:
  bool _internal_has_get_pa_address() const;
  public:
  void clear_get_pa_address();
  const ::ams::device::grpc::GetPaAddressResponse& get_pa_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetPaAddressResponse* release_get_pa_address();
  ::ams::device::grpc::GetPaAddressResponse* mutable_get_pa_address();
  void set_allocated_get_pa_address(::ams::device::grpc::GetPaAddressResponse* get_pa_address);
  private:
  const ::ams::device::grpc::GetPaAddressResponse& _internal_get_pa_address() const;
  ::ams::device::grpc::GetPaAddressResponse* _internal_mutable_get_pa_address();
  public:
  void unsafe_arena_set_allocated_get_pa_address(
      ::ams::device::grpc::GetPaAddressResponse* get_pa_address);
  ::ams::device::grpc::GetPaAddressResponse* unsafe_arena_release_get_pa_address();

  // .ams.device.grpc.GetSnapcastAddressResponse get_snapcast_address = 9;
  bool has_get_snapcast_address() const;
  private:
  bool _internal_has_get_snapcast_address() const;
  public:
  void clear_get_snapcast_address();
  const ::ams::device::grpc::GetSnapcastAddressResponse& get_snapcast_address() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetSnapcastAddressResponse* release_get_snapcast_address();
  ::ams::device::grpc::GetSnapcastAddressResponse* mutable_get_snapcast_address();
  void set_allocated_get_snapcast_address(::ams::device::grpc::GetSnapcastAddressResponse* get_snapcast_address);
  private:
  const ::ams::device::grpc::GetSnapcastAddressResponse& _internal_get_snapcast_address() const;
  ::ams::device::grpc::GetSnapcastAddressResponse* _internal_mutable_get_snapcast_address();
  public:
  void unsafe_arena_set_allocated_get_snapcast_address(
      ::ams::device::grpc::GetSnapcastAddressResponse* get_snapcast_address);
  ::ams::device::grpc::GetSnapcastAddressResponse* unsafe_arena_release_get_snapcast_address();

  // .ams.device.grpc.GetVolumeResponse get_volume = 10;
  bool has_get_volume() const;
  private:
  bool _internal_has_get_volume() const;
  public:
  void clear_get_volume();
  const ::ams::device::grpc::GetVolumeResponse& get_volume() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetVolumeResponse* release_get_volume();
  ::ams::device::grpc::GetVolumeResponse* mutable_get_volume();
  void set_allocated_get_volume(::ams::device::grpc::GetVolumeResponse* get_volume);
  private:
  const ::ams::device::grpc::GetVolumeResponse& _internal_get_volume() const;
  ::ams::device::grpc::GetVolumeResponse* _internal_mutable_get_volume();
  public:
  void unsafe_arena_set_allocated_get_volume(
      ::ams::device::grpc::GetVolumeResponse* get_volume);
  ::ams::device::grpc::GetVolumeResponse* unsafe_arena_release_get_volume();

  // .ams.device.grpc.GetScheduleListResponse get_schedule_list = 11;
  bool has_get_schedule_list() const;
  private:
  bool _internal_has_get_schedule_list() const;
  public:
  void clear_get_schedule_list();
  const ::ams::device::grpc::GetScheduleListResponse& get_schedule_list() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::GetScheduleListResponse* release_get_schedule_list();
  ::ams::device::grpc::GetScheduleListResponse* mutable_get_schedule_list();
  void set_allocated_get_schedule_list(::ams::device::grpc::GetScheduleListResponse* get_schedule_list);
  private:
  const ::ams::device::grpc::GetScheduleListResponse& _internal_get_schedule_list() const;
  ::ams::device::grpc::GetScheduleListResponse* _internal_mutable_get_schedule_list();
  public:
  void unsafe_arena_set_allocated_get_schedule_list(
      ::ams::device::grpc::GetScheduleListResponse* get_schedule_list);
  ::ams::device::grpc::GetScheduleListResponse* unsafe_arena_release_get_schedule_list();

  // .ams.device.grpc.SystemRebootResponse system_reboot = 12;
  bool has_system_reboot() const;
  private:
  bool _internal_has_system_reboot() const;
  public:
  void clear_system_reboot();
  const ::ams::device::grpc::SystemRebootResponse& system_reboot() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::SystemRebootResponse* release_system_reboot();
  ::ams::device::grpc::SystemRebootResponse* mutable_system_reboot();
  void set_allocated_system_reboot(::ams::device::grpc::SystemRebootResponse* system_reboot);
  private:
  const ::ams::device::grpc::SystemRebootResponse& _internal_system_reboot() const;
  ::ams::device::grpc::SystemRebootResponse* _internal_mutable_system_reboot();
  public:
  void unsafe_arena_set_allocated_system_reboot(
      ::ams::device::grpc::SystemRebootResponse* system_reboot);
  ::ams::device::grpc::SystemRebootResponse* unsafe_arena_release_system_reboot();

  // .ams.device.grpc.InitSessionNotify init_session_notify = 13;
  bool has_init_session_notify() const;
  private:
  bool _internal_has_init_session_notify() const;
  public:
  void clear_init_session_notify();
  const ::ams::device::grpc::InitSessionNotify& init_session_notify() const;
  PROTOBUF_NODISCARD ::ams::device::grpc::InitSessionNotify* release_init_session_notify();
  ::ams::device::grpc::InitSessionNotify* mutable_init_session_notify();
  void set_allocated_init_session_notify(::ams::device::grpc::InitSessionNotify* init_session_notify);
  private:
  const ::ams::device::grpc::InitSessionNotify& _internal_init_session_notify() const;
  ::ams::device::grpc::InitSessionNotify* _internal_mutable_init_session_notify();
  public:
  void unsafe_arena_set_allocated_init_session_notify(
      ::ams::device::grpc::InitSessionNotify* init_session_notify);
  ::ams::device::grpc::InitSessionNotify* unsafe_arena_release_init_session_notify();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:ams.device.grpc.DeviceMessage)
 private:
  class _Internal;
  void set_has_get_system_date_and_time();
  void set_has_get_network_interfaces();
  void set_has_get_sip_information();
  void set_has_get_onvif_information();
  void set_has_get_pa_address();
  void set_has_get_snapcast_address();
  void set_has_get_volume();
  void set_has_get_schedule_list();
  void set_has_system_reboot();
  void set_has_init_session_notify();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_id_;
    ::ams::device::grpc::Error* error_;
    int status_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ams::device::grpc::GetSystemDateAndTimeResponse* get_system_date_and_time_;
      ::ams::device::grpc::GetNetworkInterfacesResponse* get_network_interfaces_;
      ::ams::device::grpc::GetSipInformationResponse* get_sip_information_;
      ::ams::device::grpc::GetOnvifInformationResponse* get_onvif_information_;
      ::ams::device::grpc::GetPaAddressResponse* get_pa_address_;
      ::ams::device::grpc::GetSnapcastAddressResponse* get_snapcast_address_;
      ::ams::device::grpc::GetVolumeResponse* get_volume_;
      ::ams::device::grpc::GetScheduleListResponse* get_schedule_list_;
      ::ams::device::grpc::SystemRebootResponse* system_reboot_;
      ::ams::device::grpc::InitSessionNotify* init_session_notify_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_device_5fcontrol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Error

// string code = 1;
inline void Error::clear_code() {
  _impl_.code_.ClearToEmpty();
}
inline const std::string& Error::code() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Error.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Error.code)
}
inline std::string* Error::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Error.code)
  return _s;
}
inline const std::string& Error::_internal_code() const {
  return _impl_.code_.Get();
}
inline void Error::_internal_set_code(const std::string& value) {
  
  _impl_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_code() {
  
  return _impl_.code_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_code() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Error.code)
  return _impl_.code_.Release();
}
inline void Error::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  _impl_.code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.code_.IsDefault()) {
    _impl_.code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Error.code)
}

// string message = 2;
inline void Error::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Error.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Error.message)
}
inline std::string* Error::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Error.message)
  return _s;
}
inline const std::string& Error::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Error.message)
  return _impl_.message_.Release();
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Error.message)
}

// -------------------------------------------------------------------

// SetDeviceInformationRequest

// string name = 1;
inline void SetDeviceInformationRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SetDeviceInformationRequest::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetDeviceInformationRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetDeviceInformationRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetDeviceInformationRequest.name)
}
inline std::string* SetDeviceInformationRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetDeviceInformationRequest.name)
  return _s;
}
inline const std::string& SetDeviceInformationRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SetDeviceInformationRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetDeviceInformationRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetDeviceInformationRequest::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetDeviceInformationRequest.name)
  return _impl_.name_.Release();
}
inline void SetDeviceInformationRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetDeviceInformationRequest.name)
}

// string location = 2;
inline void SetDeviceInformationRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& SetDeviceInformationRequest::location() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetDeviceInformationRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetDeviceInformationRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetDeviceInformationRequest.location)
}
inline std::string* SetDeviceInformationRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetDeviceInformationRequest.location)
  return _s;
}
inline const std::string& SetDeviceInformationRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void SetDeviceInformationRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* SetDeviceInformationRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* SetDeviceInformationRequest::release_location() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetDeviceInformationRequest.location)
  return _impl_.location_.Release();
}
inline void SetDeviceInformationRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetDeviceInformationRequest.location)
}

// -------------------------------------------------------------------

// GetSystemDateAndTimeRequest

// -------------------------------------------------------------------

// SetSystemDateAndTimeRequest

// .ams.device.grpc.DateTimeType date_time_type = 1;
inline void SetSystemDateAndTimeRequest::clear_date_time_type() {
  _impl_.date_time_type_ = 0;
}
inline ::ams::device::grpc::DateTimeType SetSystemDateAndTimeRequest::_internal_date_time_type() const {
  return static_cast< ::ams::device::grpc::DateTimeType >(_impl_.date_time_type_);
}
inline ::ams::device::grpc::DateTimeType SetSystemDateAndTimeRequest::date_time_type() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSystemDateAndTimeRequest.date_time_type)
  return _internal_date_time_type();
}
inline void SetSystemDateAndTimeRequest::_internal_set_date_time_type(::ams::device::grpc::DateTimeType value) {
  
  _impl_.date_time_type_ = value;
}
inline void SetSystemDateAndTimeRequest::set_date_time_type(::ams::device::grpc::DateTimeType value) {
  _internal_set_date_time_type(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetSystemDateAndTimeRequest.date_time_type)
}

// string time_zone = 2;
inline void SetSystemDateAndTimeRequest::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& SetSystemDateAndTimeRequest::time_zone() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSystemDateAndTimeRequest.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSystemDateAndTimeRequest::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetSystemDateAndTimeRequest.time_zone)
}
inline std::string* SetSystemDateAndTimeRequest::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetSystemDateAndTimeRequest.time_zone)
  return _s;
}
inline const std::string& SetSystemDateAndTimeRequest::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void SetSystemDateAndTimeRequest::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::release_time_zone() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetSystemDateAndTimeRequest.time_zone)
  return _impl_.time_zone_.Release();
}
inline void SetSystemDateAndTimeRequest::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetSystemDateAndTimeRequest.time_zone)
}

// string utc_time = 3;
inline void SetSystemDateAndTimeRequest::clear_utc_time() {
  _impl_.utc_time_.ClearToEmpty();
}
inline const std::string& SetSystemDateAndTimeRequest::utc_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSystemDateAndTimeRequest.utc_time)
  return _internal_utc_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSystemDateAndTimeRequest::set_utc_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utc_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetSystemDateAndTimeRequest.utc_time)
}
inline std::string* SetSystemDateAndTimeRequest::mutable_utc_time() {
  std::string* _s = _internal_mutable_utc_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetSystemDateAndTimeRequest.utc_time)
  return _s;
}
inline const std::string& SetSystemDateAndTimeRequest::_internal_utc_time() const {
  return _impl_.utc_time_.Get();
}
inline void SetSystemDateAndTimeRequest::_internal_set_utc_time(const std::string& value) {
  
  _impl_.utc_time_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::_internal_mutable_utc_time() {
  
  return _impl_.utc_time_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::release_utc_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetSystemDateAndTimeRequest.utc_time)
  return _impl_.utc_time_.Release();
}
inline void SetSystemDateAndTimeRequest::set_allocated_utc_time(std::string* utc_time) {
  if (utc_time != nullptr) {
    
  } else {
    
  }
  _impl_.utc_time_.SetAllocated(utc_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utc_time_.IsDefault()) {
    _impl_.utc_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetSystemDateAndTimeRequest.utc_time)
}

// string ntp_server = 4;
inline void SetSystemDateAndTimeRequest::clear_ntp_server() {
  _impl_.ntp_server_.ClearToEmpty();
}
inline const std::string& SetSystemDateAndTimeRequest::ntp_server() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSystemDateAndTimeRequest.ntp_server)
  return _internal_ntp_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSystemDateAndTimeRequest::set_ntp_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ntp_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetSystemDateAndTimeRequest.ntp_server)
}
inline std::string* SetSystemDateAndTimeRequest::mutable_ntp_server() {
  std::string* _s = _internal_mutable_ntp_server();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetSystemDateAndTimeRequest.ntp_server)
  return _s;
}
inline const std::string& SetSystemDateAndTimeRequest::_internal_ntp_server() const {
  return _impl_.ntp_server_.Get();
}
inline void SetSystemDateAndTimeRequest::_internal_set_ntp_server(const std::string& value) {
  
  _impl_.ntp_server_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::_internal_mutable_ntp_server() {
  
  return _impl_.ntp_server_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSystemDateAndTimeRequest::release_ntp_server() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetSystemDateAndTimeRequest.ntp_server)
  return _impl_.ntp_server_.Release();
}
inline void SetSystemDateAndTimeRequest::set_allocated_ntp_server(std::string* ntp_server) {
  if (ntp_server != nullptr) {
    
  } else {
    
  }
  _impl_.ntp_server_.SetAllocated(ntp_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ntp_server_.IsDefault()) {
    _impl_.ntp_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetSystemDateAndTimeRequest.ntp_server)
}

// -------------------------------------------------------------------

// GetNetworkInterfacesRequest

// -------------------------------------------------------------------

// SetNetworkInterfacesRequest

// .ams.device.grpc.NetworkMode mode = 1;
inline void SetNetworkInterfacesRequest::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::ams::device::grpc::NetworkMode SetNetworkInterfacesRequest::_internal_mode() const {
  return static_cast< ::ams::device::grpc::NetworkMode >(_impl_.mode_);
}
inline ::ams::device::grpc::NetworkMode SetNetworkInterfacesRequest::mode() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.mode)
  return _internal_mode();
}
inline void SetNetworkInterfacesRequest::_internal_set_mode(::ams::device::grpc::NetworkMode value) {
  
  _impl_.mode_ = value;
}
inline void SetNetworkInterfacesRequest::set_mode(::ams::device::grpc::NetworkMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.mode)
}

// string ipv4_address = 2;
inline void SetNetworkInterfacesRequest::clear_ipv4_address() {
  _impl_.ipv4_address_.ClearToEmpty();
}
inline const std::string& SetNetworkInterfacesRequest::ipv4_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.ipv4_address)
  return _internal_ipv4_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetNetworkInterfacesRequest::set_ipv4_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv4_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.ipv4_address)
}
inline std::string* SetNetworkInterfacesRequest::mutable_ipv4_address() {
  std::string* _s = _internal_mutable_ipv4_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetNetworkInterfacesRequest.ipv4_address)
  return _s;
}
inline const std::string& SetNetworkInterfacesRequest::_internal_ipv4_address() const {
  return _impl_.ipv4_address_.Get();
}
inline void SetNetworkInterfacesRequest::_internal_set_ipv4_address(const std::string& value) {
  
  _impl_.ipv4_address_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::_internal_mutable_ipv4_address() {
  
  return _impl_.ipv4_address_.Mutable(GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::release_ipv4_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetNetworkInterfacesRequest.ipv4_address)
  return _impl_.ipv4_address_.Release();
}
inline void SetNetworkInterfacesRequest::set_allocated_ipv4_address(std::string* ipv4_address) {
  if (ipv4_address != nullptr) {
    
  } else {
    
  }
  _impl_.ipv4_address_.SetAllocated(ipv4_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv4_address_.IsDefault()) {
    _impl_.ipv4_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetNetworkInterfacesRequest.ipv4_address)
}

// string netmask = 3;
inline void SetNetworkInterfacesRequest::clear_netmask() {
  _impl_.netmask_.ClearToEmpty();
}
inline const std::string& SetNetworkInterfacesRequest::netmask() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.netmask)
  return _internal_netmask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetNetworkInterfacesRequest::set_netmask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.netmask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.netmask)
}
inline std::string* SetNetworkInterfacesRequest::mutable_netmask() {
  std::string* _s = _internal_mutable_netmask();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetNetworkInterfacesRequest.netmask)
  return _s;
}
inline const std::string& SetNetworkInterfacesRequest::_internal_netmask() const {
  return _impl_.netmask_.Get();
}
inline void SetNetworkInterfacesRequest::_internal_set_netmask(const std::string& value) {
  
  _impl_.netmask_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::_internal_mutable_netmask() {
  
  return _impl_.netmask_.Mutable(GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::release_netmask() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetNetworkInterfacesRequest.netmask)
  return _impl_.netmask_.Release();
}
inline void SetNetworkInterfacesRequest::set_allocated_netmask(std::string* netmask) {
  if (netmask != nullptr) {
    
  } else {
    
  }
  _impl_.netmask_.SetAllocated(netmask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.netmask_.IsDefault()) {
    _impl_.netmask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetNetworkInterfacesRequest.netmask)
}

// string gateway = 4;
inline void SetNetworkInterfacesRequest::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& SetNetworkInterfacesRequest::gateway() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetNetworkInterfacesRequest::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.gateway)
}
inline std::string* SetNetworkInterfacesRequest::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetNetworkInterfacesRequest.gateway)
  return _s;
}
inline const std::string& SetNetworkInterfacesRequest::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void SetNetworkInterfacesRequest::_internal_set_gateway(const std::string& value) {
  
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::_internal_mutable_gateway() {
  
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::release_gateway() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetNetworkInterfacesRequest.gateway)
  return _impl_.gateway_.Release();
}
inline void SetNetworkInterfacesRequest::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetNetworkInterfacesRequest.gateway)
}

// repeated string dns = 5;
inline int SetNetworkInterfacesRequest::_internal_dns_size() const {
  return _impl_.dns_.size();
}
inline int SetNetworkInterfacesRequest::dns_size() const {
  return _internal_dns_size();
}
inline void SetNetworkInterfacesRequest::clear_dns() {
  _impl_.dns_.Clear();
}
inline std::string* SetNetworkInterfacesRequest::add_dns() {
  std::string* _s = _internal_add_dns();
  // @@protoc_insertion_point(field_add_mutable:ams.device.grpc.SetNetworkInterfacesRequest.dns)
  return _s;
}
inline const std::string& SetNetworkInterfacesRequest::_internal_dns(int index) const {
  return _impl_.dns_.Get(index);
}
inline const std::string& SetNetworkInterfacesRequest::dns(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.dns)
  return _internal_dns(index);
}
inline std::string* SetNetworkInterfacesRequest::mutable_dns(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetNetworkInterfacesRequest.dns)
  return _impl_.dns_.Mutable(index);
}
inline void SetNetworkInterfacesRequest::set_dns(int index, const std::string& value) {
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::set_dns(int index, std::string&& value) {
  _impl_.dns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::set_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::set_dns(int index, const char* value, size_t size) {
  _impl_.dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline std::string* SetNetworkInterfacesRequest::_internal_add_dns() {
  return _impl_.dns_.Add();
}
inline void SetNetworkInterfacesRequest::add_dns(const std::string& value) {
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::add_dns(std::string&& value) {
  _impl_.dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::add_dns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline void SetNetworkInterfacesRequest::add_dns(const char* value, size_t size) {
  _impl_.dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ams.device.grpc.SetNetworkInterfacesRequest.dns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SetNetworkInterfacesRequest::dns() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.SetNetworkInterfacesRequest.dns)
  return _impl_.dns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SetNetworkInterfacesRequest::mutable_dns() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.SetNetworkInterfacesRequest.dns)
  return &_impl_.dns_;
}

// string hostname = 6;
inline void SetNetworkInterfacesRequest::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& SetNetworkInterfacesRequest::hostname() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetNetworkInterfacesRequest.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetNetworkInterfacesRequest::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetNetworkInterfacesRequest.hostname)
}
inline std::string* SetNetworkInterfacesRequest::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetNetworkInterfacesRequest.hostname)
  return _s;
}
inline const std::string& SetNetworkInterfacesRequest::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void SetNetworkInterfacesRequest::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* SetNetworkInterfacesRequest::release_hostname() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetNetworkInterfacesRequest.hostname)
  return _impl_.hostname_.Release();
}
inline void SetNetworkInterfacesRequest::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetNetworkInterfacesRequest.hostname)
}

// -------------------------------------------------------------------

// SipAccount

// string name = 1;
inline void SipAccount::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SipAccount::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SipAccount.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipAccount::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SipAccount.name)
}
inline std::string* SipAccount::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SipAccount.name)
  return _s;
}
inline const std::string& SipAccount::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SipAccount::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SipAccount::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SipAccount::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SipAccount.name)
  return _impl_.name_.Release();
}
inline void SipAccount::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SipAccount.name)
}

// string auth_id = 2;
inline void SipAccount::clear_auth_id() {
  _impl_.auth_id_.ClearToEmpty();
}
inline const std::string& SipAccount::auth_id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SipAccount.auth_id)
  return _internal_auth_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipAccount::set_auth_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SipAccount.auth_id)
}
inline std::string* SipAccount::mutable_auth_id() {
  std::string* _s = _internal_mutable_auth_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SipAccount.auth_id)
  return _s;
}
inline const std::string& SipAccount::_internal_auth_id() const {
  return _impl_.auth_id_.Get();
}
inline void SipAccount::_internal_set_auth_id(const std::string& value) {
  
  _impl_.auth_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SipAccount::_internal_mutable_auth_id() {
  
  return _impl_.auth_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SipAccount::release_auth_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SipAccount.auth_id)
  return _impl_.auth_id_.Release();
}
inline void SipAccount::set_allocated_auth_id(std::string* auth_id) {
  if (auth_id != nullptr) {
    
  } else {
    
  }
  _impl_.auth_id_.SetAllocated(auth_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_id_.IsDefault()) {
    _impl_.auth_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SipAccount.auth_id)
}

// string auth_password = 3;
inline void SipAccount::clear_auth_password() {
  _impl_.auth_password_.ClearToEmpty();
}
inline const std::string& SipAccount::auth_password() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SipAccount.auth_password)
  return _internal_auth_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipAccount::set_auth_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SipAccount.auth_password)
}
inline std::string* SipAccount::mutable_auth_password() {
  std::string* _s = _internal_mutable_auth_password();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SipAccount.auth_password)
  return _s;
}
inline const std::string& SipAccount::_internal_auth_password() const {
  return _impl_.auth_password_.Get();
}
inline void SipAccount::_internal_set_auth_password(const std::string& value) {
  
  _impl_.auth_password_.Set(value, GetArenaForAllocation());
}
inline std::string* SipAccount::_internal_mutable_auth_password() {
  
  return _impl_.auth_password_.Mutable(GetArenaForAllocation());
}
inline std::string* SipAccount::release_auth_password() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SipAccount.auth_password)
  return _impl_.auth_password_.Release();
}
inline void SipAccount::set_allocated_auth_password(std::string* auth_password) {
  if (auth_password != nullptr) {
    
  } else {
    
  }
  _impl_.auth_password_.SetAllocated(auth_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_password_.IsDefault()) {
    _impl_.auth_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SipAccount.auth_password)
}

// string server = 4;
inline void SipAccount::clear_server() {
  _impl_.server_.ClearToEmpty();
}
inline const std::string& SipAccount::server() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SipAccount.server)
  return _internal_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SipAccount::set_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SipAccount.server)
}
inline std::string* SipAccount::mutable_server() {
  std::string* _s = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SipAccount.server)
  return _s;
}
inline const std::string& SipAccount::_internal_server() const {
  return _impl_.server_.Get();
}
inline void SipAccount::_internal_set_server(const std::string& value) {
  
  _impl_.server_.Set(value, GetArenaForAllocation());
}
inline std::string* SipAccount::_internal_mutable_server() {
  
  return _impl_.server_.Mutable(GetArenaForAllocation());
}
inline std::string* SipAccount::release_server() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SipAccount.server)
  return _impl_.server_.Release();
}
inline void SipAccount::set_allocated_server(std::string* server) {
  if (server != nullptr) {
    
  } else {
    
  }
  _impl_.server_.SetAllocated(server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.server_.IsDefault()) {
    _impl_.server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SipAccount.server)
}

// -------------------------------------------------------------------

// GetSipInformationRequest

// -------------------------------------------------------------------

// AddSipUserRequest

// .ams.device.grpc.SipAccount account = 1;
inline bool AddSipUserRequest::_internal_has_account() const {
  return this != internal_default_instance() && _impl_.account_ != nullptr;
}
inline bool AddSipUserRequest::has_account() const {
  return _internal_has_account();
}
inline void AddSipUserRequest::clear_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_ != nullptr) {
    delete _impl_.account_;
  }
  _impl_.account_ = nullptr;
}
inline const ::ams::device::grpc::SipAccount& AddSipUserRequest::_internal_account() const {
  const ::ams::device::grpc::SipAccount* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::SipAccount&>(
      ::ams::device::grpc::_SipAccount_default_instance_);
}
inline const ::ams::device::grpc::SipAccount& AddSipUserRequest::account() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AddSipUserRequest.account)
  return _internal_account();
}
inline void AddSipUserRequest::unsafe_arena_set_allocated_account(
    ::ams::device::grpc::SipAccount* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.AddSipUserRequest.account)
}
inline ::ams::device::grpc::SipAccount* AddSipUserRequest::release_account() {
  
  ::ams::device::grpc::SipAccount* temp = _impl_.account_;
  _impl_.account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::SipAccount* AddSipUserRequest::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AddSipUserRequest.account)
  
  ::ams::device::grpc::SipAccount* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::SipAccount* AddSipUserRequest::_internal_mutable_account() {
  
  if (_impl_.account_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::SipAccount>(GetArenaForAllocation());
    _impl_.account_ = p;
  }
  return _impl_.account_;
}
inline ::ams::device::grpc::SipAccount* AddSipUserRequest::mutable_account() {
  ::ams::device::grpc::SipAccount* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AddSipUserRequest.account)
  return _msg;
}
inline void AddSipUserRequest::set_allocated_account(::ams::device::grpc::SipAccount* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_ = account;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AddSipUserRequest.account)
}

// -------------------------------------------------------------------

// DeleteSipUserRequest

// string name = 1;
inline void DeleteSipUserRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteSipUserRequest::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeleteSipUserRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSipUserRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeleteSipUserRequest.name)
}
inline std::string* DeleteSipUserRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeleteSipUserRequest.name)
  return _s;
}
inline const std::string& DeleteSipUserRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteSipUserRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteSipUserRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteSipUserRequest::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeleteSipUserRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteSipUserRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeleteSipUserRequest.name)
}

// -------------------------------------------------------------------

// SetSipUserRequest

// .ams.device.grpc.SipAccount account = 1;
inline bool SetSipUserRequest::_internal_has_account() const {
  return this != internal_default_instance() && _impl_.account_ != nullptr;
}
inline bool SetSipUserRequest::has_account() const {
  return _internal_has_account();
}
inline void SetSipUserRequest::clear_account() {
  if (GetArenaForAllocation() == nullptr && _impl_.account_ != nullptr) {
    delete _impl_.account_;
  }
  _impl_.account_ = nullptr;
}
inline const ::ams::device::grpc::SipAccount& SetSipUserRequest::_internal_account() const {
  const ::ams::device::grpc::SipAccount* p = _impl_.account_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::SipAccount&>(
      ::ams::device::grpc::_SipAccount_default_instance_);
}
inline const ::ams::device::grpc::SipAccount& SetSipUserRequest::account() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSipUserRequest.account)
  return _internal_account();
}
inline void SetSipUserRequest::unsafe_arena_set_allocated_account(
    ::ams::device::grpc::SipAccount* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.account_);
  }
  _impl_.account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.SetSipUserRequest.account)
}
inline ::ams::device::grpc::SipAccount* SetSipUserRequest::release_account() {
  
  ::ams::device::grpc::SipAccount* temp = _impl_.account_;
  _impl_.account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::SipAccount* SetSipUserRequest::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetSipUserRequest.account)
  
  ::ams::device::grpc::SipAccount* temp = _impl_.account_;
  _impl_.account_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::SipAccount* SetSipUserRequest::_internal_mutable_account() {
  
  if (_impl_.account_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::SipAccount>(GetArenaForAllocation());
    _impl_.account_ = p;
  }
  return _impl_.account_;
}
inline ::ams::device::grpc::SipAccount* SetSipUserRequest::mutable_account() {
  ::ams::device::grpc::SipAccount* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetSipUserRequest.account)
  return _msg;
}
inline void SetSipUserRequest::set_allocated_account(::ams::device::grpc::SipAccount* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.account_ = account;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetSipUserRequest.account)
}

// -------------------------------------------------------------------

// OnvifUser

// string username = 1;
inline void OnvifUser::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& OnvifUser::username() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.OnvifUser.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnvifUser::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.OnvifUser.username)
}
inline std::string* OnvifUser::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.OnvifUser.username)
  return _s;
}
inline const std::string& OnvifUser::_internal_username() const {
  return _impl_.username_.Get();
}
inline void OnvifUser::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* OnvifUser::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* OnvifUser::release_username() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.OnvifUser.username)
  return _impl_.username_.Release();
}
inline void OnvifUser::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.OnvifUser.username)
}

// string password = 2;
inline void OnvifUser::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& OnvifUser::password() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.OnvifUser.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OnvifUser::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.OnvifUser.password)
}
inline std::string* OnvifUser::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.OnvifUser.password)
  return _s;
}
inline const std::string& OnvifUser::_internal_password() const {
  return _impl_.password_.Get();
}
inline void OnvifUser::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* OnvifUser::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* OnvifUser::release_password() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.OnvifUser.password)
  return _impl_.password_.Release();
}
inline void OnvifUser::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.OnvifUser.password)
}

// .ams.device.grpc.OnvifAccessLevel access_level = 3;
inline void OnvifUser::clear_access_level() {
  _impl_.access_level_ = 0;
}
inline ::ams::device::grpc::OnvifAccessLevel OnvifUser::_internal_access_level() const {
  return static_cast< ::ams::device::grpc::OnvifAccessLevel >(_impl_.access_level_);
}
inline ::ams::device::grpc::OnvifAccessLevel OnvifUser::access_level() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.OnvifUser.access_level)
  return _internal_access_level();
}
inline void OnvifUser::_internal_set_access_level(::ams::device::grpc::OnvifAccessLevel value) {
  
  _impl_.access_level_ = value;
}
inline void OnvifUser::set_access_level(::ams::device::grpc::OnvifAccessLevel value) {
  _internal_set_access_level(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.OnvifUser.access_level)
}

// -------------------------------------------------------------------

// GetOnvifInformationRequest

// -------------------------------------------------------------------

// AddOnvifUserRequest

// .ams.device.grpc.OnvifUser user = 1;
inline bool AddOnvifUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool AddOnvifUserRequest::has_user() const {
  return _internal_has_user();
}
inline void AddOnvifUserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::ams::device::grpc::OnvifUser& AddOnvifUserRequest::_internal_user() const {
  const ::ams::device::grpc::OnvifUser* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::OnvifUser&>(
      ::ams::device::grpc::_OnvifUser_default_instance_);
}
inline const ::ams::device::grpc::OnvifUser& AddOnvifUserRequest::user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AddOnvifUserRequest.user)
  return _internal_user();
}
inline void AddOnvifUserRequest::unsafe_arena_set_allocated_user(
    ::ams::device::grpc::OnvifUser* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.AddOnvifUserRequest.user)
}
inline ::ams::device::grpc::OnvifUser* AddOnvifUserRequest::release_user() {
  
  ::ams::device::grpc::OnvifUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::OnvifUser* AddOnvifUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AddOnvifUserRequest.user)
  
  ::ams::device::grpc::OnvifUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::OnvifUser* AddOnvifUserRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::OnvifUser>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ams::device::grpc::OnvifUser* AddOnvifUserRequest::mutable_user() {
  ::ams::device::grpc::OnvifUser* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AddOnvifUserRequest.user)
  return _msg;
}
inline void AddOnvifUserRequest::set_allocated_user(::ams::device::grpc::OnvifUser* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AddOnvifUserRequest.user)
}

// -------------------------------------------------------------------

// DeleteOnvifUserRequest

// string username = 1;
inline void DeleteOnvifUserRequest::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& DeleteOnvifUserRequest::username() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeleteOnvifUserRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteOnvifUserRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeleteOnvifUserRequest.username)
}
inline std::string* DeleteOnvifUserRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeleteOnvifUserRequest.username)
  return _s;
}
inline const std::string& DeleteOnvifUserRequest::_internal_username() const {
  return _impl_.username_.Get();
}
inline void DeleteOnvifUserRequest::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteOnvifUserRequest::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteOnvifUserRequest::release_username() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeleteOnvifUserRequest.username)
  return _impl_.username_.Release();
}
inline void DeleteOnvifUserRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeleteOnvifUserRequest.username)
}

// -------------------------------------------------------------------

// SetOnvifUserRequest

// .ams.device.grpc.OnvifUser user = 1;
inline bool SetOnvifUserRequest::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool SetOnvifUserRequest::has_user() const {
  return _internal_has_user();
}
inline void SetOnvifUserRequest::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::ams::device::grpc::OnvifUser& SetOnvifUserRequest::_internal_user() const {
  const ::ams::device::grpc::OnvifUser* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::OnvifUser&>(
      ::ams::device::grpc::_OnvifUser_default_instance_);
}
inline const ::ams::device::grpc::OnvifUser& SetOnvifUserRequest::user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetOnvifUserRequest.user)
  return _internal_user();
}
inline void SetOnvifUserRequest::unsafe_arena_set_allocated_user(
    ::ams::device::grpc::OnvifUser* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.SetOnvifUserRequest.user)
}
inline ::ams::device::grpc::OnvifUser* SetOnvifUserRequest::release_user() {
  
  ::ams::device::grpc::OnvifUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::OnvifUser* SetOnvifUserRequest::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetOnvifUserRequest.user)
  
  ::ams::device::grpc::OnvifUser* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::OnvifUser* SetOnvifUserRequest::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::OnvifUser>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::ams::device::grpc::OnvifUser* SetOnvifUserRequest::mutable_user() {
  ::ams::device::grpc::OnvifUser* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetOnvifUserRequest.user)
  return _msg;
}
inline void SetOnvifUserRequest::set_allocated_user(::ams::device::grpc::OnvifUser* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetOnvifUserRequest.user)
}

// -------------------------------------------------------------------

// GetPaAddressRequest

// -------------------------------------------------------------------

// SetPaAddressRequest

// string address = 1;
inline void SetPaAddressRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& SetPaAddressRequest::address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetPaAddressRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPaAddressRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetPaAddressRequest.address)
}
inline std::string* SetPaAddressRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetPaAddressRequest.address)
  return _s;
}
inline const std::string& SetPaAddressRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void SetPaAddressRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPaAddressRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPaAddressRequest::release_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetPaAddressRequest.address)
  return _impl_.address_.Release();
}
inline void SetPaAddressRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetPaAddressRequest.address)
}

// -------------------------------------------------------------------

// GetSnapcastAddressRequest

// -------------------------------------------------------------------

// SetSnapcastAddressRequest

// string address = 1;
inline void SetSnapcastAddressRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& SetSnapcastAddressRequest::address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetSnapcastAddressRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetSnapcastAddressRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetSnapcastAddressRequest.address)
}
inline std::string* SetSnapcastAddressRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetSnapcastAddressRequest.address)
  return _s;
}
inline const std::string& SetSnapcastAddressRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void SetSnapcastAddressRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* SetSnapcastAddressRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* SetSnapcastAddressRequest::release_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetSnapcastAddressRequest.address)
  return _impl_.address_.Release();
}
inline void SetSnapcastAddressRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetSnapcastAddressRequest.address)
}

// -------------------------------------------------------------------

// GetVolumeRequest

// -------------------------------------------------------------------

// SetVolumeRequest

// int32 speaker_volume = 1;
inline void SetVolumeRequest::clear_speaker_volume() {
  _impl_.speaker_volume_ = 0;
}
inline int32_t SetVolumeRequest::_internal_speaker_volume() const {
  return _impl_.speaker_volume_;
}
inline int32_t SetVolumeRequest::speaker_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetVolumeRequest.speaker_volume)
  return _internal_speaker_volume();
}
inline void SetVolumeRequest::_internal_set_speaker_volume(int32_t value) {
  
  _impl_.speaker_volume_ = value;
}
inline void SetVolumeRequest::set_speaker_volume(int32_t value) {
  _internal_set_speaker_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetVolumeRequest.speaker_volume)
}

// int32 mic_volume = 2;
inline void SetVolumeRequest::clear_mic_volume() {
  _impl_.mic_volume_ = 0;
}
inline int32_t SetVolumeRequest::_internal_mic_volume() const {
  return _impl_.mic_volume_;
}
inline int32_t SetVolumeRequest::mic_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetVolumeRequest.mic_volume)
  return _internal_mic_volume();
}
inline void SetVolumeRequest::_internal_set_mic_volume(int32_t value) {
  
  _impl_.mic_volume_ = value;
}
inline void SetVolumeRequest::set_mic_volume(int32_t value) {
  _internal_set_mic_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetVolumeRequest.mic_volume)
}

// -------------------------------------------------------------------

// Schedule

// string id = 1;
inline void Schedule::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Schedule::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.id)
}
inline std::string* Schedule::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.id)
  return _s;
}
inline const std::string& Schedule::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Schedule::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.id)
  return _impl_.id_.Release();
}
inline void Schedule::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.id)
}

// string name = 2;
inline void Schedule::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Schedule::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.name)
}
inline std::string* Schedule::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.name)
  return _s;
}
inline const std::string& Schedule::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Schedule::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.name)
  return _impl_.name_.Release();
}
inline void Schedule::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.name)
}

// string start_date = 3;
inline void Schedule::clear_start_date() {
  _impl_.start_date_.ClearToEmpty();
}
inline const std::string& Schedule::start_date() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.start_date)
  return _internal_start_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_start_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.start_date)
}
inline std::string* Schedule::mutable_start_date() {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.start_date)
  return _s;
}
inline const std::string& Schedule::_internal_start_date() const {
  return _impl_.start_date_.Get();
}
inline void Schedule::_internal_set_start_date(const std::string& value) {
  
  _impl_.start_date_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_start_date() {
  
  return _impl_.start_date_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_start_date() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.start_date)
  return _impl_.start_date_.Release();
}
inline void Schedule::set_allocated_start_date(std::string* start_date) {
  if (start_date != nullptr) {
    
  } else {
    
  }
  _impl_.start_date_.SetAllocated(start_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.start_date)
}

// optional string end_date = 4;
inline bool Schedule::_internal_has_end_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Schedule::has_end_date() const {
  return _internal_has_end_date();
}
inline void Schedule::clear_end_date() {
  _impl_.end_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Schedule::end_date() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.end_date)
  return _internal_end_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_end_date(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.end_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.end_date)
}
inline std::string* Schedule::mutable_end_date() {
  std::string* _s = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.end_date)
  return _s;
}
inline const std::string& Schedule::_internal_end_date() const {
  return _impl_.end_date_.Get();
}
inline void Schedule::_internal_set_end_date(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.end_date_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_end_date() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.end_date_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_end_date() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.end_date)
  if (!_internal_has_end_date()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.end_date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_date_.IsDefault()) {
    _impl_.end_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Schedule::set_allocated_end_date(std::string* end_date) {
  if (end_date != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.end_date_.SetAllocated(end_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_date_.IsDefault()) {
    _impl_.end_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.end_date)
}

// repeated .ams.device.grpc.DayOfWeek day_of_week = 5;
inline int Schedule::_internal_day_of_week_size() const {
  return _impl_.day_of_week_.size();
}
inline int Schedule::day_of_week_size() const {
  return _internal_day_of_week_size();
}
inline void Schedule::clear_day_of_week() {
  _impl_.day_of_week_.Clear();
}
inline ::ams::device::grpc::DayOfWeek Schedule::_internal_day_of_week(int index) const {
  return static_cast< ::ams::device::grpc::DayOfWeek >(_impl_.day_of_week_.Get(index));
}
inline ::ams::device::grpc::DayOfWeek Schedule::day_of_week(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.day_of_week)
  return _internal_day_of_week(index);
}
inline void Schedule::set_day_of_week(int index, ::ams::device::grpc::DayOfWeek value) {
  _impl_.day_of_week_.Set(index, value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.day_of_week)
}
inline void Schedule::_internal_add_day_of_week(::ams::device::grpc::DayOfWeek value) {
  _impl_.day_of_week_.Add(value);
}
inline void Schedule::add_day_of_week(::ams::device::grpc::DayOfWeek value) {
  _internal_add_day_of_week(value);
  // @@protoc_insertion_point(field_add:ams.device.grpc.Schedule.day_of_week)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Schedule::day_of_week() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.Schedule.day_of_week)
  return _impl_.day_of_week_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Schedule::_internal_mutable_day_of_week() {
  return &_impl_.day_of_week_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Schedule::mutable_day_of_week() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.Schedule.day_of_week)
  return _internal_mutable_day_of_week();
}

// string start_time = 6;
inline void Schedule::clear_start_time() {
  _impl_.start_time_.ClearToEmpty();
}
inline const std::string& Schedule::start_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.start_time)
  return _internal_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_start_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.start_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.start_time)
}
inline std::string* Schedule::mutable_start_time() {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.start_time)
  return _s;
}
inline const std::string& Schedule::_internal_start_time() const {
  return _impl_.start_time_.Get();
}
inline void Schedule::_internal_set_start_time(const std::string& value) {
  
  _impl_.start_time_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_start_time() {
  
  return _impl_.start_time_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_start_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.start_time)
  return _impl_.start_time_.Release();
}
inline void Schedule::set_allocated_start_time(std::string* start_time) {
  if (start_time != nullptr) {
    
  } else {
    
  }
  _impl_.start_time_.SetAllocated(start_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.start_time)
}

// optional string end_time = 7;
inline bool Schedule::_internal_has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Schedule::has_end_time() const {
  return _internal_has_end_time();
}
inline void Schedule::clear_end_time() {
  _impl_.end_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Schedule::end_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.end_time)
  return _internal_end_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_end_time(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.end_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.end_time)
}
inline std::string* Schedule::mutable_end_time() {
  std::string* _s = _internal_mutable_end_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.end_time)
  return _s;
}
inline const std::string& Schedule::_internal_end_time() const {
  return _impl_.end_time_.Get();
}
inline void Schedule::_internal_set_end_time(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_time_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_end_time() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.end_time_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_end_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.end_time)
  if (!_internal_has_end_time()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.end_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_time_.IsDefault()) {
    _impl_.end_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Schedule::set_allocated_end_time(std::string* end_time) {
  if (end_time != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.end_time_.SetAllocated(end_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_time_.IsDefault()) {
    _impl_.end_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.end_time)
}

// int32 time_interval = 8;
inline void Schedule::clear_time_interval() {
  _impl_.time_interval_ = 0;
}
inline int32_t Schedule::_internal_time_interval() const {
  return _impl_.time_interval_;
}
inline int32_t Schedule::time_interval() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.time_interval)
  return _internal_time_interval();
}
inline void Schedule::_internal_set_time_interval(int32_t value) {
  
  _impl_.time_interval_ = value;
}
inline void Schedule::set_time_interval(int32_t value) {
  _internal_set_time_interval(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.time_interval)
}

// string sound_id = 9;
inline void Schedule::clear_sound_id() {
  _impl_.sound_id_.ClearToEmpty();
}
inline const std::string& Schedule::sound_id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.sound_id)
  return _internal_sound_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_sound_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sound_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.sound_id)
}
inline std::string* Schedule::mutable_sound_id() {
  std::string* _s = _internal_mutable_sound_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.sound_id)
  return _s;
}
inline const std::string& Schedule::_internal_sound_id() const {
  return _impl_.sound_id_.Get();
}
inline void Schedule::_internal_set_sound_id(const std::string& value) {
  
  _impl_.sound_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_sound_id() {
  
  return _impl_.sound_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_sound_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.sound_id)
  return _impl_.sound_id_.Release();
}
inline void Schedule::set_allocated_sound_id(std::string* sound_id) {
  if (sound_id != nullptr) {
    
  } else {
    
  }
  _impl_.sound_id_.SetAllocated(sound_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sound_id_.IsDefault()) {
    _impl_.sound_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.sound_id)
}

// string display_text = 10;
inline void Schedule::clear_display_text() {
  _impl_.display_text_.ClearToEmpty();
}
inline const std::string& Schedule::display_text() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.display_text)
  return _internal_display_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Schedule::set_display_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.display_text)
}
inline std::string* Schedule::mutable_display_text() {
  std::string* _s = _internal_mutable_display_text();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.display_text)
  return _s;
}
inline const std::string& Schedule::_internal_display_text() const {
  return _impl_.display_text_.Get();
}
inline void Schedule::_internal_set_display_text(const std::string& value) {
  
  _impl_.display_text_.Set(value, GetArenaForAllocation());
}
inline std::string* Schedule::_internal_mutable_display_text() {
  
  return _impl_.display_text_.Mutable(GetArenaForAllocation());
}
inline std::string* Schedule::release_display_text() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.Schedule.display_text)
  return _impl_.display_text_.Release();
}
inline void Schedule::set_allocated_display_text(std::string* display_text) {
  if (display_text != nullptr) {
    
  } else {
    
  }
  _impl_.display_text_.SetAllocated(display_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_text_.IsDefault()) {
    _impl_.display_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.Schedule.display_text)
}

// repeated string exception_date = 11;
inline int Schedule::_internal_exception_date_size() const {
  return _impl_.exception_date_.size();
}
inline int Schedule::exception_date_size() const {
  return _internal_exception_date_size();
}
inline void Schedule::clear_exception_date() {
  _impl_.exception_date_.Clear();
}
inline std::string* Schedule::add_exception_date() {
  std::string* _s = _internal_add_exception_date();
  // @@protoc_insertion_point(field_add_mutable:ams.device.grpc.Schedule.exception_date)
  return _s;
}
inline const std::string& Schedule::_internal_exception_date(int index) const {
  return _impl_.exception_date_.Get(index);
}
inline const std::string& Schedule::exception_date(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.exception_date)
  return _internal_exception_date(index);
}
inline std::string* Schedule::mutable_exception_date(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.exception_date)
  return _impl_.exception_date_.Mutable(index);
}
inline void Schedule::set_exception_date(int index, const std::string& value) {
  _impl_.exception_date_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::set_exception_date(int index, std::string&& value) {
  _impl_.exception_date_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::set_exception_date(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exception_date_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::set_exception_date(int index, const char* value, size_t size) {
  _impl_.exception_date_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ams.device.grpc.Schedule.exception_date)
}
inline std::string* Schedule::_internal_add_exception_date() {
  return _impl_.exception_date_.Add();
}
inline void Schedule::add_exception_date(const std::string& value) {
  _impl_.exception_date_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::add_exception_date(std::string&& value) {
  _impl_.exception_date_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::add_exception_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exception_date_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ams.device.grpc.Schedule.exception_date)
}
inline void Schedule::add_exception_date(const char* value, size_t size) {
  _impl_.exception_date_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ams.device.grpc.Schedule.exception_date)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Schedule::exception_date() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.Schedule.exception_date)
  return _impl_.exception_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Schedule::mutable_exception_date() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.Schedule.exception_date)
  return &_impl_.exception_date_;
}

// repeated string exception_datetime = 12;
inline int Schedule::_internal_exception_datetime_size() const {
  return _impl_.exception_datetime_.size();
}
inline int Schedule::exception_datetime_size() const {
  return _internal_exception_datetime_size();
}
inline void Schedule::clear_exception_datetime() {
  _impl_.exception_datetime_.Clear();
}
inline std::string* Schedule::add_exception_datetime() {
  std::string* _s = _internal_add_exception_datetime();
  // @@protoc_insertion_point(field_add_mutable:ams.device.grpc.Schedule.exception_datetime)
  return _s;
}
inline const std::string& Schedule::_internal_exception_datetime(int index) const {
  return _impl_.exception_datetime_.Get(index);
}
inline const std::string& Schedule::exception_datetime(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.exception_datetime)
  return _internal_exception_datetime(index);
}
inline std::string* Schedule::mutable_exception_datetime(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.Schedule.exception_datetime)
  return _impl_.exception_datetime_.Mutable(index);
}
inline void Schedule::set_exception_datetime(int index, const std::string& value) {
  _impl_.exception_datetime_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::set_exception_datetime(int index, std::string&& value) {
  _impl_.exception_datetime_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::set_exception_datetime(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exception_datetime_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::set_exception_datetime(int index, const char* value, size_t size) {
  _impl_.exception_datetime_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ams.device.grpc.Schedule.exception_datetime)
}
inline std::string* Schedule::_internal_add_exception_datetime() {
  return _impl_.exception_datetime_.Add();
}
inline void Schedule::add_exception_datetime(const std::string& value) {
  _impl_.exception_datetime_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::add_exception_datetime(std::string&& value) {
  _impl_.exception_datetime_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::add_exception_datetime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.exception_datetime_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ams.device.grpc.Schedule.exception_datetime)
}
inline void Schedule::add_exception_datetime(const char* value, size_t size) {
  _impl_.exception_datetime_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ams.device.grpc.Schedule.exception_datetime)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Schedule::exception_datetime() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.Schedule.exception_datetime)
  return _impl_.exception_datetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Schedule::mutable_exception_datetime() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.Schedule.exception_datetime)
  return &_impl_.exception_datetime_;
}

// bool enabled = 13;
inline void Schedule::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool Schedule::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool Schedule::enabled() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.enabled)
  return _internal_enabled();
}
inline void Schedule::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void Schedule::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.enabled)
}

// int32 volume = 14;
inline void Schedule::clear_volume() {
  _impl_.volume_ = 0;
}
inline int32_t Schedule::_internal_volume() const {
  return _impl_.volume_;
}
inline int32_t Schedule::volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.Schedule.volume)
  return _internal_volume();
}
inline void Schedule::_internal_set_volume(int32_t value) {
  
  _impl_.volume_ = value;
}
inline void Schedule::set_volume(int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.Schedule.volume)
}

// -------------------------------------------------------------------

// GetScheduleListRequest

// -------------------------------------------------------------------

// AddScheduleRequest

// .ams.device.grpc.Schedule schedule = 1;
inline bool AddScheduleRequest::_internal_has_schedule() const {
  return this != internal_default_instance() && _impl_.schedule_ != nullptr;
}
inline bool AddScheduleRequest::has_schedule() const {
  return _internal_has_schedule();
}
inline void AddScheduleRequest::clear_schedule() {
  if (GetArenaForAllocation() == nullptr && _impl_.schedule_ != nullptr) {
    delete _impl_.schedule_;
  }
  _impl_.schedule_ = nullptr;
}
inline const ::ams::device::grpc::Schedule& AddScheduleRequest::_internal_schedule() const {
  const ::ams::device::grpc::Schedule* p = _impl_.schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::Schedule&>(
      ::ams::device::grpc::_Schedule_default_instance_);
}
inline const ::ams::device::grpc::Schedule& AddScheduleRequest::schedule() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AddScheduleRequest.schedule)
  return _internal_schedule();
}
inline void AddScheduleRequest::unsafe_arena_set_allocated_schedule(
    ::ams::device::grpc::Schedule* schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schedule_);
  }
  _impl_.schedule_ = schedule;
  if (schedule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.AddScheduleRequest.schedule)
}
inline ::ams::device::grpc::Schedule* AddScheduleRequest::release_schedule() {
  
  ::ams::device::grpc::Schedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::Schedule* AddScheduleRequest::unsafe_arena_release_schedule() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AddScheduleRequest.schedule)
  
  ::ams::device::grpc::Schedule* temp = _impl_.schedule_;
  _impl_.schedule_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::Schedule* AddScheduleRequest::_internal_mutable_schedule() {
  
  if (_impl_.schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::Schedule>(GetArenaForAllocation());
    _impl_.schedule_ = p;
  }
  return _impl_.schedule_;
}
inline ::ams::device::grpc::Schedule* AddScheduleRequest::mutable_schedule() {
  ::ams::device::grpc::Schedule* _msg = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AddScheduleRequest.schedule)
  return _msg;
}
inline void AddScheduleRequest::set_allocated_schedule(::ams::device::grpc::Schedule* schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schedule_;
  }
  if (schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schedule);
    if (message_arena != submessage_arena) {
      schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AddScheduleRequest.schedule)
}

// -------------------------------------------------------------------

// DeleteScheduleRequest

// string id = 1;
inline void DeleteScheduleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteScheduleRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeleteScheduleRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteScheduleRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeleteScheduleRequest.id)
}
inline std::string* DeleteScheduleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeleteScheduleRequest.id)
  return _s;
}
inline const std::string& DeleteScheduleRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeleteScheduleRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteScheduleRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteScheduleRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeleteScheduleRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteScheduleRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeleteScheduleRequest.id)
}

// -------------------------------------------------------------------

// SetScheduleRequest

// string id = 1;
inline void SetScheduleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SetScheduleRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetScheduleRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetScheduleRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetScheduleRequest.id)
}
inline std::string* SetScheduleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SetScheduleRequest.id)
  return _s;
}
inline const std::string& SetScheduleRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SetScheduleRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetScheduleRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetScheduleRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SetScheduleRequest.id)
  return _impl_.id_.Release();
}
inline void SetScheduleRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SetScheduleRequest.id)
}

// bool enabled = 2;
inline void SetScheduleRequest::clear_enabled() {
  _impl_.enabled_ = false;
}
inline bool SetScheduleRequest::_internal_enabled() const {
  return _impl_.enabled_;
}
inline bool SetScheduleRequest::enabled() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetScheduleRequest.enabled)
  return _internal_enabled();
}
inline void SetScheduleRequest::_internal_set_enabled(bool value) {
  
  _impl_.enabled_ = value;
}
inline void SetScheduleRequest::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetScheduleRequest.enabled)
}

// int32 volume = 3;
inline void SetScheduleRequest::clear_volume() {
  _impl_.volume_ = 0;
}
inline int32_t SetScheduleRequest::_internal_volume() const {
  return _impl_.volume_;
}
inline int32_t SetScheduleRequest::volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SetScheduleRequest.volume)
  return _internal_volume();
}
inline void SetScheduleRequest::_internal_set_volume(int32_t value) {
  
  _impl_.volume_ = value;
}
inline void SetScheduleRequest::set_volume(int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.SetScheduleRequest.volume)
}

// -------------------------------------------------------------------

// ExceptionScheduleRequest

// string id = 1;
inline void ExceptionScheduleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ExceptionScheduleRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ExceptionScheduleRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExceptionScheduleRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.ExceptionScheduleRequest.id)
}
inline std::string* ExceptionScheduleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ExceptionScheduleRequest.id)
  return _s;
}
inline const std::string& ExceptionScheduleRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ExceptionScheduleRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ExceptionScheduleRequest.id)
  return _impl_.id_.Release();
}
inline void ExceptionScheduleRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.ExceptionScheduleRequest.id)
}

// string exception_date = 2;
inline void ExceptionScheduleRequest::clear_exception_date() {
  _impl_.exception_date_.ClearToEmpty();
}
inline const std::string& ExceptionScheduleRequest::exception_date() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ExceptionScheduleRequest.exception_date)
  return _internal_exception_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExceptionScheduleRequest::set_exception_date(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exception_date_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.ExceptionScheduleRequest.exception_date)
}
inline std::string* ExceptionScheduleRequest::mutable_exception_date() {
  std::string* _s = _internal_mutable_exception_date();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ExceptionScheduleRequest.exception_date)
  return _s;
}
inline const std::string& ExceptionScheduleRequest::_internal_exception_date() const {
  return _impl_.exception_date_.Get();
}
inline void ExceptionScheduleRequest::_internal_set_exception_date(const std::string& value) {
  
  _impl_.exception_date_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::_internal_mutable_exception_date() {
  
  return _impl_.exception_date_.Mutable(GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::release_exception_date() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ExceptionScheduleRequest.exception_date)
  return _impl_.exception_date_.Release();
}
inline void ExceptionScheduleRequest::set_allocated_exception_date(std::string* exception_date) {
  if (exception_date != nullptr) {
    
  } else {
    
  }
  _impl_.exception_date_.SetAllocated(exception_date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exception_date_.IsDefault()) {
    _impl_.exception_date_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.ExceptionScheduleRequest.exception_date)
}

// optional string exception_time = 3;
inline bool ExceptionScheduleRequest::_internal_has_exception_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExceptionScheduleRequest::has_exception_time() const {
  return _internal_has_exception_time();
}
inline void ExceptionScheduleRequest::clear_exception_time() {
  _impl_.exception_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExceptionScheduleRequest::exception_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ExceptionScheduleRequest.exception_time)
  return _internal_exception_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExceptionScheduleRequest::set_exception_time(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.exception_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.ExceptionScheduleRequest.exception_time)
}
inline std::string* ExceptionScheduleRequest::mutable_exception_time() {
  std::string* _s = _internal_mutable_exception_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ExceptionScheduleRequest.exception_time)
  return _s;
}
inline const std::string& ExceptionScheduleRequest::_internal_exception_time() const {
  return _impl_.exception_time_.Get();
}
inline void ExceptionScheduleRequest::_internal_set_exception_time(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.exception_time_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::_internal_mutable_exception_time() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.exception_time_.Mutable(GetArenaForAllocation());
}
inline std::string* ExceptionScheduleRequest::release_exception_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ExceptionScheduleRequest.exception_time)
  if (!_internal_has_exception_time()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.exception_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exception_time_.IsDefault()) {
    _impl_.exception_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ExceptionScheduleRequest::set_allocated_exception_time(std::string* exception_time) {
  if (exception_time != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.exception_time_.SetAllocated(exception_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exception_time_.IsDefault()) {
    _impl_.exception_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.ExceptionScheduleRequest.exception_time)
}

// -------------------------------------------------------------------

// StartBroadcastRequest

// string id = 1;
inline void StartBroadcastRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StartBroadcastRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.StartBroadcastRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartBroadcastRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.StartBroadcastRequest.id)
}
inline std::string* StartBroadcastRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.StartBroadcastRequest.id)
  return _s;
}
inline const std::string& StartBroadcastRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void StartBroadcastRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* StartBroadcastRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* StartBroadcastRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.StartBroadcastRequest.id)
  return _impl_.id_.Release();
}
inline void StartBroadcastRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.StartBroadcastRequest.id)
}

// string display_text = 2;
inline void StartBroadcastRequest::clear_display_text() {
  _impl_.display_text_.ClearToEmpty();
}
inline const std::string& StartBroadcastRequest::display_text() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.StartBroadcastRequest.display_text)
  return _internal_display_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartBroadcastRequest::set_display_text(ArgT0&& arg0, ArgT... args) {
 
 _impl_.display_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.StartBroadcastRequest.display_text)
}
inline std::string* StartBroadcastRequest::mutable_display_text() {
  std::string* _s = _internal_mutable_display_text();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.StartBroadcastRequest.display_text)
  return _s;
}
inline const std::string& StartBroadcastRequest::_internal_display_text() const {
  return _impl_.display_text_.Get();
}
inline void StartBroadcastRequest::_internal_set_display_text(const std::string& value) {
  
  _impl_.display_text_.Set(value, GetArenaForAllocation());
}
inline std::string* StartBroadcastRequest::_internal_mutable_display_text() {
  
  return _impl_.display_text_.Mutable(GetArenaForAllocation());
}
inline std::string* StartBroadcastRequest::release_display_text() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.StartBroadcastRequest.display_text)
  return _impl_.display_text_.Release();
}
inline void StartBroadcastRequest::set_allocated_display_text(std::string* display_text) {
  if (display_text != nullptr) {
    
  } else {
    
  }
  _impl_.display_text_.SetAllocated(display_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.display_text_.IsDefault()) {
    _impl_.display_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.StartBroadcastRequest.display_text)
}

// int32 volume = 3;
inline void StartBroadcastRequest::clear_volume() {
  _impl_.volume_ = 0;
}
inline int32_t StartBroadcastRequest::_internal_volume() const {
  return _impl_.volume_;
}
inline int32_t StartBroadcastRequest::volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.StartBroadcastRequest.volume)
  return _internal_volume();
}
inline void StartBroadcastRequest::_internal_set_volume(int32_t value) {
  
  _impl_.volume_ = value;
}
inline void StartBroadcastRequest::set_volume(int32_t value) {
  _internal_set_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.StartBroadcastRequest.volume)
}

// -------------------------------------------------------------------

// StopBroadcastRequest

// -------------------------------------------------------------------

// AudioClip

// string id = 1;
inline void AudioClip::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AudioClip::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AudioClip.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioClip::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.AudioClip.id)
}
inline std::string* AudioClip::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AudioClip.id)
  return _s;
}
inline const std::string& AudioClip::_internal_id() const {
  return _impl_.id_.Get();
}
inline void AudioClip::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioClip::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioClip::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AudioClip.id)
  return _impl_.id_.Release();
}
inline void AudioClip::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AudioClip.id)
}

// string name = 2;
inline void AudioClip::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AudioClip::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AudioClip.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioClip::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.AudioClip.name)
}
inline std::string* AudioClip::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AudioClip.name)
  return _s;
}
inline const std::string& AudioClip::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AudioClip::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioClip::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioClip::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AudioClip.name)
  return _impl_.name_.Release();
}
inline void AudioClip::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AudioClip.name)
}

// string filename = 3;
inline void AudioClip::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& AudioClip::filename() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AudioClip.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioClip::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.AudioClip.filename)
}
inline std::string* AudioClip::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AudioClip.filename)
  return _s;
}
inline const std::string& AudioClip::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void AudioClip::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioClip::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioClip::release_filename() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AudioClip.filename)
  return _impl_.filename_.Release();
}
inline void AudioClip::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AudioClip.filename)
}

// string presigned_url = 4;
inline void AudioClip::clear_presigned_url() {
  _impl_.presigned_url_.ClearToEmpty();
}
inline const std::string& AudioClip::presigned_url() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AudioClip.presigned_url)
  return _internal_presigned_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioClip::set_presigned_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.presigned_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.AudioClip.presigned_url)
}
inline std::string* AudioClip::mutable_presigned_url() {
  std::string* _s = _internal_mutable_presigned_url();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AudioClip.presigned_url)
  return _s;
}
inline const std::string& AudioClip::_internal_presigned_url() const {
  return _impl_.presigned_url_.Get();
}
inline void AudioClip::_internal_set_presigned_url(const std::string& value) {
  
  _impl_.presigned_url_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioClip::_internal_mutable_presigned_url() {
  
  return _impl_.presigned_url_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioClip::release_presigned_url() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AudioClip.presigned_url)
  return _impl_.presigned_url_.Release();
}
inline void AudioClip::set_allocated_presigned_url(std::string* presigned_url) {
  if (presigned_url != nullptr) {
    
  } else {
    
  }
  _impl_.presigned_url_.SetAllocated(presigned_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.presigned_url_.IsDefault()) {
    _impl_.presigned_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AudioClip.presigned_url)
}

// -------------------------------------------------------------------

// AddAudioClipRequest

// .ams.device.grpc.AudioClip clip = 1;
inline bool AddAudioClipRequest::_internal_has_clip() const {
  return this != internal_default_instance() && _impl_.clip_ != nullptr;
}
inline bool AddAudioClipRequest::has_clip() const {
  return _internal_has_clip();
}
inline void AddAudioClipRequest::clear_clip() {
  if (GetArenaForAllocation() == nullptr && _impl_.clip_ != nullptr) {
    delete _impl_.clip_;
  }
  _impl_.clip_ = nullptr;
}
inline const ::ams::device::grpc::AudioClip& AddAudioClipRequest::_internal_clip() const {
  const ::ams::device::grpc::AudioClip* p = _impl_.clip_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::AudioClip&>(
      ::ams::device::grpc::_AudioClip_default_instance_);
}
inline const ::ams::device::grpc::AudioClip& AddAudioClipRequest::clip() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.AddAudioClipRequest.clip)
  return _internal_clip();
}
inline void AddAudioClipRequest::unsafe_arena_set_allocated_clip(
    ::ams::device::grpc::AudioClip* clip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clip_);
  }
  _impl_.clip_ = clip;
  if (clip) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.AddAudioClipRequest.clip)
}
inline ::ams::device::grpc::AudioClip* AddAudioClipRequest::release_clip() {
  
  ::ams::device::grpc::AudioClip* temp = _impl_.clip_;
  _impl_.clip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::AudioClip* AddAudioClipRequest::unsafe_arena_release_clip() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.AddAudioClipRequest.clip)
  
  ::ams::device::grpc::AudioClip* temp = _impl_.clip_;
  _impl_.clip_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::AudioClip* AddAudioClipRequest::_internal_mutable_clip() {
  
  if (_impl_.clip_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::AudioClip>(GetArenaForAllocation());
    _impl_.clip_ = p;
  }
  return _impl_.clip_;
}
inline ::ams::device::grpc::AudioClip* AddAudioClipRequest::mutable_clip() {
  ::ams::device::grpc::AudioClip* _msg = _internal_mutable_clip();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.AddAudioClipRequest.clip)
  return _msg;
}
inline void AddAudioClipRequest::set_allocated_clip(::ams::device::grpc::AudioClip* clip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.clip_;
  }
  if (clip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clip);
    if (message_arena != submessage_arena) {
      clip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clip, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.clip_ = clip;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.AddAudioClipRequest.clip)
}

// -------------------------------------------------------------------

// EditAudioClipRequest

// string id = 1;
inline void EditAudioClipRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& EditAudioClipRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.EditAudioClipRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditAudioClipRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.EditAudioClipRequest.id)
}
inline std::string* EditAudioClipRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.EditAudioClipRequest.id)
  return _s;
}
inline const std::string& EditAudioClipRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void EditAudioClipRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* EditAudioClipRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* EditAudioClipRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.EditAudioClipRequest.id)
  return _impl_.id_.Release();
}
inline void EditAudioClipRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.EditAudioClipRequest.id)
}

// string name = 2;
inline void EditAudioClipRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& EditAudioClipRequest::name() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.EditAudioClipRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EditAudioClipRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.EditAudioClipRequest.name)
}
inline std::string* EditAudioClipRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.EditAudioClipRequest.name)
  return _s;
}
inline const std::string& EditAudioClipRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void EditAudioClipRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* EditAudioClipRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* EditAudioClipRequest::release_name() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.EditAudioClipRequest.name)
  return _impl_.name_.Release();
}
inline void EditAudioClipRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.EditAudioClipRequest.name)
}

// -------------------------------------------------------------------

// DeleteAudioClipRequest

// string id = 1;
inline void DeleteAudioClipRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteAudioClipRequest::id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeleteAudioClipRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteAudioClipRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeleteAudioClipRequest.id)
}
inline std::string* DeleteAudioClipRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeleteAudioClipRequest.id)
  return _s;
}
inline const std::string& DeleteAudioClipRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void DeleteAudioClipRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAudioClipRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteAudioClipRequest::release_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeleteAudioClipRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteAudioClipRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeleteAudioClipRequest.id)
}

// -------------------------------------------------------------------

// SystemRebootRequest

// -------------------------------------------------------------------

// GetSystemDateAndTimeResponse

// .ams.device.grpc.DateTimeType date_time_type = 1;
inline void GetSystemDateAndTimeResponse::clear_date_time_type() {
  _impl_.date_time_type_ = 0;
}
inline ::ams::device::grpc::DateTimeType GetSystemDateAndTimeResponse::_internal_date_time_type() const {
  return static_cast< ::ams::device::grpc::DateTimeType >(_impl_.date_time_type_);
}
inline ::ams::device::grpc::DateTimeType GetSystemDateAndTimeResponse::date_time_type() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSystemDateAndTimeResponse.date_time_type)
  return _internal_date_time_type();
}
inline void GetSystemDateAndTimeResponse::_internal_set_date_time_type(::ams::device::grpc::DateTimeType value) {
  
  _impl_.date_time_type_ = value;
}
inline void GetSystemDateAndTimeResponse::set_date_time_type(::ams::device::grpc::DateTimeType value) {
  _internal_set_date_time_type(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSystemDateAndTimeResponse.date_time_type)
}

// string time_zone = 2;
inline void GetSystemDateAndTimeResponse::clear_time_zone() {
  _impl_.time_zone_.ClearToEmpty();
}
inline const std::string& GetSystemDateAndTimeResponse::time_zone() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSystemDateAndTimeResponse.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSystemDateAndTimeResponse::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSystemDateAndTimeResponse.time_zone)
}
inline std::string* GetSystemDateAndTimeResponse::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSystemDateAndTimeResponse.time_zone)
  return _s;
}
inline const std::string& GetSystemDateAndTimeResponse::_internal_time_zone() const {
  return _impl_.time_zone_.Get();
}
inline void GetSystemDateAndTimeResponse::_internal_set_time_zone(const std::string& value) {
  
  _impl_.time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::_internal_mutable_time_zone() {
  
  return _impl_.time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::release_time_zone() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetSystemDateAndTimeResponse.time_zone)
  return _impl_.time_zone_.Release();
}
inline void GetSystemDateAndTimeResponse::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  _impl_.time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_zone_.IsDefault()) {
    _impl_.time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetSystemDateAndTimeResponse.time_zone)
}

// string utc_time = 3;
inline void GetSystemDateAndTimeResponse::clear_utc_time() {
  _impl_.utc_time_.ClearToEmpty();
}
inline const std::string& GetSystemDateAndTimeResponse::utc_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSystemDateAndTimeResponse.utc_time)
  return _internal_utc_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSystemDateAndTimeResponse::set_utc_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.utc_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSystemDateAndTimeResponse.utc_time)
}
inline std::string* GetSystemDateAndTimeResponse::mutable_utc_time() {
  std::string* _s = _internal_mutable_utc_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSystemDateAndTimeResponse.utc_time)
  return _s;
}
inline const std::string& GetSystemDateAndTimeResponse::_internal_utc_time() const {
  return _impl_.utc_time_.Get();
}
inline void GetSystemDateAndTimeResponse::_internal_set_utc_time(const std::string& value) {
  
  _impl_.utc_time_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::_internal_mutable_utc_time() {
  
  return _impl_.utc_time_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::release_utc_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetSystemDateAndTimeResponse.utc_time)
  return _impl_.utc_time_.Release();
}
inline void GetSystemDateAndTimeResponse::set_allocated_utc_time(std::string* utc_time) {
  if (utc_time != nullptr) {
    
  } else {
    
  }
  _impl_.utc_time_.SetAllocated(utc_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.utc_time_.IsDefault()) {
    _impl_.utc_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetSystemDateAndTimeResponse.utc_time)
}

// string local_time = 4;
inline void GetSystemDateAndTimeResponse::clear_local_time() {
  _impl_.local_time_.ClearToEmpty();
}
inline const std::string& GetSystemDateAndTimeResponse::local_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSystemDateAndTimeResponse.local_time)
  return _internal_local_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSystemDateAndTimeResponse::set_local_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.local_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSystemDateAndTimeResponse.local_time)
}
inline std::string* GetSystemDateAndTimeResponse::mutable_local_time() {
  std::string* _s = _internal_mutable_local_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSystemDateAndTimeResponse.local_time)
  return _s;
}
inline const std::string& GetSystemDateAndTimeResponse::_internal_local_time() const {
  return _impl_.local_time_.Get();
}
inline void GetSystemDateAndTimeResponse::_internal_set_local_time(const std::string& value) {
  
  _impl_.local_time_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::_internal_mutable_local_time() {
  
  return _impl_.local_time_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::release_local_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetSystemDateAndTimeResponse.local_time)
  return _impl_.local_time_.Release();
}
inline void GetSystemDateAndTimeResponse::set_allocated_local_time(std::string* local_time) {
  if (local_time != nullptr) {
    
  } else {
    
  }
  _impl_.local_time_.SetAllocated(local_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.local_time_.IsDefault()) {
    _impl_.local_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetSystemDateAndTimeResponse.local_time)
}

// string ntp_server = 5;
inline void GetSystemDateAndTimeResponse::clear_ntp_server() {
  _impl_.ntp_server_.ClearToEmpty();
}
inline const std::string& GetSystemDateAndTimeResponse::ntp_server() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSystemDateAndTimeResponse.ntp_server)
  return _internal_ntp_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSystemDateAndTimeResponse::set_ntp_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ntp_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSystemDateAndTimeResponse.ntp_server)
}
inline std::string* GetSystemDateAndTimeResponse::mutable_ntp_server() {
  std::string* _s = _internal_mutable_ntp_server();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSystemDateAndTimeResponse.ntp_server)
  return _s;
}
inline const std::string& GetSystemDateAndTimeResponse::_internal_ntp_server() const {
  return _impl_.ntp_server_.Get();
}
inline void GetSystemDateAndTimeResponse::_internal_set_ntp_server(const std::string& value) {
  
  _impl_.ntp_server_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::_internal_mutable_ntp_server() {
  
  return _impl_.ntp_server_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSystemDateAndTimeResponse::release_ntp_server() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetSystemDateAndTimeResponse.ntp_server)
  return _impl_.ntp_server_.Release();
}
inline void GetSystemDateAndTimeResponse::set_allocated_ntp_server(std::string* ntp_server) {
  if (ntp_server != nullptr) {
    
  } else {
    
  }
  _impl_.ntp_server_.SetAllocated(ntp_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ntp_server_.IsDefault()) {
    _impl_.ntp_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetSystemDateAndTimeResponse.ntp_server)
}

// -------------------------------------------------------------------

// GetNetworkInterfacesResponse

// .ams.device.grpc.NetworkMode mode = 1;
inline void GetNetworkInterfacesResponse::clear_mode() {
  _impl_.mode_ = 0;
}
inline ::ams::device::grpc::NetworkMode GetNetworkInterfacesResponse::_internal_mode() const {
  return static_cast< ::ams::device::grpc::NetworkMode >(_impl_.mode_);
}
inline ::ams::device::grpc::NetworkMode GetNetworkInterfacesResponse::mode() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.mode)
  return _internal_mode();
}
inline void GetNetworkInterfacesResponse::_internal_set_mode(::ams::device::grpc::NetworkMode value) {
  
  _impl_.mode_ = value;
}
inline void GetNetworkInterfacesResponse::set_mode(::ams::device::grpc::NetworkMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.mode)
}

// string ipv4_address = 2;
inline void GetNetworkInterfacesResponse::clear_ipv4_address() {
  _impl_.ipv4_address_.ClearToEmpty();
}
inline const std::string& GetNetworkInterfacesResponse::ipv4_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.ipv4_address)
  return _internal_ipv4_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkInterfacesResponse::set_ipv4_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ipv4_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.ipv4_address)
}
inline std::string* GetNetworkInterfacesResponse::mutable_ipv4_address() {
  std::string* _s = _internal_mutable_ipv4_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetNetworkInterfacesResponse.ipv4_address)
  return _s;
}
inline const std::string& GetNetworkInterfacesResponse::_internal_ipv4_address() const {
  return _impl_.ipv4_address_.Get();
}
inline void GetNetworkInterfacesResponse::_internal_set_ipv4_address(const std::string& value) {
  
  _impl_.ipv4_address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::_internal_mutable_ipv4_address() {
  
  return _impl_.ipv4_address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::release_ipv4_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetNetworkInterfacesResponse.ipv4_address)
  return _impl_.ipv4_address_.Release();
}
inline void GetNetworkInterfacesResponse::set_allocated_ipv4_address(std::string* ipv4_address) {
  if (ipv4_address != nullptr) {
    
  } else {
    
  }
  _impl_.ipv4_address_.SetAllocated(ipv4_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ipv4_address_.IsDefault()) {
    _impl_.ipv4_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetNetworkInterfacesResponse.ipv4_address)
}

// string netmask = 3;
inline void GetNetworkInterfacesResponse::clear_netmask() {
  _impl_.netmask_.ClearToEmpty();
}
inline const std::string& GetNetworkInterfacesResponse::netmask() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.netmask)
  return _internal_netmask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkInterfacesResponse::set_netmask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.netmask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.netmask)
}
inline std::string* GetNetworkInterfacesResponse::mutable_netmask() {
  std::string* _s = _internal_mutable_netmask();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetNetworkInterfacesResponse.netmask)
  return _s;
}
inline const std::string& GetNetworkInterfacesResponse::_internal_netmask() const {
  return _impl_.netmask_.Get();
}
inline void GetNetworkInterfacesResponse::_internal_set_netmask(const std::string& value) {
  
  _impl_.netmask_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::_internal_mutable_netmask() {
  
  return _impl_.netmask_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::release_netmask() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetNetworkInterfacesResponse.netmask)
  return _impl_.netmask_.Release();
}
inline void GetNetworkInterfacesResponse::set_allocated_netmask(std::string* netmask) {
  if (netmask != nullptr) {
    
  } else {
    
  }
  _impl_.netmask_.SetAllocated(netmask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.netmask_.IsDefault()) {
    _impl_.netmask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetNetworkInterfacesResponse.netmask)
}

// string gateway = 4;
inline void GetNetworkInterfacesResponse::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& GetNetworkInterfacesResponse::gateway() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkInterfacesResponse::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.gateway)
}
inline std::string* GetNetworkInterfacesResponse::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetNetworkInterfacesResponse.gateway)
  return _s;
}
inline const std::string& GetNetworkInterfacesResponse::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void GetNetworkInterfacesResponse::_internal_set_gateway(const std::string& value) {
  
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::_internal_mutable_gateway() {
  
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::release_gateway() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetNetworkInterfacesResponse.gateway)
  return _impl_.gateway_.Release();
}
inline void GetNetworkInterfacesResponse::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetNetworkInterfacesResponse.gateway)
}

// repeated string dns = 5;
inline int GetNetworkInterfacesResponse::_internal_dns_size() const {
  return _impl_.dns_.size();
}
inline int GetNetworkInterfacesResponse::dns_size() const {
  return _internal_dns_size();
}
inline void GetNetworkInterfacesResponse::clear_dns() {
  _impl_.dns_.Clear();
}
inline std::string* GetNetworkInterfacesResponse::add_dns() {
  std::string* _s = _internal_add_dns();
  // @@protoc_insertion_point(field_add_mutable:ams.device.grpc.GetNetworkInterfacesResponse.dns)
  return _s;
}
inline const std::string& GetNetworkInterfacesResponse::_internal_dns(int index) const {
  return _impl_.dns_.Get(index);
}
inline const std::string& GetNetworkInterfacesResponse::dns(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.dns)
  return _internal_dns(index);
}
inline std::string* GetNetworkInterfacesResponse::mutable_dns(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetNetworkInterfacesResponse.dns)
  return _impl_.dns_.Mutable(index);
}
inline void GetNetworkInterfacesResponse::set_dns(int index, const std::string& value) {
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::set_dns(int index, std::string&& value) {
  _impl_.dns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::set_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::set_dns(int index, const char* value, size_t size) {
  _impl_.dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline std::string* GetNetworkInterfacesResponse::_internal_add_dns() {
  return _impl_.dns_.Add();
}
inline void GetNetworkInterfacesResponse::add_dns(const std::string& value) {
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::add_dns(std::string&& value) {
  _impl_.dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::add_dns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline void GetNetworkInterfacesResponse::add_dns(const char* value, size_t size) {
  _impl_.dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ams.device.grpc.GetNetworkInterfacesResponse.dns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetNetworkInterfacesResponse::dns() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.GetNetworkInterfacesResponse.dns)
  return _impl_.dns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetNetworkInterfacesResponse::mutable_dns() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.GetNetworkInterfacesResponse.dns)
  return &_impl_.dns_;
}

// string hostname = 6;
inline void GetNetworkInterfacesResponse::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& GetNetworkInterfacesResponse::hostname() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetNetworkInterfacesResponse.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkInterfacesResponse::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetNetworkInterfacesResponse.hostname)
}
inline std::string* GetNetworkInterfacesResponse::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetNetworkInterfacesResponse.hostname)
  return _s;
}
inline const std::string& GetNetworkInterfacesResponse::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void GetNetworkInterfacesResponse::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* GetNetworkInterfacesResponse::release_hostname() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetNetworkInterfacesResponse.hostname)
  return _impl_.hostname_.Release();
}
inline void GetNetworkInterfacesResponse::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetNetworkInterfacesResponse.hostname)
}

// -------------------------------------------------------------------

// GetSipInformationResponse

// repeated .ams.device.grpc.SipAccount accounts = 1;
inline int GetSipInformationResponse::_internal_accounts_size() const {
  return _impl_.accounts_.size();
}
inline int GetSipInformationResponse::accounts_size() const {
  return _internal_accounts_size();
}
inline void GetSipInformationResponse::clear_accounts() {
  _impl_.accounts_.Clear();
}
inline ::ams::device::grpc::SipAccount* GetSipInformationResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSipInformationResponse.accounts)
  return _impl_.accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::SipAccount >*
GetSipInformationResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.GetSipInformationResponse.accounts)
  return &_impl_.accounts_;
}
inline const ::ams::device::grpc::SipAccount& GetSipInformationResponse::_internal_accounts(int index) const {
  return _impl_.accounts_.Get(index);
}
inline const ::ams::device::grpc::SipAccount& GetSipInformationResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSipInformationResponse.accounts)
  return _internal_accounts(index);
}
inline ::ams::device::grpc::SipAccount* GetSipInformationResponse::_internal_add_accounts() {
  return _impl_.accounts_.Add();
}
inline ::ams::device::grpc::SipAccount* GetSipInformationResponse::add_accounts() {
  ::ams::device::grpc::SipAccount* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:ams.device.grpc.GetSipInformationResponse.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::SipAccount >&
GetSipInformationResponse::accounts() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.GetSipInformationResponse.accounts)
  return _impl_.accounts_;
}

// -------------------------------------------------------------------

// GetOnvifInformationResponse

// repeated .ams.device.grpc.OnvifUser users = 1;
inline int GetOnvifInformationResponse::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int GetOnvifInformationResponse::users_size() const {
  return _internal_users_size();
}
inline void GetOnvifInformationResponse::clear_users() {
  _impl_.users_.Clear();
}
inline ::ams::device::grpc::OnvifUser* GetOnvifInformationResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetOnvifInformationResponse.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::OnvifUser >*
GetOnvifInformationResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.GetOnvifInformationResponse.users)
  return &_impl_.users_;
}
inline const ::ams::device::grpc::OnvifUser& GetOnvifInformationResponse::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::ams::device::grpc::OnvifUser& GetOnvifInformationResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetOnvifInformationResponse.users)
  return _internal_users(index);
}
inline ::ams::device::grpc::OnvifUser* GetOnvifInformationResponse::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::ams::device::grpc::OnvifUser* GetOnvifInformationResponse::add_users() {
  ::ams::device::grpc::OnvifUser* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:ams.device.grpc.GetOnvifInformationResponse.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::OnvifUser >&
GetOnvifInformationResponse::users() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.GetOnvifInformationResponse.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// GetPaAddressResponse

// string address = 1;
inline void GetPaAddressResponse::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetPaAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetPaAddressResponse.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPaAddressResponse::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetPaAddressResponse.address)
}
inline std::string* GetPaAddressResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetPaAddressResponse.address)
  return _s;
}
inline const std::string& GetPaAddressResponse::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetPaAddressResponse::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetPaAddressResponse::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetPaAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetPaAddressResponse.address)
  return _impl_.address_.Release();
}
inline void GetPaAddressResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetPaAddressResponse.address)
}

// -------------------------------------------------------------------

// GetSnapcastAddressResponse

// string address = 1;
inline void GetSnapcastAddressResponse::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetSnapcastAddressResponse::address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetSnapcastAddressResponse.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSnapcastAddressResponse::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetSnapcastAddressResponse.address)
}
inline std::string* GetSnapcastAddressResponse::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetSnapcastAddressResponse.address)
  return _s;
}
inline const std::string& GetSnapcastAddressResponse::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetSnapcastAddressResponse::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSnapcastAddressResponse::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSnapcastAddressResponse::release_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.GetSnapcastAddressResponse.address)
  return _impl_.address_.Release();
}
inline void GetSnapcastAddressResponse::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.GetSnapcastAddressResponse.address)
}

// -------------------------------------------------------------------

// GetVolumeResponse

// int32 speaker_volume = 1;
inline void GetVolumeResponse::clear_speaker_volume() {
  _impl_.speaker_volume_ = 0;
}
inline int32_t GetVolumeResponse::_internal_speaker_volume() const {
  return _impl_.speaker_volume_;
}
inline int32_t GetVolumeResponse::speaker_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetVolumeResponse.speaker_volume)
  return _internal_speaker_volume();
}
inline void GetVolumeResponse::_internal_set_speaker_volume(int32_t value) {
  
  _impl_.speaker_volume_ = value;
}
inline void GetVolumeResponse::set_speaker_volume(int32_t value) {
  _internal_set_speaker_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetVolumeResponse.speaker_volume)
}

// int32 mic_volume = 2;
inline void GetVolumeResponse::clear_mic_volume() {
  _impl_.mic_volume_ = 0;
}
inline int32_t GetVolumeResponse::_internal_mic_volume() const {
  return _impl_.mic_volume_;
}
inline int32_t GetVolumeResponse::mic_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetVolumeResponse.mic_volume)
  return _internal_mic_volume();
}
inline void GetVolumeResponse::_internal_set_mic_volume(int32_t value) {
  
  _impl_.mic_volume_ = value;
}
inline void GetVolumeResponse::set_mic_volume(int32_t value) {
  _internal_set_mic_volume(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.GetVolumeResponse.mic_volume)
}

// -------------------------------------------------------------------

// GetScheduleListResponse

// repeated .ams.device.grpc.Schedule schedules = 1;
inline int GetScheduleListResponse::_internal_schedules_size() const {
  return _impl_.schedules_.size();
}
inline int GetScheduleListResponse::schedules_size() const {
  return _internal_schedules_size();
}
inline void GetScheduleListResponse::clear_schedules() {
  _impl_.schedules_.Clear();
}
inline ::ams::device::grpc::Schedule* GetScheduleListResponse::mutable_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.GetScheduleListResponse.schedules)
  return _impl_.schedules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::Schedule >*
GetScheduleListResponse::mutable_schedules() {
  // @@protoc_insertion_point(field_mutable_list:ams.device.grpc.GetScheduleListResponse.schedules)
  return &_impl_.schedules_;
}
inline const ::ams::device::grpc::Schedule& GetScheduleListResponse::_internal_schedules(int index) const {
  return _impl_.schedules_.Get(index);
}
inline const ::ams::device::grpc::Schedule& GetScheduleListResponse::schedules(int index) const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.GetScheduleListResponse.schedules)
  return _internal_schedules(index);
}
inline ::ams::device::grpc::Schedule* GetScheduleListResponse::_internal_add_schedules() {
  return _impl_.schedules_.Add();
}
inline ::ams::device::grpc::Schedule* GetScheduleListResponse::add_schedules() {
  ::ams::device::grpc::Schedule* _add = _internal_add_schedules();
  // @@protoc_insertion_point(field_add:ams.device.grpc.GetScheduleListResponse.schedules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ams::device::grpc::Schedule >&
GetScheduleListResponse::schedules() const {
  // @@protoc_insertion_point(field_list:ams.device.grpc.GetScheduleListResponse.schedules)
  return _impl_.schedules_;
}

// -------------------------------------------------------------------

// SystemRebootResponse

// string message = 1;
inline void SystemRebootResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& SystemRebootResponse::message() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.SystemRebootResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemRebootResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.SystemRebootResponse.message)
}
inline std::string* SystemRebootResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.SystemRebootResponse.message)
  return _s;
}
inline const std::string& SystemRebootResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void SystemRebootResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemRebootResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemRebootResponse::release_message() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.SystemRebootResponse.message)
  return _impl_.message_.Release();
}
inline void SystemRebootResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.SystemRebootResponse.message)
}

// -------------------------------------------------------------------

// InitSessionNotify

// string mac_address = 1;
inline void InitSessionNotify::clear_mac_address() {
  _impl_.mac_address_.ClearToEmpty();
}
inline const std::string& InitSessionNotify::mac_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.InitSessionNotify.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitSessionNotify::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.InitSessionNotify.mac_address)
}
inline std::string* InitSessionNotify::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.InitSessionNotify.mac_address)
  return _s;
}
inline const std::string& InitSessionNotify::_internal_mac_address() const {
  return _impl_.mac_address_.Get();
}
inline void InitSessionNotify::_internal_set_mac_address(const std::string& value) {
  
  _impl_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* InitSessionNotify::_internal_mutable_mac_address() {
  
  return _impl_.mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* InitSessionNotify::release_mac_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.InitSessionNotify.mac_address)
  return _impl_.mac_address_.Release();
}
inline void InitSessionNotify::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  _impl_.mac_address_.SetAllocated(mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_address_.IsDefault()) {
    _impl_.mac_address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.InitSessionNotify.mac_address)
}

// -------------------------------------------------------------------

// ServerMessage

// string message_id = 1;
inline void ServerMessage::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& ServerMessage::message_id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServerMessage::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.ServerMessage.message_id)
}
inline std::string* ServerMessage::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.message_id)
  return _s;
}
inline const std::string& ServerMessage::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void ServerMessage::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMessage::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void ServerMessage::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.ServerMessage.message_id)
}

// .ams.device.grpc.SetDeviceInformationRequest set_device_information = 2;
inline bool ServerMessage::_internal_has_set_device_information() const {
  return payload_case() == kSetDeviceInformation;
}
inline bool ServerMessage::has_set_device_information() const {
  return _internal_has_set_device_information();
}
inline void ServerMessage::set_has_set_device_information() {
  _impl_._oneof_case_[0] = kSetDeviceInformation;
}
inline void ServerMessage::clear_set_device_information() {
  if (_internal_has_set_device_information()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_device_information_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetDeviceInformationRequest* ServerMessage::release_set_device_information() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_device_information)
  if (_internal_has_set_device_information()) {
    clear_has_payload();
    ::ams::device::grpc::SetDeviceInformationRequest* temp = _impl_.payload_.set_device_information_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_device_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetDeviceInformationRequest& ServerMessage::_internal_set_device_information() const {
  return _internal_has_set_device_information()
      ? *_impl_.payload_.set_device_information_
      : reinterpret_cast< ::ams::device::grpc::SetDeviceInformationRequest&>(::ams::device::grpc::_SetDeviceInformationRequest_default_instance_);
}
inline const ::ams::device::grpc::SetDeviceInformationRequest& ServerMessage::set_device_information() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_device_information)
  return _internal_set_device_information();
}
inline ::ams::device::grpc::SetDeviceInformationRequest* ServerMessage::unsafe_arena_release_set_device_information() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_device_information)
  if (_internal_has_set_device_information()) {
    clear_has_payload();
    ::ams::device::grpc::SetDeviceInformationRequest* temp = _impl_.payload_.set_device_information_;
    _impl_.payload_.set_device_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_device_information(::ams::device::grpc::SetDeviceInformationRequest* set_device_information) {
  clear_payload();
  if (set_device_information) {
    set_has_set_device_information();
    _impl_.payload_.set_device_information_ = set_device_information;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_device_information)
}
inline ::ams::device::grpc::SetDeviceInformationRequest* ServerMessage::_internal_mutable_set_device_information() {
  if (!_internal_has_set_device_information()) {
    clear_payload();
    set_has_set_device_information();
    _impl_.payload_.set_device_information_ = CreateMaybeMessage< ::ams::device::grpc::SetDeviceInformationRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_device_information_;
}
inline ::ams::device::grpc::SetDeviceInformationRequest* ServerMessage::mutable_set_device_information() {
  ::ams::device::grpc::SetDeviceInformationRequest* _msg = _internal_mutable_set_device_information();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_device_information)
  return _msg;
}

// .ams.device.grpc.GetSystemDateAndTimeRequest get_system_date_and_time = 3;
inline bool ServerMessage::_internal_has_get_system_date_and_time() const {
  return payload_case() == kGetSystemDateAndTime;
}
inline bool ServerMessage::has_get_system_date_and_time() const {
  return _internal_has_get_system_date_and_time();
}
inline void ServerMessage::set_has_get_system_date_and_time() {
  _impl_._oneof_case_[0] = kGetSystemDateAndTime;
}
inline void ServerMessage::clear_get_system_date_and_time() {
  if (_internal_has_get_system_date_and_time()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_system_date_and_time_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSystemDateAndTimeRequest* ServerMessage::release_get_system_date_and_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_system_date_and_time)
  if (_internal_has_get_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::GetSystemDateAndTimeRequest* temp = _impl_.payload_.get_system_date_and_time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSystemDateAndTimeRequest& ServerMessage::_internal_get_system_date_and_time() const {
  return _internal_has_get_system_date_and_time()
      ? *_impl_.payload_.get_system_date_and_time_
      : reinterpret_cast< ::ams::device::grpc::GetSystemDateAndTimeRequest&>(::ams::device::grpc::_GetSystemDateAndTimeRequest_default_instance_);
}
inline const ::ams::device::grpc::GetSystemDateAndTimeRequest& ServerMessage::get_system_date_and_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_system_date_and_time)
  return _internal_get_system_date_and_time();
}
inline ::ams::device::grpc::GetSystemDateAndTimeRequest* ServerMessage::unsafe_arena_release_get_system_date_and_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_system_date_and_time)
  if (_internal_has_get_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::GetSystemDateAndTimeRequest* temp = _impl_.payload_.get_system_date_and_time_;
    _impl_.payload_.get_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_system_date_and_time(::ams::device::grpc::GetSystemDateAndTimeRequest* get_system_date_and_time) {
  clear_payload();
  if (get_system_date_and_time) {
    set_has_get_system_date_and_time();
    _impl_.payload_.get_system_date_and_time_ = get_system_date_and_time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_system_date_and_time)
}
inline ::ams::device::grpc::GetSystemDateAndTimeRequest* ServerMessage::_internal_mutable_get_system_date_and_time() {
  if (!_internal_has_get_system_date_and_time()) {
    clear_payload();
    set_has_get_system_date_and_time();
    _impl_.payload_.get_system_date_and_time_ = CreateMaybeMessage< ::ams::device::grpc::GetSystemDateAndTimeRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_system_date_and_time_;
}
inline ::ams::device::grpc::GetSystemDateAndTimeRequest* ServerMessage::mutable_get_system_date_and_time() {
  ::ams::device::grpc::GetSystemDateAndTimeRequest* _msg = _internal_mutable_get_system_date_and_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_system_date_and_time)
  return _msg;
}

// .ams.device.grpc.SetSystemDateAndTimeRequest set_system_date_and_time = 4;
inline bool ServerMessage::_internal_has_set_system_date_and_time() const {
  return payload_case() == kSetSystemDateAndTime;
}
inline bool ServerMessage::has_set_system_date_and_time() const {
  return _internal_has_set_system_date_and_time();
}
inline void ServerMessage::set_has_set_system_date_and_time() {
  _impl_._oneof_case_[0] = kSetSystemDateAndTime;
}
inline void ServerMessage::clear_set_system_date_and_time() {
  if (_internal_has_set_system_date_and_time()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_system_date_and_time_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetSystemDateAndTimeRequest* ServerMessage::release_set_system_date_and_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_system_date_and_time)
  if (_internal_has_set_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::SetSystemDateAndTimeRequest* temp = _impl_.payload_.set_system_date_and_time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetSystemDateAndTimeRequest& ServerMessage::_internal_set_system_date_and_time() const {
  return _internal_has_set_system_date_and_time()
      ? *_impl_.payload_.set_system_date_and_time_
      : reinterpret_cast< ::ams::device::grpc::SetSystemDateAndTimeRequest&>(::ams::device::grpc::_SetSystemDateAndTimeRequest_default_instance_);
}
inline const ::ams::device::grpc::SetSystemDateAndTimeRequest& ServerMessage::set_system_date_and_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_system_date_and_time)
  return _internal_set_system_date_and_time();
}
inline ::ams::device::grpc::SetSystemDateAndTimeRequest* ServerMessage::unsafe_arena_release_set_system_date_and_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_system_date_and_time)
  if (_internal_has_set_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::SetSystemDateAndTimeRequest* temp = _impl_.payload_.set_system_date_and_time_;
    _impl_.payload_.set_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_system_date_and_time(::ams::device::grpc::SetSystemDateAndTimeRequest* set_system_date_and_time) {
  clear_payload();
  if (set_system_date_and_time) {
    set_has_set_system_date_and_time();
    _impl_.payload_.set_system_date_and_time_ = set_system_date_and_time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_system_date_and_time)
}
inline ::ams::device::grpc::SetSystemDateAndTimeRequest* ServerMessage::_internal_mutable_set_system_date_and_time() {
  if (!_internal_has_set_system_date_and_time()) {
    clear_payload();
    set_has_set_system_date_and_time();
    _impl_.payload_.set_system_date_and_time_ = CreateMaybeMessage< ::ams::device::grpc::SetSystemDateAndTimeRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_system_date_and_time_;
}
inline ::ams::device::grpc::SetSystemDateAndTimeRequest* ServerMessage::mutable_set_system_date_and_time() {
  ::ams::device::grpc::SetSystemDateAndTimeRequest* _msg = _internal_mutable_set_system_date_and_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_system_date_and_time)
  return _msg;
}

// .ams.device.grpc.GetNetworkInterfacesRequest get_network_interfaces = 5;
inline bool ServerMessage::_internal_has_get_network_interfaces() const {
  return payload_case() == kGetNetworkInterfaces;
}
inline bool ServerMessage::has_get_network_interfaces() const {
  return _internal_has_get_network_interfaces();
}
inline void ServerMessage::set_has_get_network_interfaces() {
  _impl_._oneof_case_[0] = kGetNetworkInterfaces;
}
inline void ServerMessage::clear_get_network_interfaces() {
  if (_internal_has_get_network_interfaces()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_network_interfaces_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetNetworkInterfacesRequest* ServerMessage::release_get_network_interfaces() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_network_interfaces)
  if (_internal_has_get_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::GetNetworkInterfacesRequest* temp = _impl_.payload_.get_network_interfaces_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetNetworkInterfacesRequest& ServerMessage::_internal_get_network_interfaces() const {
  return _internal_has_get_network_interfaces()
      ? *_impl_.payload_.get_network_interfaces_
      : reinterpret_cast< ::ams::device::grpc::GetNetworkInterfacesRequest&>(::ams::device::grpc::_GetNetworkInterfacesRequest_default_instance_);
}
inline const ::ams::device::grpc::GetNetworkInterfacesRequest& ServerMessage::get_network_interfaces() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_network_interfaces)
  return _internal_get_network_interfaces();
}
inline ::ams::device::grpc::GetNetworkInterfacesRequest* ServerMessage::unsafe_arena_release_get_network_interfaces() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_network_interfaces)
  if (_internal_has_get_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::GetNetworkInterfacesRequest* temp = _impl_.payload_.get_network_interfaces_;
    _impl_.payload_.get_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_network_interfaces(::ams::device::grpc::GetNetworkInterfacesRequest* get_network_interfaces) {
  clear_payload();
  if (get_network_interfaces) {
    set_has_get_network_interfaces();
    _impl_.payload_.get_network_interfaces_ = get_network_interfaces;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_network_interfaces)
}
inline ::ams::device::grpc::GetNetworkInterfacesRequest* ServerMessage::_internal_mutable_get_network_interfaces() {
  if (!_internal_has_get_network_interfaces()) {
    clear_payload();
    set_has_get_network_interfaces();
    _impl_.payload_.get_network_interfaces_ = CreateMaybeMessage< ::ams::device::grpc::GetNetworkInterfacesRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_network_interfaces_;
}
inline ::ams::device::grpc::GetNetworkInterfacesRequest* ServerMessage::mutable_get_network_interfaces() {
  ::ams::device::grpc::GetNetworkInterfacesRequest* _msg = _internal_mutable_get_network_interfaces();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_network_interfaces)
  return _msg;
}

// .ams.device.grpc.SetNetworkInterfacesRequest set_network_interfaces = 6;
inline bool ServerMessage::_internal_has_set_network_interfaces() const {
  return payload_case() == kSetNetworkInterfaces;
}
inline bool ServerMessage::has_set_network_interfaces() const {
  return _internal_has_set_network_interfaces();
}
inline void ServerMessage::set_has_set_network_interfaces() {
  _impl_._oneof_case_[0] = kSetNetworkInterfaces;
}
inline void ServerMessage::clear_set_network_interfaces() {
  if (_internal_has_set_network_interfaces()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_network_interfaces_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetNetworkInterfacesRequest* ServerMessage::release_set_network_interfaces() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_network_interfaces)
  if (_internal_has_set_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::SetNetworkInterfacesRequest* temp = _impl_.payload_.set_network_interfaces_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetNetworkInterfacesRequest& ServerMessage::_internal_set_network_interfaces() const {
  return _internal_has_set_network_interfaces()
      ? *_impl_.payload_.set_network_interfaces_
      : reinterpret_cast< ::ams::device::grpc::SetNetworkInterfacesRequest&>(::ams::device::grpc::_SetNetworkInterfacesRequest_default_instance_);
}
inline const ::ams::device::grpc::SetNetworkInterfacesRequest& ServerMessage::set_network_interfaces() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_network_interfaces)
  return _internal_set_network_interfaces();
}
inline ::ams::device::grpc::SetNetworkInterfacesRequest* ServerMessage::unsafe_arena_release_set_network_interfaces() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_network_interfaces)
  if (_internal_has_set_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::SetNetworkInterfacesRequest* temp = _impl_.payload_.set_network_interfaces_;
    _impl_.payload_.set_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_network_interfaces(::ams::device::grpc::SetNetworkInterfacesRequest* set_network_interfaces) {
  clear_payload();
  if (set_network_interfaces) {
    set_has_set_network_interfaces();
    _impl_.payload_.set_network_interfaces_ = set_network_interfaces;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_network_interfaces)
}
inline ::ams::device::grpc::SetNetworkInterfacesRequest* ServerMessage::_internal_mutable_set_network_interfaces() {
  if (!_internal_has_set_network_interfaces()) {
    clear_payload();
    set_has_set_network_interfaces();
    _impl_.payload_.set_network_interfaces_ = CreateMaybeMessage< ::ams::device::grpc::SetNetworkInterfacesRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_network_interfaces_;
}
inline ::ams::device::grpc::SetNetworkInterfacesRequest* ServerMessage::mutable_set_network_interfaces() {
  ::ams::device::grpc::SetNetworkInterfacesRequest* _msg = _internal_mutable_set_network_interfaces();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_network_interfaces)
  return _msg;
}

// .ams.device.grpc.GetSipInformationRequest get_sip_information = 7;
inline bool ServerMessage::_internal_has_get_sip_information() const {
  return payload_case() == kGetSipInformation;
}
inline bool ServerMessage::has_get_sip_information() const {
  return _internal_has_get_sip_information();
}
inline void ServerMessage::set_has_get_sip_information() {
  _impl_._oneof_case_[0] = kGetSipInformation;
}
inline void ServerMessage::clear_get_sip_information() {
  if (_internal_has_get_sip_information()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_sip_information_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSipInformationRequest* ServerMessage::release_get_sip_information() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_sip_information)
  if (_internal_has_get_sip_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetSipInformationRequest* temp = _impl_.payload_.get_sip_information_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_sip_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSipInformationRequest& ServerMessage::_internal_get_sip_information() const {
  return _internal_has_get_sip_information()
      ? *_impl_.payload_.get_sip_information_
      : reinterpret_cast< ::ams::device::grpc::GetSipInformationRequest&>(::ams::device::grpc::_GetSipInformationRequest_default_instance_);
}
inline const ::ams::device::grpc::GetSipInformationRequest& ServerMessage::get_sip_information() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_sip_information)
  return _internal_get_sip_information();
}
inline ::ams::device::grpc::GetSipInformationRequest* ServerMessage::unsafe_arena_release_get_sip_information() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_sip_information)
  if (_internal_has_get_sip_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetSipInformationRequest* temp = _impl_.payload_.get_sip_information_;
    _impl_.payload_.get_sip_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_sip_information(::ams::device::grpc::GetSipInformationRequest* get_sip_information) {
  clear_payload();
  if (get_sip_information) {
    set_has_get_sip_information();
    _impl_.payload_.get_sip_information_ = get_sip_information;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_sip_information)
}
inline ::ams::device::grpc::GetSipInformationRequest* ServerMessage::_internal_mutable_get_sip_information() {
  if (!_internal_has_get_sip_information()) {
    clear_payload();
    set_has_get_sip_information();
    _impl_.payload_.get_sip_information_ = CreateMaybeMessage< ::ams::device::grpc::GetSipInformationRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_sip_information_;
}
inline ::ams::device::grpc::GetSipInformationRequest* ServerMessage::mutable_get_sip_information() {
  ::ams::device::grpc::GetSipInformationRequest* _msg = _internal_mutable_get_sip_information();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_sip_information)
  return _msg;
}

// .ams.device.grpc.AddSipUserRequest add_sip_user = 8;
inline bool ServerMessage::_internal_has_add_sip_user() const {
  return payload_case() == kAddSipUser;
}
inline bool ServerMessage::has_add_sip_user() const {
  return _internal_has_add_sip_user();
}
inline void ServerMessage::set_has_add_sip_user() {
  _impl_._oneof_case_[0] = kAddSipUser;
}
inline void ServerMessage::clear_add_sip_user() {
  if (_internal_has_add_sip_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.add_sip_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::AddSipUserRequest* ServerMessage::release_add_sip_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.add_sip_user)
  if (_internal_has_add_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::AddSipUserRequest* temp = _impl_.payload_.add_sip_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::AddSipUserRequest& ServerMessage::_internal_add_sip_user() const {
  return _internal_has_add_sip_user()
      ? *_impl_.payload_.add_sip_user_
      : reinterpret_cast< ::ams::device::grpc::AddSipUserRequest&>(::ams::device::grpc::_AddSipUserRequest_default_instance_);
}
inline const ::ams::device::grpc::AddSipUserRequest& ServerMessage::add_sip_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.add_sip_user)
  return _internal_add_sip_user();
}
inline ::ams::device::grpc::AddSipUserRequest* ServerMessage::unsafe_arena_release_add_sip_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.add_sip_user)
  if (_internal_has_add_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::AddSipUserRequest* temp = _impl_.payload_.add_sip_user_;
    _impl_.payload_.add_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_add_sip_user(::ams::device::grpc::AddSipUserRequest* add_sip_user) {
  clear_payload();
  if (add_sip_user) {
    set_has_add_sip_user();
    _impl_.payload_.add_sip_user_ = add_sip_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.add_sip_user)
}
inline ::ams::device::grpc::AddSipUserRequest* ServerMessage::_internal_mutable_add_sip_user() {
  if (!_internal_has_add_sip_user()) {
    clear_payload();
    set_has_add_sip_user();
    _impl_.payload_.add_sip_user_ = CreateMaybeMessage< ::ams::device::grpc::AddSipUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.add_sip_user_;
}
inline ::ams::device::grpc::AddSipUserRequest* ServerMessage::mutable_add_sip_user() {
  ::ams::device::grpc::AddSipUserRequest* _msg = _internal_mutable_add_sip_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.add_sip_user)
  return _msg;
}

// .ams.device.grpc.DeleteSipUserRequest delete_sip_user = 9;
inline bool ServerMessage::_internal_has_delete_sip_user() const {
  return payload_case() == kDeleteSipUser;
}
inline bool ServerMessage::has_delete_sip_user() const {
  return _internal_has_delete_sip_user();
}
inline void ServerMessage::set_has_delete_sip_user() {
  _impl_._oneof_case_[0] = kDeleteSipUser;
}
inline void ServerMessage::clear_delete_sip_user() {
  if (_internal_has_delete_sip_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.delete_sip_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::DeleteSipUserRequest* ServerMessage::release_delete_sip_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.delete_sip_user)
  if (_internal_has_delete_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteSipUserRequest* temp = _impl_.payload_.delete_sip_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::DeleteSipUserRequest& ServerMessage::_internal_delete_sip_user() const {
  return _internal_has_delete_sip_user()
      ? *_impl_.payload_.delete_sip_user_
      : reinterpret_cast< ::ams::device::grpc::DeleteSipUserRequest&>(::ams::device::grpc::_DeleteSipUserRequest_default_instance_);
}
inline const ::ams::device::grpc::DeleteSipUserRequest& ServerMessage::delete_sip_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.delete_sip_user)
  return _internal_delete_sip_user();
}
inline ::ams::device::grpc::DeleteSipUserRequest* ServerMessage::unsafe_arena_release_delete_sip_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.delete_sip_user)
  if (_internal_has_delete_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteSipUserRequest* temp = _impl_.payload_.delete_sip_user_;
    _impl_.payload_.delete_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_delete_sip_user(::ams::device::grpc::DeleteSipUserRequest* delete_sip_user) {
  clear_payload();
  if (delete_sip_user) {
    set_has_delete_sip_user();
    _impl_.payload_.delete_sip_user_ = delete_sip_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.delete_sip_user)
}
inline ::ams::device::grpc::DeleteSipUserRequest* ServerMessage::_internal_mutable_delete_sip_user() {
  if (!_internal_has_delete_sip_user()) {
    clear_payload();
    set_has_delete_sip_user();
    _impl_.payload_.delete_sip_user_ = CreateMaybeMessage< ::ams::device::grpc::DeleteSipUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.delete_sip_user_;
}
inline ::ams::device::grpc::DeleteSipUserRequest* ServerMessage::mutable_delete_sip_user() {
  ::ams::device::grpc::DeleteSipUserRequest* _msg = _internal_mutable_delete_sip_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.delete_sip_user)
  return _msg;
}

// .ams.device.grpc.SetSipUserRequest set_sip_user = 10;
inline bool ServerMessage::_internal_has_set_sip_user() const {
  return payload_case() == kSetSipUser;
}
inline bool ServerMessage::has_set_sip_user() const {
  return _internal_has_set_sip_user();
}
inline void ServerMessage::set_has_set_sip_user() {
  _impl_._oneof_case_[0] = kSetSipUser;
}
inline void ServerMessage::clear_set_sip_user() {
  if (_internal_has_set_sip_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_sip_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetSipUserRequest* ServerMessage::release_set_sip_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_sip_user)
  if (_internal_has_set_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::SetSipUserRequest* temp = _impl_.payload_.set_sip_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetSipUserRequest& ServerMessage::_internal_set_sip_user() const {
  return _internal_has_set_sip_user()
      ? *_impl_.payload_.set_sip_user_
      : reinterpret_cast< ::ams::device::grpc::SetSipUserRequest&>(::ams::device::grpc::_SetSipUserRequest_default_instance_);
}
inline const ::ams::device::grpc::SetSipUserRequest& ServerMessage::set_sip_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_sip_user)
  return _internal_set_sip_user();
}
inline ::ams::device::grpc::SetSipUserRequest* ServerMessage::unsafe_arena_release_set_sip_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_sip_user)
  if (_internal_has_set_sip_user()) {
    clear_has_payload();
    ::ams::device::grpc::SetSipUserRequest* temp = _impl_.payload_.set_sip_user_;
    _impl_.payload_.set_sip_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_sip_user(::ams::device::grpc::SetSipUserRequest* set_sip_user) {
  clear_payload();
  if (set_sip_user) {
    set_has_set_sip_user();
    _impl_.payload_.set_sip_user_ = set_sip_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_sip_user)
}
inline ::ams::device::grpc::SetSipUserRequest* ServerMessage::_internal_mutable_set_sip_user() {
  if (!_internal_has_set_sip_user()) {
    clear_payload();
    set_has_set_sip_user();
    _impl_.payload_.set_sip_user_ = CreateMaybeMessage< ::ams::device::grpc::SetSipUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_sip_user_;
}
inline ::ams::device::grpc::SetSipUserRequest* ServerMessage::mutable_set_sip_user() {
  ::ams::device::grpc::SetSipUserRequest* _msg = _internal_mutable_set_sip_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_sip_user)
  return _msg;
}

// .ams.device.grpc.GetOnvifInformationRequest get_onvif_information = 11;
inline bool ServerMessage::_internal_has_get_onvif_information() const {
  return payload_case() == kGetOnvifInformation;
}
inline bool ServerMessage::has_get_onvif_information() const {
  return _internal_has_get_onvif_information();
}
inline void ServerMessage::set_has_get_onvif_information() {
  _impl_._oneof_case_[0] = kGetOnvifInformation;
}
inline void ServerMessage::clear_get_onvif_information() {
  if (_internal_has_get_onvif_information()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_onvif_information_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetOnvifInformationRequest* ServerMessage::release_get_onvif_information() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_onvif_information)
  if (_internal_has_get_onvif_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetOnvifInformationRequest* temp = _impl_.payload_.get_onvif_information_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_onvif_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetOnvifInformationRequest& ServerMessage::_internal_get_onvif_information() const {
  return _internal_has_get_onvif_information()
      ? *_impl_.payload_.get_onvif_information_
      : reinterpret_cast< ::ams::device::grpc::GetOnvifInformationRequest&>(::ams::device::grpc::_GetOnvifInformationRequest_default_instance_);
}
inline const ::ams::device::grpc::GetOnvifInformationRequest& ServerMessage::get_onvif_information() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_onvif_information)
  return _internal_get_onvif_information();
}
inline ::ams::device::grpc::GetOnvifInformationRequest* ServerMessage::unsafe_arena_release_get_onvif_information() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_onvif_information)
  if (_internal_has_get_onvif_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetOnvifInformationRequest* temp = _impl_.payload_.get_onvif_information_;
    _impl_.payload_.get_onvif_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_onvif_information(::ams::device::grpc::GetOnvifInformationRequest* get_onvif_information) {
  clear_payload();
  if (get_onvif_information) {
    set_has_get_onvif_information();
    _impl_.payload_.get_onvif_information_ = get_onvif_information;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_onvif_information)
}
inline ::ams::device::grpc::GetOnvifInformationRequest* ServerMessage::_internal_mutable_get_onvif_information() {
  if (!_internal_has_get_onvif_information()) {
    clear_payload();
    set_has_get_onvif_information();
    _impl_.payload_.get_onvif_information_ = CreateMaybeMessage< ::ams::device::grpc::GetOnvifInformationRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_onvif_information_;
}
inline ::ams::device::grpc::GetOnvifInformationRequest* ServerMessage::mutable_get_onvif_information() {
  ::ams::device::grpc::GetOnvifInformationRequest* _msg = _internal_mutable_get_onvif_information();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_onvif_information)
  return _msg;
}

// .ams.device.grpc.AddOnvifUserRequest add_onvif_user = 12;
inline bool ServerMessage::_internal_has_add_onvif_user() const {
  return payload_case() == kAddOnvifUser;
}
inline bool ServerMessage::has_add_onvif_user() const {
  return _internal_has_add_onvif_user();
}
inline void ServerMessage::set_has_add_onvif_user() {
  _impl_._oneof_case_[0] = kAddOnvifUser;
}
inline void ServerMessage::clear_add_onvif_user() {
  if (_internal_has_add_onvif_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.add_onvif_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::AddOnvifUserRequest* ServerMessage::release_add_onvif_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.add_onvif_user)
  if (_internal_has_add_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::AddOnvifUserRequest* temp = _impl_.payload_.add_onvif_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::AddOnvifUserRequest& ServerMessage::_internal_add_onvif_user() const {
  return _internal_has_add_onvif_user()
      ? *_impl_.payload_.add_onvif_user_
      : reinterpret_cast< ::ams::device::grpc::AddOnvifUserRequest&>(::ams::device::grpc::_AddOnvifUserRequest_default_instance_);
}
inline const ::ams::device::grpc::AddOnvifUserRequest& ServerMessage::add_onvif_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.add_onvif_user)
  return _internal_add_onvif_user();
}
inline ::ams::device::grpc::AddOnvifUserRequest* ServerMessage::unsafe_arena_release_add_onvif_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.add_onvif_user)
  if (_internal_has_add_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::AddOnvifUserRequest* temp = _impl_.payload_.add_onvif_user_;
    _impl_.payload_.add_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_add_onvif_user(::ams::device::grpc::AddOnvifUserRequest* add_onvif_user) {
  clear_payload();
  if (add_onvif_user) {
    set_has_add_onvif_user();
    _impl_.payload_.add_onvif_user_ = add_onvif_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.add_onvif_user)
}
inline ::ams::device::grpc::AddOnvifUserRequest* ServerMessage::_internal_mutable_add_onvif_user() {
  if (!_internal_has_add_onvif_user()) {
    clear_payload();
    set_has_add_onvif_user();
    _impl_.payload_.add_onvif_user_ = CreateMaybeMessage< ::ams::device::grpc::AddOnvifUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.add_onvif_user_;
}
inline ::ams::device::grpc::AddOnvifUserRequest* ServerMessage::mutable_add_onvif_user() {
  ::ams::device::grpc::AddOnvifUserRequest* _msg = _internal_mutable_add_onvif_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.add_onvif_user)
  return _msg;
}

// .ams.device.grpc.DeleteOnvifUserRequest delete_onvif_user = 13;
inline bool ServerMessage::_internal_has_delete_onvif_user() const {
  return payload_case() == kDeleteOnvifUser;
}
inline bool ServerMessage::has_delete_onvif_user() const {
  return _internal_has_delete_onvif_user();
}
inline void ServerMessage::set_has_delete_onvif_user() {
  _impl_._oneof_case_[0] = kDeleteOnvifUser;
}
inline void ServerMessage::clear_delete_onvif_user() {
  if (_internal_has_delete_onvif_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.delete_onvif_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::DeleteOnvifUserRequest* ServerMessage::release_delete_onvif_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.delete_onvif_user)
  if (_internal_has_delete_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteOnvifUserRequest* temp = _impl_.payload_.delete_onvif_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::DeleteOnvifUserRequest& ServerMessage::_internal_delete_onvif_user() const {
  return _internal_has_delete_onvif_user()
      ? *_impl_.payload_.delete_onvif_user_
      : reinterpret_cast< ::ams::device::grpc::DeleteOnvifUserRequest&>(::ams::device::grpc::_DeleteOnvifUserRequest_default_instance_);
}
inline const ::ams::device::grpc::DeleteOnvifUserRequest& ServerMessage::delete_onvif_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.delete_onvif_user)
  return _internal_delete_onvif_user();
}
inline ::ams::device::grpc::DeleteOnvifUserRequest* ServerMessage::unsafe_arena_release_delete_onvif_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.delete_onvif_user)
  if (_internal_has_delete_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteOnvifUserRequest* temp = _impl_.payload_.delete_onvif_user_;
    _impl_.payload_.delete_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_delete_onvif_user(::ams::device::grpc::DeleteOnvifUserRequest* delete_onvif_user) {
  clear_payload();
  if (delete_onvif_user) {
    set_has_delete_onvif_user();
    _impl_.payload_.delete_onvif_user_ = delete_onvif_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.delete_onvif_user)
}
inline ::ams::device::grpc::DeleteOnvifUserRequest* ServerMessage::_internal_mutable_delete_onvif_user() {
  if (!_internal_has_delete_onvif_user()) {
    clear_payload();
    set_has_delete_onvif_user();
    _impl_.payload_.delete_onvif_user_ = CreateMaybeMessage< ::ams::device::grpc::DeleteOnvifUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.delete_onvif_user_;
}
inline ::ams::device::grpc::DeleteOnvifUserRequest* ServerMessage::mutable_delete_onvif_user() {
  ::ams::device::grpc::DeleteOnvifUserRequest* _msg = _internal_mutable_delete_onvif_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.delete_onvif_user)
  return _msg;
}

// .ams.device.grpc.SetOnvifUserRequest set_onvif_user = 14;
inline bool ServerMessage::_internal_has_set_onvif_user() const {
  return payload_case() == kSetOnvifUser;
}
inline bool ServerMessage::has_set_onvif_user() const {
  return _internal_has_set_onvif_user();
}
inline void ServerMessage::set_has_set_onvif_user() {
  _impl_._oneof_case_[0] = kSetOnvifUser;
}
inline void ServerMessage::clear_set_onvif_user() {
  if (_internal_has_set_onvif_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_onvif_user_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetOnvifUserRequest* ServerMessage::release_set_onvif_user() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_onvif_user)
  if (_internal_has_set_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::SetOnvifUserRequest* temp = _impl_.payload_.set_onvif_user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetOnvifUserRequest& ServerMessage::_internal_set_onvif_user() const {
  return _internal_has_set_onvif_user()
      ? *_impl_.payload_.set_onvif_user_
      : reinterpret_cast< ::ams::device::grpc::SetOnvifUserRequest&>(::ams::device::grpc::_SetOnvifUserRequest_default_instance_);
}
inline const ::ams::device::grpc::SetOnvifUserRequest& ServerMessage::set_onvif_user() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_onvif_user)
  return _internal_set_onvif_user();
}
inline ::ams::device::grpc::SetOnvifUserRequest* ServerMessage::unsafe_arena_release_set_onvif_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_onvif_user)
  if (_internal_has_set_onvif_user()) {
    clear_has_payload();
    ::ams::device::grpc::SetOnvifUserRequest* temp = _impl_.payload_.set_onvif_user_;
    _impl_.payload_.set_onvif_user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_onvif_user(::ams::device::grpc::SetOnvifUserRequest* set_onvif_user) {
  clear_payload();
  if (set_onvif_user) {
    set_has_set_onvif_user();
    _impl_.payload_.set_onvif_user_ = set_onvif_user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_onvif_user)
}
inline ::ams::device::grpc::SetOnvifUserRequest* ServerMessage::_internal_mutable_set_onvif_user() {
  if (!_internal_has_set_onvif_user()) {
    clear_payload();
    set_has_set_onvif_user();
    _impl_.payload_.set_onvif_user_ = CreateMaybeMessage< ::ams::device::grpc::SetOnvifUserRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_onvif_user_;
}
inline ::ams::device::grpc::SetOnvifUserRequest* ServerMessage::mutable_set_onvif_user() {
  ::ams::device::grpc::SetOnvifUserRequest* _msg = _internal_mutable_set_onvif_user();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_onvif_user)
  return _msg;
}

// .ams.device.grpc.GetPaAddressRequest get_pa_address = 15;
inline bool ServerMessage::_internal_has_get_pa_address() const {
  return payload_case() == kGetPaAddress;
}
inline bool ServerMessage::has_get_pa_address() const {
  return _internal_has_get_pa_address();
}
inline void ServerMessage::set_has_get_pa_address() {
  _impl_._oneof_case_[0] = kGetPaAddress;
}
inline void ServerMessage::clear_get_pa_address() {
  if (_internal_has_get_pa_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_pa_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetPaAddressRequest* ServerMessage::release_get_pa_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_pa_address)
  if (_internal_has_get_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetPaAddressRequest* temp = _impl_.payload_.get_pa_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetPaAddressRequest& ServerMessage::_internal_get_pa_address() const {
  return _internal_has_get_pa_address()
      ? *_impl_.payload_.get_pa_address_
      : reinterpret_cast< ::ams::device::grpc::GetPaAddressRequest&>(::ams::device::grpc::_GetPaAddressRequest_default_instance_);
}
inline const ::ams::device::grpc::GetPaAddressRequest& ServerMessage::get_pa_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_pa_address)
  return _internal_get_pa_address();
}
inline ::ams::device::grpc::GetPaAddressRequest* ServerMessage::unsafe_arena_release_get_pa_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_pa_address)
  if (_internal_has_get_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetPaAddressRequest* temp = _impl_.payload_.get_pa_address_;
    _impl_.payload_.get_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_pa_address(::ams::device::grpc::GetPaAddressRequest* get_pa_address) {
  clear_payload();
  if (get_pa_address) {
    set_has_get_pa_address();
    _impl_.payload_.get_pa_address_ = get_pa_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_pa_address)
}
inline ::ams::device::grpc::GetPaAddressRequest* ServerMessage::_internal_mutable_get_pa_address() {
  if (!_internal_has_get_pa_address()) {
    clear_payload();
    set_has_get_pa_address();
    _impl_.payload_.get_pa_address_ = CreateMaybeMessage< ::ams::device::grpc::GetPaAddressRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_pa_address_;
}
inline ::ams::device::grpc::GetPaAddressRequest* ServerMessage::mutable_get_pa_address() {
  ::ams::device::grpc::GetPaAddressRequest* _msg = _internal_mutable_get_pa_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_pa_address)
  return _msg;
}

// .ams.device.grpc.SetPaAddressRequest set_pa_address = 16;
inline bool ServerMessage::_internal_has_set_pa_address() const {
  return payload_case() == kSetPaAddress;
}
inline bool ServerMessage::has_set_pa_address() const {
  return _internal_has_set_pa_address();
}
inline void ServerMessage::set_has_set_pa_address() {
  _impl_._oneof_case_[0] = kSetPaAddress;
}
inline void ServerMessage::clear_set_pa_address() {
  if (_internal_has_set_pa_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_pa_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetPaAddressRequest* ServerMessage::release_set_pa_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_pa_address)
  if (_internal_has_set_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::SetPaAddressRequest* temp = _impl_.payload_.set_pa_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetPaAddressRequest& ServerMessage::_internal_set_pa_address() const {
  return _internal_has_set_pa_address()
      ? *_impl_.payload_.set_pa_address_
      : reinterpret_cast< ::ams::device::grpc::SetPaAddressRequest&>(::ams::device::grpc::_SetPaAddressRequest_default_instance_);
}
inline const ::ams::device::grpc::SetPaAddressRequest& ServerMessage::set_pa_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_pa_address)
  return _internal_set_pa_address();
}
inline ::ams::device::grpc::SetPaAddressRequest* ServerMessage::unsafe_arena_release_set_pa_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_pa_address)
  if (_internal_has_set_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::SetPaAddressRequest* temp = _impl_.payload_.set_pa_address_;
    _impl_.payload_.set_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_pa_address(::ams::device::grpc::SetPaAddressRequest* set_pa_address) {
  clear_payload();
  if (set_pa_address) {
    set_has_set_pa_address();
    _impl_.payload_.set_pa_address_ = set_pa_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_pa_address)
}
inline ::ams::device::grpc::SetPaAddressRequest* ServerMessage::_internal_mutable_set_pa_address() {
  if (!_internal_has_set_pa_address()) {
    clear_payload();
    set_has_set_pa_address();
    _impl_.payload_.set_pa_address_ = CreateMaybeMessage< ::ams::device::grpc::SetPaAddressRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_pa_address_;
}
inline ::ams::device::grpc::SetPaAddressRequest* ServerMessage::mutable_set_pa_address() {
  ::ams::device::grpc::SetPaAddressRequest* _msg = _internal_mutable_set_pa_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_pa_address)
  return _msg;
}

// .ams.device.grpc.GetSnapcastAddressRequest get_snapcast_address = 17;
inline bool ServerMessage::_internal_has_get_snapcast_address() const {
  return payload_case() == kGetSnapcastAddress;
}
inline bool ServerMessage::has_get_snapcast_address() const {
  return _internal_has_get_snapcast_address();
}
inline void ServerMessage::set_has_get_snapcast_address() {
  _impl_._oneof_case_[0] = kGetSnapcastAddress;
}
inline void ServerMessage::clear_get_snapcast_address() {
  if (_internal_has_get_snapcast_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_snapcast_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSnapcastAddressRequest* ServerMessage::release_get_snapcast_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_snapcast_address)
  if (_internal_has_get_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetSnapcastAddressRequest* temp = _impl_.payload_.get_snapcast_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSnapcastAddressRequest& ServerMessage::_internal_get_snapcast_address() const {
  return _internal_has_get_snapcast_address()
      ? *_impl_.payload_.get_snapcast_address_
      : reinterpret_cast< ::ams::device::grpc::GetSnapcastAddressRequest&>(::ams::device::grpc::_GetSnapcastAddressRequest_default_instance_);
}
inline const ::ams::device::grpc::GetSnapcastAddressRequest& ServerMessage::get_snapcast_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_snapcast_address)
  return _internal_get_snapcast_address();
}
inline ::ams::device::grpc::GetSnapcastAddressRequest* ServerMessage::unsafe_arena_release_get_snapcast_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_snapcast_address)
  if (_internal_has_get_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetSnapcastAddressRequest* temp = _impl_.payload_.get_snapcast_address_;
    _impl_.payload_.get_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_snapcast_address(::ams::device::grpc::GetSnapcastAddressRequest* get_snapcast_address) {
  clear_payload();
  if (get_snapcast_address) {
    set_has_get_snapcast_address();
    _impl_.payload_.get_snapcast_address_ = get_snapcast_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_snapcast_address)
}
inline ::ams::device::grpc::GetSnapcastAddressRequest* ServerMessage::_internal_mutable_get_snapcast_address() {
  if (!_internal_has_get_snapcast_address()) {
    clear_payload();
    set_has_get_snapcast_address();
    _impl_.payload_.get_snapcast_address_ = CreateMaybeMessage< ::ams::device::grpc::GetSnapcastAddressRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_snapcast_address_;
}
inline ::ams::device::grpc::GetSnapcastAddressRequest* ServerMessage::mutable_get_snapcast_address() {
  ::ams::device::grpc::GetSnapcastAddressRequest* _msg = _internal_mutable_get_snapcast_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_snapcast_address)
  return _msg;
}

// .ams.device.grpc.SetSnapcastAddressRequest set_snapcast_address = 18;
inline bool ServerMessage::_internal_has_set_snapcast_address() const {
  return payload_case() == kSetSnapcastAddress;
}
inline bool ServerMessage::has_set_snapcast_address() const {
  return _internal_has_set_snapcast_address();
}
inline void ServerMessage::set_has_set_snapcast_address() {
  _impl_._oneof_case_[0] = kSetSnapcastAddress;
}
inline void ServerMessage::clear_set_snapcast_address() {
  if (_internal_has_set_snapcast_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_snapcast_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetSnapcastAddressRequest* ServerMessage::release_set_snapcast_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_snapcast_address)
  if (_internal_has_set_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::SetSnapcastAddressRequest* temp = _impl_.payload_.set_snapcast_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetSnapcastAddressRequest& ServerMessage::_internal_set_snapcast_address() const {
  return _internal_has_set_snapcast_address()
      ? *_impl_.payload_.set_snapcast_address_
      : reinterpret_cast< ::ams::device::grpc::SetSnapcastAddressRequest&>(::ams::device::grpc::_SetSnapcastAddressRequest_default_instance_);
}
inline const ::ams::device::grpc::SetSnapcastAddressRequest& ServerMessage::set_snapcast_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_snapcast_address)
  return _internal_set_snapcast_address();
}
inline ::ams::device::grpc::SetSnapcastAddressRequest* ServerMessage::unsafe_arena_release_set_snapcast_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_snapcast_address)
  if (_internal_has_set_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::SetSnapcastAddressRequest* temp = _impl_.payload_.set_snapcast_address_;
    _impl_.payload_.set_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_snapcast_address(::ams::device::grpc::SetSnapcastAddressRequest* set_snapcast_address) {
  clear_payload();
  if (set_snapcast_address) {
    set_has_set_snapcast_address();
    _impl_.payload_.set_snapcast_address_ = set_snapcast_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_snapcast_address)
}
inline ::ams::device::grpc::SetSnapcastAddressRequest* ServerMessage::_internal_mutable_set_snapcast_address() {
  if (!_internal_has_set_snapcast_address()) {
    clear_payload();
    set_has_set_snapcast_address();
    _impl_.payload_.set_snapcast_address_ = CreateMaybeMessage< ::ams::device::grpc::SetSnapcastAddressRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_snapcast_address_;
}
inline ::ams::device::grpc::SetSnapcastAddressRequest* ServerMessage::mutable_set_snapcast_address() {
  ::ams::device::grpc::SetSnapcastAddressRequest* _msg = _internal_mutable_set_snapcast_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_snapcast_address)
  return _msg;
}

// .ams.device.grpc.GetVolumeRequest get_volume = 19;
inline bool ServerMessage::_internal_has_get_volume() const {
  return payload_case() == kGetVolume;
}
inline bool ServerMessage::has_get_volume() const {
  return _internal_has_get_volume();
}
inline void ServerMessage::set_has_get_volume() {
  _impl_._oneof_case_[0] = kGetVolume;
}
inline void ServerMessage::clear_get_volume() {
  if (_internal_has_get_volume()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_volume_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetVolumeRequest* ServerMessage::release_get_volume() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_volume)
  if (_internal_has_get_volume()) {
    clear_has_payload();
    ::ams::device::grpc::GetVolumeRequest* temp = _impl_.payload_.get_volume_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetVolumeRequest& ServerMessage::_internal_get_volume() const {
  return _internal_has_get_volume()
      ? *_impl_.payload_.get_volume_
      : reinterpret_cast< ::ams::device::grpc::GetVolumeRequest&>(::ams::device::grpc::_GetVolumeRequest_default_instance_);
}
inline const ::ams::device::grpc::GetVolumeRequest& ServerMessage::get_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_volume)
  return _internal_get_volume();
}
inline ::ams::device::grpc::GetVolumeRequest* ServerMessage::unsafe_arena_release_get_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_volume)
  if (_internal_has_get_volume()) {
    clear_has_payload();
    ::ams::device::grpc::GetVolumeRequest* temp = _impl_.payload_.get_volume_;
    _impl_.payload_.get_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_volume(::ams::device::grpc::GetVolumeRequest* get_volume) {
  clear_payload();
  if (get_volume) {
    set_has_get_volume();
    _impl_.payload_.get_volume_ = get_volume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_volume)
}
inline ::ams::device::grpc::GetVolumeRequest* ServerMessage::_internal_mutable_get_volume() {
  if (!_internal_has_get_volume()) {
    clear_payload();
    set_has_get_volume();
    _impl_.payload_.get_volume_ = CreateMaybeMessage< ::ams::device::grpc::GetVolumeRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_volume_;
}
inline ::ams::device::grpc::GetVolumeRequest* ServerMessage::mutable_get_volume() {
  ::ams::device::grpc::GetVolumeRequest* _msg = _internal_mutable_get_volume();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_volume)
  return _msg;
}

// .ams.device.grpc.SetVolumeRequest set_volume = 20;
inline bool ServerMessage::_internal_has_set_volume() const {
  return payload_case() == kSetVolume;
}
inline bool ServerMessage::has_set_volume() const {
  return _internal_has_set_volume();
}
inline void ServerMessage::set_has_set_volume() {
  _impl_._oneof_case_[0] = kSetVolume;
}
inline void ServerMessage::clear_set_volume() {
  if (_internal_has_set_volume()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_volume_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetVolumeRequest* ServerMessage::release_set_volume() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_volume)
  if (_internal_has_set_volume()) {
    clear_has_payload();
    ::ams::device::grpc::SetVolumeRequest* temp = _impl_.payload_.set_volume_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetVolumeRequest& ServerMessage::_internal_set_volume() const {
  return _internal_has_set_volume()
      ? *_impl_.payload_.set_volume_
      : reinterpret_cast< ::ams::device::grpc::SetVolumeRequest&>(::ams::device::grpc::_SetVolumeRequest_default_instance_);
}
inline const ::ams::device::grpc::SetVolumeRequest& ServerMessage::set_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_volume)
  return _internal_set_volume();
}
inline ::ams::device::grpc::SetVolumeRequest* ServerMessage::unsafe_arena_release_set_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_volume)
  if (_internal_has_set_volume()) {
    clear_has_payload();
    ::ams::device::grpc::SetVolumeRequest* temp = _impl_.payload_.set_volume_;
    _impl_.payload_.set_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_volume(::ams::device::grpc::SetVolumeRequest* set_volume) {
  clear_payload();
  if (set_volume) {
    set_has_set_volume();
    _impl_.payload_.set_volume_ = set_volume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_volume)
}
inline ::ams::device::grpc::SetVolumeRequest* ServerMessage::_internal_mutable_set_volume() {
  if (!_internal_has_set_volume()) {
    clear_payload();
    set_has_set_volume();
    _impl_.payload_.set_volume_ = CreateMaybeMessage< ::ams::device::grpc::SetVolumeRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_volume_;
}
inline ::ams::device::grpc::SetVolumeRequest* ServerMessage::mutable_set_volume() {
  ::ams::device::grpc::SetVolumeRequest* _msg = _internal_mutable_set_volume();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_volume)
  return _msg;
}

// .ams.device.grpc.GetScheduleListRequest get_schedule_list = 21;
inline bool ServerMessage::_internal_has_get_schedule_list() const {
  return payload_case() == kGetScheduleList;
}
inline bool ServerMessage::has_get_schedule_list() const {
  return _internal_has_get_schedule_list();
}
inline void ServerMessage::set_has_get_schedule_list() {
  _impl_._oneof_case_[0] = kGetScheduleList;
}
inline void ServerMessage::clear_get_schedule_list() {
  if (_internal_has_get_schedule_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_schedule_list_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetScheduleListRequest* ServerMessage::release_get_schedule_list() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.get_schedule_list)
  if (_internal_has_get_schedule_list()) {
    clear_has_payload();
    ::ams::device::grpc::GetScheduleListRequest* temp = _impl_.payload_.get_schedule_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_schedule_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetScheduleListRequest& ServerMessage::_internal_get_schedule_list() const {
  return _internal_has_get_schedule_list()
      ? *_impl_.payload_.get_schedule_list_
      : reinterpret_cast< ::ams::device::grpc::GetScheduleListRequest&>(::ams::device::grpc::_GetScheduleListRequest_default_instance_);
}
inline const ::ams::device::grpc::GetScheduleListRequest& ServerMessage::get_schedule_list() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.get_schedule_list)
  return _internal_get_schedule_list();
}
inline ::ams::device::grpc::GetScheduleListRequest* ServerMessage::unsafe_arena_release_get_schedule_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.get_schedule_list)
  if (_internal_has_get_schedule_list()) {
    clear_has_payload();
    ::ams::device::grpc::GetScheduleListRequest* temp = _impl_.payload_.get_schedule_list_;
    _impl_.payload_.get_schedule_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_get_schedule_list(::ams::device::grpc::GetScheduleListRequest* get_schedule_list) {
  clear_payload();
  if (get_schedule_list) {
    set_has_get_schedule_list();
    _impl_.payload_.get_schedule_list_ = get_schedule_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.get_schedule_list)
}
inline ::ams::device::grpc::GetScheduleListRequest* ServerMessage::_internal_mutable_get_schedule_list() {
  if (!_internal_has_get_schedule_list()) {
    clear_payload();
    set_has_get_schedule_list();
    _impl_.payload_.get_schedule_list_ = CreateMaybeMessage< ::ams::device::grpc::GetScheduleListRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_schedule_list_;
}
inline ::ams::device::grpc::GetScheduleListRequest* ServerMessage::mutable_get_schedule_list() {
  ::ams::device::grpc::GetScheduleListRequest* _msg = _internal_mutable_get_schedule_list();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.get_schedule_list)
  return _msg;
}

// .ams.device.grpc.AddScheduleRequest add_schedule = 22;
inline bool ServerMessage::_internal_has_add_schedule() const {
  return payload_case() == kAddSchedule;
}
inline bool ServerMessage::has_add_schedule() const {
  return _internal_has_add_schedule();
}
inline void ServerMessage::set_has_add_schedule() {
  _impl_._oneof_case_[0] = kAddSchedule;
}
inline void ServerMessage::clear_add_schedule() {
  if (_internal_has_add_schedule()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.add_schedule_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::AddScheduleRequest* ServerMessage::release_add_schedule() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.add_schedule)
  if (_internal_has_add_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::AddScheduleRequest* temp = _impl_.payload_.add_schedule_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::AddScheduleRequest& ServerMessage::_internal_add_schedule() const {
  return _internal_has_add_schedule()
      ? *_impl_.payload_.add_schedule_
      : reinterpret_cast< ::ams::device::grpc::AddScheduleRequest&>(::ams::device::grpc::_AddScheduleRequest_default_instance_);
}
inline const ::ams::device::grpc::AddScheduleRequest& ServerMessage::add_schedule() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.add_schedule)
  return _internal_add_schedule();
}
inline ::ams::device::grpc::AddScheduleRequest* ServerMessage::unsafe_arena_release_add_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.add_schedule)
  if (_internal_has_add_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::AddScheduleRequest* temp = _impl_.payload_.add_schedule_;
    _impl_.payload_.add_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_add_schedule(::ams::device::grpc::AddScheduleRequest* add_schedule) {
  clear_payload();
  if (add_schedule) {
    set_has_add_schedule();
    _impl_.payload_.add_schedule_ = add_schedule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.add_schedule)
}
inline ::ams::device::grpc::AddScheduleRequest* ServerMessage::_internal_mutable_add_schedule() {
  if (!_internal_has_add_schedule()) {
    clear_payload();
    set_has_add_schedule();
    _impl_.payload_.add_schedule_ = CreateMaybeMessage< ::ams::device::grpc::AddScheduleRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.add_schedule_;
}
inline ::ams::device::grpc::AddScheduleRequest* ServerMessage::mutable_add_schedule() {
  ::ams::device::grpc::AddScheduleRequest* _msg = _internal_mutable_add_schedule();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.add_schedule)
  return _msg;
}

// .ams.device.grpc.DeleteScheduleRequest delete_schedule = 23;
inline bool ServerMessage::_internal_has_delete_schedule() const {
  return payload_case() == kDeleteSchedule;
}
inline bool ServerMessage::has_delete_schedule() const {
  return _internal_has_delete_schedule();
}
inline void ServerMessage::set_has_delete_schedule() {
  _impl_._oneof_case_[0] = kDeleteSchedule;
}
inline void ServerMessage::clear_delete_schedule() {
  if (_internal_has_delete_schedule()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.delete_schedule_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::DeleteScheduleRequest* ServerMessage::release_delete_schedule() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.delete_schedule)
  if (_internal_has_delete_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteScheduleRequest* temp = _impl_.payload_.delete_schedule_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::DeleteScheduleRequest& ServerMessage::_internal_delete_schedule() const {
  return _internal_has_delete_schedule()
      ? *_impl_.payload_.delete_schedule_
      : reinterpret_cast< ::ams::device::grpc::DeleteScheduleRequest&>(::ams::device::grpc::_DeleteScheduleRequest_default_instance_);
}
inline const ::ams::device::grpc::DeleteScheduleRequest& ServerMessage::delete_schedule() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.delete_schedule)
  return _internal_delete_schedule();
}
inline ::ams::device::grpc::DeleteScheduleRequest* ServerMessage::unsafe_arena_release_delete_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.delete_schedule)
  if (_internal_has_delete_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteScheduleRequest* temp = _impl_.payload_.delete_schedule_;
    _impl_.payload_.delete_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_delete_schedule(::ams::device::grpc::DeleteScheduleRequest* delete_schedule) {
  clear_payload();
  if (delete_schedule) {
    set_has_delete_schedule();
    _impl_.payload_.delete_schedule_ = delete_schedule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.delete_schedule)
}
inline ::ams::device::grpc::DeleteScheduleRequest* ServerMessage::_internal_mutable_delete_schedule() {
  if (!_internal_has_delete_schedule()) {
    clear_payload();
    set_has_delete_schedule();
    _impl_.payload_.delete_schedule_ = CreateMaybeMessage< ::ams::device::grpc::DeleteScheduleRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.delete_schedule_;
}
inline ::ams::device::grpc::DeleteScheduleRequest* ServerMessage::mutable_delete_schedule() {
  ::ams::device::grpc::DeleteScheduleRequest* _msg = _internal_mutable_delete_schedule();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.delete_schedule)
  return _msg;
}

// .ams.device.grpc.SetScheduleRequest set_schedule = 24;
inline bool ServerMessage::_internal_has_set_schedule() const {
  return payload_case() == kSetSchedule;
}
inline bool ServerMessage::has_set_schedule() const {
  return _internal_has_set_schedule();
}
inline void ServerMessage::set_has_set_schedule() {
  _impl_._oneof_case_[0] = kSetSchedule;
}
inline void ServerMessage::clear_set_schedule() {
  if (_internal_has_set_schedule()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.set_schedule_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SetScheduleRequest* ServerMessage::release_set_schedule() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.set_schedule)
  if (_internal_has_set_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::SetScheduleRequest* temp = _impl_.payload_.set_schedule_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.set_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SetScheduleRequest& ServerMessage::_internal_set_schedule() const {
  return _internal_has_set_schedule()
      ? *_impl_.payload_.set_schedule_
      : reinterpret_cast< ::ams::device::grpc::SetScheduleRequest&>(::ams::device::grpc::_SetScheduleRequest_default_instance_);
}
inline const ::ams::device::grpc::SetScheduleRequest& ServerMessage::set_schedule() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.set_schedule)
  return _internal_set_schedule();
}
inline ::ams::device::grpc::SetScheduleRequest* ServerMessage::unsafe_arena_release_set_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.set_schedule)
  if (_internal_has_set_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::SetScheduleRequest* temp = _impl_.payload_.set_schedule_;
    _impl_.payload_.set_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_set_schedule(::ams::device::grpc::SetScheduleRequest* set_schedule) {
  clear_payload();
  if (set_schedule) {
    set_has_set_schedule();
    _impl_.payload_.set_schedule_ = set_schedule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.set_schedule)
}
inline ::ams::device::grpc::SetScheduleRequest* ServerMessage::_internal_mutable_set_schedule() {
  if (!_internal_has_set_schedule()) {
    clear_payload();
    set_has_set_schedule();
    _impl_.payload_.set_schedule_ = CreateMaybeMessage< ::ams::device::grpc::SetScheduleRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.set_schedule_;
}
inline ::ams::device::grpc::SetScheduleRequest* ServerMessage::mutable_set_schedule() {
  ::ams::device::grpc::SetScheduleRequest* _msg = _internal_mutable_set_schedule();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.set_schedule)
  return _msg;
}

// .ams.device.grpc.ExceptionScheduleRequest exception_schedule = 25;
inline bool ServerMessage::_internal_has_exception_schedule() const {
  return payload_case() == kExceptionSchedule;
}
inline bool ServerMessage::has_exception_schedule() const {
  return _internal_has_exception_schedule();
}
inline void ServerMessage::set_has_exception_schedule() {
  _impl_._oneof_case_[0] = kExceptionSchedule;
}
inline void ServerMessage::clear_exception_schedule() {
  if (_internal_has_exception_schedule()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.exception_schedule_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::ExceptionScheduleRequest* ServerMessage::release_exception_schedule() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.exception_schedule)
  if (_internal_has_exception_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::ExceptionScheduleRequest* temp = _impl_.payload_.exception_schedule_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.exception_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::ExceptionScheduleRequest& ServerMessage::_internal_exception_schedule() const {
  return _internal_has_exception_schedule()
      ? *_impl_.payload_.exception_schedule_
      : reinterpret_cast< ::ams::device::grpc::ExceptionScheduleRequest&>(::ams::device::grpc::_ExceptionScheduleRequest_default_instance_);
}
inline const ::ams::device::grpc::ExceptionScheduleRequest& ServerMessage::exception_schedule() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.exception_schedule)
  return _internal_exception_schedule();
}
inline ::ams::device::grpc::ExceptionScheduleRequest* ServerMessage::unsafe_arena_release_exception_schedule() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.exception_schedule)
  if (_internal_has_exception_schedule()) {
    clear_has_payload();
    ::ams::device::grpc::ExceptionScheduleRequest* temp = _impl_.payload_.exception_schedule_;
    _impl_.payload_.exception_schedule_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_exception_schedule(::ams::device::grpc::ExceptionScheduleRequest* exception_schedule) {
  clear_payload();
  if (exception_schedule) {
    set_has_exception_schedule();
    _impl_.payload_.exception_schedule_ = exception_schedule;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.exception_schedule)
}
inline ::ams::device::grpc::ExceptionScheduleRequest* ServerMessage::_internal_mutable_exception_schedule() {
  if (!_internal_has_exception_schedule()) {
    clear_payload();
    set_has_exception_schedule();
    _impl_.payload_.exception_schedule_ = CreateMaybeMessage< ::ams::device::grpc::ExceptionScheduleRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.exception_schedule_;
}
inline ::ams::device::grpc::ExceptionScheduleRequest* ServerMessage::mutable_exception_schedule() {
  ::ams::device::grpc::ExceptionScheduleRequest* _msg = _internal_mutable_exception_schedule();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.exception_schedule)
  return _msg;
}

// .ams.device.grpc.StartBroadcastRequest start_broadcast = 26;
inline bool ServerMessage::_internal_has_start_broadcast() const {
  return payload_case() == kStartBroadcast;
}
inline bool ServerMessage::has_start_broadcast() const {
  return _internal_has_start_broadcast();
}
inline void ServerMessage::set_has_start_broadcast() {
  _impl_._oneof_case_[0] = kStartBroadcast;
}
inline void ServerMessage::clear_start_broadcast() {
  if (_internal_has_start_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.start_broadcast_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::StartBroadcastRequest* ServerMessage::release_start_broadcast() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.start_broadcast)
  if (_internal_has_start_broadcast()) {
    clear_has_payload();
    ::ams::device::grpc::StartBroadcastRequest* temp = _impl_.payload_.start_broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.start_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::StartBroadcastRequest& ServerMessage::_internal_start_broadcast() const {
  return _internal_has_start_broadcast()
      ? *_impl_.payload_.start_broadcast_
      : reinterpret_cast< ::ams::device::grpc::StartBroadcastRequest&>(::ams::device::grpc::_StartBroadcastRequest_default_instance_);
}
inline const ::ams::device::grpc::StartBroadcastRequest& ServerMessage::start_broadcast() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.start_broadcast)
  return _internal_start_broadcast();
}
inline ::ams::device::grpc::StartBroadcastRequest* ServerMessage::unsafe_arena_release_start_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.start_broadcast)
  if (_internal_has_start_broadcast()) {
    clear_has_payload();
    ::ams::device::grpc::StartBroadcastRequest* temp = _impl_.payload_.start_broadcast_;
    _impl_.payload_.start_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_start_broadcast(::ams::device::grpc::StartBroadcastRequest* start_broadcast) {
  clear_payload();
  if (start_broadcast) {
    set_has_start_broadcast();
    _impl_.payload_.start_broadcast_ = start_broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.start_broadcast)
}
inline ::ams::device::grpc::StartBroadcastRequest* ServerMessage::_internal_mutable_start_broadcast() {
  if (!_internal_has_start_broadcast()) {
    clear_payload();
    set_has_start_broadcast();
    _impl_.payload_.start_broadcast_ = CreateMaybeMessage< ::ams::device::grpc::StartBroadcastRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.start_broadcast_;
}
inline ::ams::device::grpc::StartBroadcastRequest* ServerMessage::mutable_start_broadcast() {
  ::ams::device::grpc::StartBroadcastRequest* _msg = _internal_mutable_start_broadcast();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.start_broadcast)
  return _msg;
}

// .ams.device.grpc.StopBroadcastRequest stop_broadcast = 27;
inline bool ServerMessage::_internal_has_stop_broadcast() const {
  return payload_case() == kStopBroadcast;
}
inline bool ServerMessage::has_stop_broadcast() const {
  return _internal_has_stop_broadcast();
}
inline void ServerMessage::set_has_stop_broadcast() {
  _impl_._oneof_case_[0] = kStopBroadcast;
}
inline void ServerMessage::clear_stop_broadcast() {
  if (_internal_has_stop_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.stop_broadcast_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::StopBroadcastRequest* ServerMessage::release_stop_broadcast() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.stop_broadcast)
  if (_internal_has_stop_broadcast()) {
    clear_has_payload();
    ::ams::device::grpc::StopBroadcastRequest* temp = _impl_.payload_.stop_broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.stop_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::StopBroadcastRequest& ServerMessage::_internal_stop_broadcast() const {
  return _internal_has_stop_broadcast()
      ? *_impl_.payload_.stop_broadcast_
      : reinterpret_cast< ::ams::device::grpc::StopBroadcastRequest&>(::ams::device::grpc::_StopBroadcastRequest_default_instance_);
}
inline const ::ams::device::grpc::StopBroadcastRequest& ServerMessage::stop_broadcast() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.stop_broadcast)
  return _internal_stop_broadcast();
}
inline ::ams::device::grpc::StopBroadcastRequest* ServerMessage::unsafe_arena_release_stop_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.stop_broadcast)
  if (_internal_has_stop_broadcast()) {
    clear_has_payload();
    ::ams::device::grpc::StopBroadcastRequest* temp = _impl_.payload_.stop_broadcast_;
    _impl_.payload_.stop_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_stop_broadcast(::ams::device::grpc::StopBroadcastRequest* stop_broadcast) {
  clear_payload();
  if (stop_broadcast) {
    set_has_stop_broadcast();
    _impl_.payload_.stop_broadcast_ = stop_broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.stop_broadcast)
}
inline ::ams::device::grpc::StopBroadcastRequest* ServerMessage::_internal_mutable_stop_broadcast() {
  if (!_internal_has_stop_broadcast()) {
    clear_payload();
    set_has_stop_broadcast();
    _impl_.payload_.stop_broadcast_ = CreateMaybeMessage< ::ams::device::grpc::StopBroadcastRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.stop_broadcast_;
}
inline ::ams::device::grpc::StopBroadcastRequest* ServerMessage::mutable_stop_broadcast() {
  ::ams::device::grpc::StopBroadcastRequest* _msg = _internal_mutable_stop_broadcast();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.stop_broadcast)
  return _msg;
}

// .ams.device.grpc.AddAudioClipRequest add_audio_clip = 28;
inline bool ServerMessage::_internal_has_add_audio_clip() const {
  return payload_case() == kAddAudioClip;
}
inline bool ServerMessage::has_add_audio_clip() const {
  return _internal_has_add_audio_clip();
}
inline void ServerMessage::set_has_add_audio_clip() {
  _impl_._oneof_case_[0] = kAddAudioClip;
}
inline void ServerMessage::clear_add_audio_clip() {
  if (_internal_has_add_audio_clip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.add_audio_clip_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::AddAudioClipRequest* ServerMessage::release_add_audio_clip() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.add_audio_clip)
  if (_internal_has_add_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::AddAudioClipRequest* temp = _impl_.payload_.add_audio_clip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::AddAudioClipRequest& ServerMessage::_internal_add_audio_clip() const {
  return _internal_has_add_audio_clip()
      ? *_impl_.payload_.add_audio_clip_
      : reinterpret_cast< ::ams::device::grpc::AddAudioClipRequest&>(::ams::device::grpc::_AddAudioClipRequest_default_instance_);
}
inline const ::ams::device::grpc::AddAudioClipRequest& ServerMessage::add_audio_clip() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.add_audio_clip)
  return _internal_add_audio_clip();
}
inline ::ams::device::grpc::AddAudioClipRequest* ServerMessage::unsafe_arena_release_add_audio_clip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.add_audio_clip)
  if (_internal_has_add_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::AddAudioClipRequest* temp = _impl_.payload_.add_audio_clip_;
    _impl_.payload_.add_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_add_audio_clip(::ams::device::grpc::AddAudioClipRequest* add_audio_clip) {
  clear_payload();
  if (add_audio_clip) {
    set_has_add_audio_clip();
    _impl_.payload_.add_audio_clip_ = add_audio_clip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.add_audio_clip)
}
inline ::ams::device::grpc::AddAudioClipRequest* ServerMessage::_internal_mutable_add_audio_clip() {
  if (!_internal_has_add_audio_clip()) {
    clear_payload();
    set_has_add_audio_clip();
    _impl_.payload_.add_audio_clip_ = CreateMaybeMessage< ::ams::device::grpc::AddAudioClipRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.add_audio_clip_;
}
inline ::ams::device::grpc::AddAudioClipRequest* ServerMessage::mutable_add_audio_clip() {
  ::ams::device::grpc::AddAudioClipRequest* _msg = _internal_mutable_add_audio_clip();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.add_audio_clip)
  return _msg;
}

// .ams.device.grpc.EditAudioClipRequest edit_audio_clip = 29;
inline bool ServerMessage::_internal_has_edit_audio_clip() const {
  return payload_case() == kEditAudioClip;
}
inline bool ServerMessage::has_edit_audio_clip() const {
  return _internal_has_edit_audio_clip();
}
inline void ServerMessage::set_has_edit_audio_clip() {
  _impl_._oneof_case_[0] = kEditAudioClip;
}
inline void ServerMessage::clear_edit_audio_clip() {
  if (_internal_has_edit_audio_clip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.edit_audio_clip_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::EditAudioClipRequest* ServerMessage::release_edit_audio_clip() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.edit_audio_clip)
  if (_internal_has_edit_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::EditAudioClipRequest* temp = _impl_.payload_.edit_audio_clip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.edit_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::EditAudioClipRequest& ServerMessage::_internal_edit_audio_clip() const {
  return _internal_has_edit_audio_clip()
      ? *_impl_.payload_.edit_audio_clip_
      : reinterpret_cast< ::ams::device::grpc::EditAudioClipRequest&>(::ams::device::grpc::_EditAudioClipRequest_default_instance_);
}
inline const ::ams::device::grpc::EditAudioClipRequest& ServerMessage::edit_audio_clip() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.edit_audio_clip)
  return _internal_edit_audio_clip();
}
inline ::ams::device::grpc::EditAudioClipRequest* ServerMessage::unsafe_arena_release_edit_audio_clip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.edit_audio_clip)
  if (_internal_has_edit_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::EditAudioClipRequest* temp = _impl_.payload_.edit_audio_clip_;
    _impl_.payload_.edit_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_edit_audio_clip(::ams::device::grpc::EditAudioClipRequest* edit_audio_clip) {
  clear_payload();
  if (edit_audio_clip) {
    set_has_edit_audio_clip();
    _impl_.payload_.edit_audio_clip_ = edit_audio_clip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.edit_audio_clip)
}
inline ::ams::device::grpc::EditAudioClipRequest* ServerMessage::_internal_mutable_edit_audio_clip() {
  if (!_internal_has_edit_audio_clip()) {
    clear_payload();
    set_has_edit_audio_clip();
    _impl_.payload_.edit_audio_clip_ = CreateMaybeMessage< ::ams::device::grpc::EditAudioClipRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.edit_audio_clip_;
}
inline ::ams::device::grpc::EditAudioClipRequest* ServerMessage::mutable_edit_audio_clip() {
  ::ams::device::grpc::EditAudioClipRequest* _msg = _internal_mutable_edit_audio_clip();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.edit_audio_clip)
  return _msg;
}

// .ams.device.grpc.DeleteAudioClipRequest delete_audio_clip = 30;
inline bool ServerMessage::_internal_has_delete_audio_clip() const {
  return payload_case() == kDeleteAudioClip;
}
inline bool ServerMessage::has_delete_audio_clip() const {
  return _internal_has_delete_audio_clip();
}
inline void ServerMessage::set_has_delete_audio_clip() {
  _impl_._oneof_case_[0] = kDeleteAudioClip;
}
inline void ServerMessage::clear_delete_audio_clip() {
  if (_internal_has_delete_audio_clip()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.delete_audio_clip_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::DeleteAudioClipRequest* ServerMessage::release_delete_audio_clip() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.delete_audio_clip)
  if (_internal_has_delete_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteAudioClipRequest* temp = _impl_.payload_.delete_audio_clip_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::DeleteAudioClipRequest& ServerMessage::_internal_delete_audio_clip() const {
  return _internal_has_delete_audio_clip()
      ? *_impl_.payload_.delete_audio_clip_
      : reinterpret_cast< ::ams::device::grpc::DeleteAudioClipRequest&>(::ams::device::grpc::_DeleteAudioClipRequest_default_instance_);
}
inline const ::ams::device::grpc::DeleteAudioClipRequest& ServerMessage::delete_audio_clip() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.delete_audio_clip)
  return _internal_delete_audio_clip();
}
inline ::ams::device::grpc::DeleteAudioClipRequest* ServerMessage::unsafe_arena_release_delete_audio_clip() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.delete_audio_clip)
  if (_internal_has_delete_audio_clip()) {
    clear_has_payload();
    ::ams::device::grpc::DeleteAudioClipRequest* temp = _impl_.payload_.delete_audio_clip_;
    _impl_.payload_.delete_audio_clip_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_delete_audio_clip(::ams::device::grpc::DeleteAudioClipRequest* delete_audio_clip) {
  clear_payload();
  if (delete_audio_clip) {
    set_has_delete_audio_clip();
    _impl_.payload_.delete_audio_clip_ = delete_audio_clip;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.delete_audio_clip)
}
inline ::ams::device::grpc::DeleteAudioClipRequest* ServerMessage::_internal_mutable_delete_audio_clip() {
  if (!_internal_has_delete_audio_clip()) {
    clear_payload();
    set_has_delete_audio_clip();
    _impl_.payload_.delete_audio_clip_ = CreateMaybeMessage< ::ams::device::grpc::DeleteAudioClipRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.delete_audio_clip_;
}
inline ::ams::device::grpc::DeleteAudioClipRequest* ServerMessage::mutable_delete_audio_clip() {
  ::ams::device::grpc::DeleteAudioClipRequest* _msg = _internal_mutable_delete_audio_clip();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.delete_audio_clip)
  return _msg;
}

// .ams.device.grpc.SystemRebootRequest system_reboot = 31;
inline bool ServerMessage::_internal_has_system_reboot() const {
  return payload_case() == kSystemReboot;
}
inline bool ServerMessage::has_system_reboot() const {
  return _internal_has_system_reboot();
}
inline void ServerMessage::set_has_system_reboot() {
  _impl_._oneof_case_[0] = kSystemReboot;
}
inline void ServerMessage::clear_system_reboot() {
  if (_internal_has_system_reboot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.system_reboot_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SystemRebootRequest* ServerMessage::release_system_reboot() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.ServerMessage.system_reboot)
  if (_internal_has_system_reboot()) {
    clear_has_payload();
    ::ams::device::grpc::SystemRebootRequest* temp = _impl_.payload_.system_reboot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.system_reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SystemRebootRequest& ServerMessage::_internal_system_reboot() const {
  return _internal_has_system_reboot()
      ? *_impl_.payload_.system_reboot_
      : reinterpret_cast< ::ams::device::grpc::SystemRebootRequest&>(::ams::device::grpc::_SystemRebootRequest_default_instance_);
}
inline const ::ams::device::grpc::SystemRebootRequest& ServerMessage::system_reboot() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.ServerMessage.system_reboot)
  return _internal_system_reboot();
}
inline ::ams::device::grpc::SystemRebootRequest* ServerMessage::unsafe_arena_release_system_reboot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.ServerMessage.system_reboot)
  if (_internal_has_system_reboot()) {
    clear_has_payload();
    ::ams::device::grpc::SystemRebootRequest* temp = _impl_.payload_.system_reboot_;
    _impl_.payload_.system_reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ServerMessage::unsafe_arena_set_allocated_system_reboot(::ams::device::grpc::SystemRebootRequest* system_reboot) {
  clear_payload();
  if (system_reboot) {
    set_has_system_reboot();
    _impl_.payload_.system_reboot_ = system_reboot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.ServerMessage.system_reboot)
}
inline ::ams::device::grpc::SystemRebootRequest* ServerMessage::_internal_mutable_system_reboot() {
  if (!_internal_has_system_reboot()) {
    clear_payload();
    set_has_system_reboot();
    _impl_.payload_.system_reboot_ = CreateMaybeMessage< ::ams::device::grpc::SystemRebootRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.system_reboot_;
}
inline ::ams::device::grpc::SystemRebootRequest* ServerMessage::mutable_system_reboot() {
  ::ams::device::grpc::SystemRebootRequest* _msg = _internal_mutable_system_reboot();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.ServerMessage.system_reboot)
  return _msg;
}

inline bool ServerMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void ServerMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline ServerMessage::PayloadCase ServerMessage::payload_case() const {
  return ServerMessage::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DeviceMessage

// string message_id = 1;
inline void DeviceMessage::clear_message_id() {
  _impl_.message_id_.ClearToEmpty();
}
inline const std::string& DeviceMessage::message_id() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.message_id)
  return _internal_message_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceMessage::set_message_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeviceMessage.message_id)
}
inline std::string* DeviceMessage::mutable_message_id() {
  std::string* _s = _internal_mutable_message_id();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.message_id)
  return _s;
}
inline const std::string& DeviceMessage::_internal_message_id() const {
  return _impl_.message_id_.Get();
}
inline void DeviceMessage::_internal_set_message_id(const std::string& value) {
  
  _impl_.message_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceMessage::_internal_mutable_message_id() {
  
  return _impl_.message_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceMessage::release_message_id() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.message_id)
  return _impl_.message_id_.Release();
}
inline void DeviceMessage::set_allocated_message_id(std::string* message_id) {
  if (message_id != nullptr) {
    
  } else {
    
  }
  _impl_.message_id_.SetAllocated(message_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_id_.IsDefault()) {
    _impl_.message_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeviceMessage.message_id)
}

// .ams.device.grpc.Status status = 2;
inline void DeviceMessage::clear_status() {
  _impl_.status_ = 0;
}
inline ::ams::device::grpc::Status DeviceMessage::_internal_status() const {
  return static_cast< ::ams::device::grpc::Status >(_impl_.status_);
}
inline ::ams::device::grpc::Status DeviceMessage::status() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.status)
  return _internal_status();
}
inline void DeviceMessage::_internal_set_status(::ams::device::grpc::Status value) {
  
  _impl_.status_ = value;
}
inline void DeviceMessage::set_status(::ams::device::grpc::Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ams.device.grpc.DeviceMessage.status)
}

// .ams.device.grpc.Error error = 3;
inline bool DeviceMessage::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool DeviceMessage::has_error() const {
  return _internal_has_error();
}
inline void DeviceMessage::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::ams::device::grpc::Error& DeviceMessage::_internal_error() const {
  const ::ams::device::grpc::Error* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::ams::device::grpc::Error&>(
      ::ams::device::grpc::_Error_default_instance_);
}
inline const ::ams::device::grpc::Error& DeviceMessage::error() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.error)
  return _internal_error();
}
inline void DeviceMessage::unsafe_arena_set_allocated_error(
    ::ams::device::grpc::Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.error)
}
inline ::ams::device::grpc::Error* DeviceMessage::release_error() {
  
  ::ams::device::grpc::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ams::device::grpc::Error* DeviceMessage::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.error)
  
  ::ams::device::grpc::Error* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::ams::device::grpc::Error* DeviceMessage::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::ams::device::grpc::Error>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::ams::device::grpc::Error* DeviceMessage::mutable_error() {
  ::ams::device::grpc::Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.error)
  return _msg;
}
inline void DeviceMessage::set_allocated_error(::ams::device::grpc::Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:ams.device.grpc.DeviceMessage.error)
}

// .ams.device.grpc.GetSystemDateAndTimeResponse get_system_date_and_time = 4;
inline bool DeviceMessage::_internal_has_get_system_date_and_time() const {
  return payload_case() == kGetSystemDateAndTime;
}
inline bool DeviceMessage::has_get_system_date_and_time() const {
  return _internal_has_get_system_date_and_time();
}
inline void DeviceMessage::set_has_get_system_date_and_time() {
  _impl_._oneof_case_[0] = kGetSystemDateAndTime;
}
inline void DeviceMessage::clear_get_system_date_and_time() {
  if (_internal_has_get_system_date_and_time()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_system_date_and_time_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSystemDateAndTimeResponse* DeviceMessage::release_get_system_date_and_time() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_system_date_and_time)
  if (_internal_has_get_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::GetSystemDateAndTimeResponse* temp = _impl_.payload_.get_system_date_and_time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSystemDateAndTimeResponse& DeviceMessage::_internal_get_system_date_and_time() const {
  return _internal_has_get_system_date_and_time()
      ? *_impl_.payload_.get_system_date_and_time_
      : reinterpret_cast< ::ams::device::grpc::GetSystemDateAndTimeResponse&>(::ams::device::grpc::_GetSystemDateAndTimeResponse_default_instance_);
}
inline const ::ams::device::grpc::GetSystemDateAndTimeResponse& DeviceMessage::get_system_date_and_time() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_system_date_and_time)
  return _internal_get_system_date_and_time();
}
inline ::ams::device::grpc::GetSystemDateAndTimeResponse* DeviceMessage::unsafe_arena_release_get_system_date_and_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_system_date_and_time)
  if (_internal_has_get_system_date_and_time()) {
    clear_has_payload();
    ::ams::device::grpc::GetSystemDateAndTimeResponse* temp = _impl_.payload_.get_system_date_and_time_;
    _impl_.payload_.get_system_date_and_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_system_date_and_time(::ams::device::grpc::GetSystemDateAndTimeResponse* get_system_date_and_time) {
  clear_payload();
  if (get_system_date_and_time) {
    set_has_get_system_date_and_time();
    _impl_.payload_.get_system_date_and_time_ = get_system_date_and_time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_system_date_and_time)
}
inline ::ams::device::grpc::GetSystemDateAndTimeResponse* DeviceMessage::_internal_mutable_get_system_date_and_time() {
  if (!_internal_has_get_system_date_and_time()) {
    clear_payload();
    set_has_get_system_date_and_time();
    _impl_.payload_.get_system_date_and_time_ = CreateMaybeMessage< ::ams::device::grpc::GetSystemDateAndTimeResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_system_date_and_time_;
}
inline ::ams::device::grpc::GetSystemDateAndTimeResponse* DeviceMessage::mutable_get_system_date_and_time() {
  ::ams::device::grpc::GetSystemDateAndTimeResponse* _msg = _internal_mutable_get_system_date_and_time();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_system_date_and_time)
  return _msg;
}

// .ams.device.grpc.GetNetworkInterfacesResponse get_network_interfaces = 5;
inline bool DeviceMessage::_internal_has_get_network_interfaces() const {
  return payload_case() == kGetNetworkInterfaces;
}
inline bool DeviceMessage::has_get_network_interfaces() const {
  return _internal_has_get_network_interfaces();
}
inline void DeviceMessage::set_has_get_network_interfaces() {
  _impl_._oneof_case_[0] = kGetNetworkInterfaces;
}
inline void DeviceMessage::clear_get_network_interfaces() {
  if (_internal_has_get_network_interfaces()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_network_interfaces_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetNetworkInterfacesResponse* DeviceMessage::release_get_network_interfaces() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_network_interfaces)
  if (_internal_has_get_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::GetNetworkInterfacesResponse* temp = _impl_.payload_.get_network_interfaces_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetNetworkInterfacesResponse& DeviceMessage::_internal_get_network_interfaces() const {
  return _internal_has_get_network_interfaces()
      ? *_impl_.payload_.get_network_interfaces_
      : reinterpret_cast< ::ams::device::grpc::GetNetworkInterfacesResponse&>(::ams::device::grpc::_GetNetworkInterfacesResponse_default_instance_);
}
inline const ::ams::device::grpc::GetNetworkInterfacesResponse& DeviceMessage::get_network_interfaces() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_network_interfaces)
  return _internal_get_network_interfaces();
}
inline ::ams::device::grpc::GetNetworkInterfacesResponse* DeviceMessage::unsafe_arena_release_get_network_interfaces() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_network_interfaces)
  if (_internal_has_get_network_interfaces()) {
    clear_has_payload();
    ::ams::device::grpc::GetNetworkInterfacesResponse* temp = _impl_.payload_.get_network_interfaces_;
    _impl_.payload_.get_network_interfaces_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_network_interfaces(::ams::device::grpc::GetNetworkInterfacesResponse* get_network_interfaces) {
  clear_payload();
  if (get_network_interfaces) {
    set_has_get_network_interfaces();
    _impl_.payload_.get_network_interfaces_ = get_network_interfaces;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_network_interfaces)
}
inline ::ams::device::grpc::GetNetworkInterfacesResponse* DeviceMessage::_internal_mutable_get_network_interfaces() {
  if (!_internal_has_get_network_interfaces()) {
    clear_payload();
    set_has_get_network_interfaces();
    _impl_.payload_.get_network_interfaces_ = CreateMaybeMessage< ::ams::device::grpc::GetNetworkInterfacesResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_network_interfaces_;
}
inline ::ams::device::grpc::GetNetworkInterfacesResponse* DeviceMessage::mutable_get_network_interfaces() {
  ::ams::device::grpc::GetNetworkInterfacesResponse* _msg = _internal_mutable_get_network_interfaces();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_network_interfaces)
  return _msg;
}

// .ams.device.grpc.GetSipInformationResponse get_sip_information = 6;
inline bool DeviceMessage::_internal_has_get_sip_information() const {
  return payload_case() == kGetSipInformation;
}
inline bool DeviceMessage::has_get_sip_information() const {
  return _internal_has_get_sip_information();
}
inline void DeviceMessage::set_has_get_sip_information() {
  _impl_._oneof_case_[0] = kGetSipInformation;
}
inline void DeviceMessage::clear_get_sip_information() {
  if (_internal_has_get_sip_information()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_sip_information_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSipInformationResponse* DeviceMessage::release_get_sip_information() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_sip_information)
  if (_internal_has_get_sip_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetSipInformationResponse* temp = _impl_.payload_.get_sip_information_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_sip_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSipInformationResponse& DeviceMessage::_internal_get_sip_information() const {
  return _internal_has_get_sip_information()
      ? *_impl_.payload_.get_sip_information_
      : reinterpret_cast< ::ams::device::grpc::GetSipInformationResponse&>(::ams::device::grpc::_GetSipInformationResponse_default_instance_);
}
inline const ::ams::device::grpc::GetSipInformationResponse& DeviceMessage::get_sip_information() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_sip_information)
  return _internal_get_sip_information();
}
inline ::ams::device::grpc::GetSipInformationResponse* DeviceMessage::unsafe_arena_release_get_sip_information() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_sip_information)
  if (_internal_has_get_sip_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetSipInformationResponse* temp = _impl_.payload_.get_sip_information_;
    _impl_.payload_.get_sip_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_sip_information(::ams::device::grpc::GetSipInformationResponse* get_sip_information) {
  clear_payload();
  if (get_sip_information) {
    set_has_get_sip_information();
    _impl_.payload_.get_sip_information_ = get_sip_information;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_sip_information)
}
inline ::ams::device::grpc::GetSipInformationResponse* DeviceMessage::_internal_mutable_get_sip_information() {
  if (!_internal_has_get_sip_information()) {
    clear_payload();
    set_has_get_sip_information();
    _impl_.payload_.get_sip_information_ = CreateMaybeMessage< ::ams::device::grpc::GetSipInformationResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_sip_information_;
}
inline ::ams::device::grpc::GetSipInformationResponse* DeviceMessage::mutable_get_sip_information() {
  ::ams::device::grpc::GetSipInformationResponse* _msg = _internal_mutable_get_sip_information();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_sip_information)
  return _msg;
}

// .ams.device.grpc.GetOnvifInformationResponse get_onvif_information = 7;
inline bool DeviceMessage::_internal_has_get_onvif_information() const {
  return payload_case() == kGetOnvifInformation;
}
inline bool DeviceMessage::has_get_onvif_information() const {
  return _internal_has_get_onvif_information();
}
inline void DeviceMessage::set_has_get_onvif_information() {
  _impl_._oneof_case_[0] = kGetOnvifInformation;
}
inline void DeviceMessage::clear_get_onvif_information() {
  if (_internal_has_get_onvif_information()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_onvif_information_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetOnvifInformationResponse* DeviceMessage::release_get_onvif_information() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_onvif_information)
  if (_internal_has_get_onvif_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetOnvifInformationResponse* temp = _impl_.payload_.get_onvif_information_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_onvif_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetOnvifInformationResponse& DeviceMessage::_internal_get_onvif_information() const {
  return _internal_has_get_onvif_information()
      ? *_impl_.payload_.get_onvif_information_
      : reinterpret_cast< ::ams::device::grpc::GetOnvifInformationResponse&>(::ams::device::grpc::_GetOnvifInformationResponse_default_instance_);
}
inline const ::ams::device::grpc::GetOnvifInformationResponse& DeviceMessage::get_onvif_information() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_onvif_information)
  return _internal_get_onvif_information();
}
inline ::ams::device::grpc::GetOnvifInformationResponse* DeviceMessage::unsafe_arena_release_get_onvif_information() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_onvif_information)
  if (_internal_has_get_onvif_information()) {
    clear_has_payload();
    ::ams::device::grpc::GetOnvifInformationResponse* temp = _impl_.payload_.get_onvif_information_;
    _impl_.payload_.get_onvif_information_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_onvif_information(::ams::device::grpc::GetOnvifInformationResponse* get_onvif_information) {
  clear_payload();
  if (get_onvif_information) {
    set_has_get_onvif_information();
    _impl_.payload_.get_onvif_information_ = get_onvif_information;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_onvif_information)
}
inline ::ams::device::grpc::GetOnvifInformationResponse* DeviceMessage::_internal_mutable_get_onvif_information() {
  if (!_internal_has_get_onvif_information()) {
    clear_payload();
    set_has_get_onvif_information();
    _impl_.payload_.get_onvif_information_ = CreateMaybeMessage< ::ams::device::grpc::GetOnvifInformationResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_onvif_information_;
}
inline ::ams::device::grpc::GetOnvifInformationResponse* DeviceMessage::mutable_get_onvif_information() {
  ::ams::device::grpc::GetOnvifInformationResponse* _msg = _internal_mutable_get_onvif_information();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_onvif_information)
  return _msg;
}

// .ams.device.grpc.GetPaAddressResponse get_pa_address = 8;
inline bool DeviceMessage::_internal_has_get_pa_address() const {
  return payload_case() == kGetPaAddress;
}
inline bool DeviceMessage::has_get_pa_address() const {
  return _internal_has_get_pa_address();
}
inline void DeviceMessage::set_has_get_pa_address() {
  _impl_._oneof_case_[0] = kGetPaAddress;
}
inline void DeviceMessage::clear_get_pa_address() {
  if (_internal_has_get_pa_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_pa_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetPaAddressResponse* DeviceMessage::release_get_pa_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_pa_address)
  if (_internal_has_get_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetPaAddressResponse* temp = _impl_.payload_.get_pa_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetPaAddressResponse& DeviceMessage::_internal_get_pa_address() const {
  return _internal_has_get_pa_address()
      ? *_impl_.payload_.get_pa_address_
      : reinterpret_cast< ::ams::device::grpc::GetPaAddressResponse&>(::ams::device::grpc::_GetPaAddressResponse_default_instance_);
}
inline const ::ams::device::grpc::GetPaAddressResponse& DeviceMessage::get_pa_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_pa_address)
  return _internal_get_pa_address();
}
inline ::ams::device::grpc::GetPaAddressResponse* DeviceMessage::unsafe_arena_release_get_pa_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_pa_address)
  if (_internal_has_get_pa_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetPaAddressResponse* temp = _impl_.payload_.get_pa_address_;
    _impl_.payload_.get_pa_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_pa_address(::ams::device::grpc::GetPaAddressResponse* get_pa_address) {
  clear_payload();
  if (get_pa_address) {
    set_has_get_pa_address();
    _impl_.payload_.get_pa_address_ = get_pa_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_pa_address)
}
inline ::ams::device::grpc::GetPaAddressResponse* DeviceMessage::_internal_mutable_get_pa_address() {
  if (!_internal_has_get_pa_address()) {
    clear_payload();
    set_has_get_pa_address();
    _impl_.payload_.get_pa_address_ = CreateMaybeMessage< ::ams::device::grpc::GetPaAddressResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_pa_address_;
}
inline ::ams::device::grpc::GetPaAddressResponse* DeviceMessage::mutable_get_pa_address() {
  ::ams::device::grpc::GetPaAddressResponse* _msg = _internal_mutable_get_pa_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_pa_address)
  return _msg;
}

// .ams.device.grpc.GetSnapcastAddressResponse get_snapcast_address = 9;
inline bool DeviceMessage::_internal_has_get_snapcast_address() const {
  return payload_case() == kGetSnapcastAddress;
}
inline bool DeviceMessage::has_get_snapcast_address() const {
  return _internal_has_get_snapcast_address();
}
inline void DeviceMessage::set_has_get_snapcast_address() {
  _impl_._oneof_case_[0] = kGetSnapcastAddress;
}
inline void DeviceMessage::clear_get_snapcast_address() {
  if (_internal_has_get_snapcast_address()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_snapcast_address_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetSnapcastAddressResponse* DeviceMessage::release_get_snapcast_address() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_snapcast_address)
  if (_internal_has_get_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetSnapcastAddressResponse* temp = _impl_.payload_.get_snapcast_address_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetSnapcastAddressResponse& DeviceMessage::_internal_get_snapcast_address() const {
  return _internal_has_get_snapcast_address()
      ? *_impl_.payload_.get_snapcast_address_
      : reinterpret_cast< ::ams::device::grpc::GetSnapcastAddressResponse&>(::ams::device::grpc::_GetSnapcastAddressResponse_default_instance_);
}
inline const ::ams::device::grpc::GetSnapcastAddressResponse& DeviceMessage::get_snapcast_address() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_snapcast_address)
  return _internal_get_snapcast_address();
}
inline ::ams::device::grpc::GetSnapcastAddressResponse* DeviceMessage::unsafe_arena_release_get_snapcast_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_snapcast_address)
  if (_internal_has_get_snapcast_address()) {
    clear_has_payload();
    ::ams::device::grpc::GetSnapcastAddressResponse* temp = _impl_.payload_.get_snapcast_address_;
    _impl_.payload_.get_snapcast_address_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_snapcast_address(::ams::device::grpc::GetSnapcastAddressResponse* get_snapcast_address) {
  clear_payload();
  if (get_snapcast_address) {
    set_has_get_snapcast_address();
    _impl_.payload_.get_snapcast_address_ = get_snapcast_address;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_snapcast_address)
}
inline ::ams::device::grpc::GetSnapcastAddressResponse* DeviceMessage::_internal_mutable_get_snapcast_address() {
  if (!_internal_has_get_snapcast_address()) {
    clear_payload();
    set_has_get_snapcast_address();
    _impl_.payload_.get_snapcast_address_ = CreateMaybeMessage< ::ams::device::grpc::GetSnapcastAddressResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_snapcast_address_;
}
inline ::ams::device::grpc::GetSnapcastAddressResponse* DeviceMessage::mutable_get_snapcast_address() {
  ::ams::device::grpc::GetSnapcastAddressResponse* _msg = _internal_mutable_get_snapcast_address();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_snapcast_address)
  return _msg;
}

// .ams.device.grpc.GetVolumeResponse get_volume = 10;
inline bool DeviceMessage::_internal_has_get_volume() const {
  return payload_case() == kGetVolume;
}
inline bool DeviceMessage::has_get_volume() const {
  return _internal_has_get_volume();
}
inline void DeviceMessage::set_has_get_volume() {
  _impl_._oneof_case_[0] = kGetVolume;
}
inline void DeviceMessage::clear_get_volume() {
  if (_internal_has_get_volume()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_volume_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetVolumeResponse* DeviceMessage::release_get_volume() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_volume)
  if (_internal_has_get_volume()) {
    clear_has_payload();
    ::ams::device::grpc::GetVolumeResponse* temp = _impl_.payload_.get_volume_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetVolumeResponse& DeviceMessage::_internal_get_volume() const {
  return _internal_has_get_volume()
      ? *_impl_.payload_.get_volume_
      : reinterpret_cast< ::ams::device::grpc::GetVolumeResponse&>(::ams::device::grpc::_GetVolumeResponse_default_instance_);
}
inline const ::ams::device::grpc::GetVolumeResponse& DeviceMessage::get_volume() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_volume)
  return _internal_get_volume();
}
inline ::ams::device::grpc::GetVolumeResponse* DeviceMessage::unsafe_arena_release_get_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_volume)
  if (_internal_has_get_volume()) {
    clear_has_payload();
    ::ams::device::grpc::GetVolumeResponse* temp = _impl_.payload_.get_volume_;
    _impl_.payload_.get_volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_volume(::ams::device::grpc::GetVolumeResponse* get_volume) {
  clear_payload();
  if (get_volume) {
    set_has_get_volume();
    _impl_.payload_.get_volume_ = get_volume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_volume)
}
inline ::ams::device::grpc::GetVolumeResponse* DeviceMessage::_internal_mutable_get_volume() {
  if (!_internal_has_get_volume()) {
    clear_payload();
    set_has_get_volume();
    _impl_.payload_.get_volume_ = CreateMaybeMessage< ::ams::device::grpc::GetVolumeResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_volume_;
}
inline ::ams::device::grpc::GetVolumeResponse* DeviceMessage::mutable_get_volume() {
  ::ams::device::grpc::GetVolumeResponse* _msg = _internal_mutable_get_volume();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_volume)
  return _msg;
}

// .ams.device.grpc.GetScheduleListResponse get_schedule_list = 11;
inline bool DeviceMessage::_internal_has_get_schedule_list() const {
  return payload_case() == kGetScheduleList;
}
inline bool DeviceMessage::has_get_schedule_list() const {
  return _internal_has_get_schedule_list();
}
inline void DeviceMessage::set_has_get_schedule_list() {
  _impl_._oneof_case_[0] = kGetScheduleList;
}
inline void DeviceMessage::clear_get_schedule_list() {
  if (_internal_has_get_schedule_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.get_schedule_list_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::GetScheduleListResponse* DeviceMessage::release_get_schedule_list() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.get_schedule_list)
  if (_internal_has_get_schedule_list()) {
    clear_has_payload();
    ::ams::device::grpc::GetScheduleListResponse* temp = _impl_.payload_.get_schedule_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.get_schedule_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::GetScheduleListResponse& DeviceMessage::_internal_get_schedule_list() const {
  return _internal_has_get_schedule_list()
      ? *_impl_.payload_.get_schedule_list_
      : reinterpret_cast< ::ams::device::grpc::GetScheduleListResponse&>(::ams::device::grpc::_GetScheduleListResponse_default_instance_);
}
inline const ::ams::device::grpc::GetScheduleListResponse& DeviceMessage::get_schedule_list() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.get_schedule_list)
  return _internal_get_schedule_list();
}
inline ::ams::device::grpc::GetScheduleListResponse* DeviceMessage::unsafe_arena_release_get_schedule_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.get_schedule_list)
  if (_internal_has_get_schedule_list()) {
    clear_has_payload();
    ::ams::device::grpc::GetScheduleListResponse* temp = _impl_.payload_.get_schedule_list_;
    _impl_.payload_.get_schedule_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_get_schedule_list(::ams::device::grpc::GetScheduleListResponse* get_schedule_list) {
  clear_payload();
  if (get_schedule_list) {
    set_has_get_schedule_list();
    _impl_.payload_.get_schedule_list_ = get_schedule_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.get_schedule_list)
}
inline ::ams::device::grpc::GetScheduleListResponse* DeviceMessage::_internal_mutable_get_schedule_list() {
  if (!_internal_has_get_schedule_list()) {
    clear_payload();
    set_has_get_schedule_list();
    _impl_.payload_.get_schedule_list_ = CreateMaybeMessage< ::ams::device::grpc::GetScheduleListResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.get_schedule_list_;
}
inline ::ams::device::grpc::GetScheduleListResponse* DeviceMessage::mutable_get_schedule_list() {
  ::ams::device::grpc::GetScheduleListResponse* _msg = _internal_mutable_get_schedule_list();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.get_schedule_list)
  return _msg;
}

// .ams.device.grpc.SystemRebootResponse system_reboot = 12;
inline bool DeviceMessage::_internal_has_system_reboot() const {
  return payload_case() == kSystemReboot;
}
inline bool DeviceMessage::has_system_reboot() const {
  return _internal_has_system_reboot();
}
inline void DeviceMessage::set_has_system_reboot() {
  _impl_._oneof_case_[0] = kSystemReboot;
}
inline void DeviceMessage::clear_system_reboot() {
  if (_internal_has_system_reboot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.system_reboot_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::SystemRebootResponse* DeviceMessage::release_system_reboot() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.system_reboot)
  if (_internal_has_system_reboot()) {
    clear_has_payload();
    ::ams::device::grpc::SystemRebootResponse* temp = _impl_.payload_.system_reboot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.system_reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::SystemRebootResponse& DeviceMessage::_internal_system_reboot() const {
  return _internal_has_system_reboot()
      ? *_impl_.payload_.system_reboot_
      : reinterpret_cast< ::ams::device::grpc::SystemRebootResponse&>(::ams::device::grpc::_SystemRebootResponse_default_instance_);
}
inline const ::ams::device::grpc::SystemRebootResponse& DeviceMessage::system_reboot() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.system_reboot)
  return _internal_system_reboot();
}
inline ::ams::device::grpc::SystemRebootResponse* DeviceMessage::unsafe_arena_release_system_reboot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.system_reboot)
  if (_internal_has_system_reboot()) {
    clear_has_payload();
    ::ams::device::grpc::SystemRebootResponse* temp = _impl_.payload_.system_reboot_;
    _impl_.payload_.system_reboot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_system_reboot(::ams::device::grpc::SystemRebootResponse* system_reboot) {
  clear_payload();
  if (system_reboot) {
    set_has_system_reboot();
    _impl_.payload_.system_reboot_ = system_reboot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.system_reboot)
}
inline ::ams::device::grpc::SystemRebootResponse* DeviceMessage::_internal_mutable_system_reboot() {
  if (!_internal_has_system_reboot()) {
    clear_payload();
    set_has_system_reboot();
    _impl_.payload_.system_reboot_ = CreateMaybeMessage< ::ams::device::grpc::SystemRebootResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.system_reboot_;
}
inline ::ams::device::grpc::SystemRebootResponse* DeviceMessage::mutable_system_reboot() {
  ::ams::device::grpc::SystemRebootResponse* _msg = _internal_mutable_system_reboot();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.system_reboot)
  return _msg;
}

// .ams.device.grpc.InitSessionNotify init_session_notify = 13;
inline bool DeviceMessage::_internal_has_init_session_notify() const {
  return payload_case() == kInitSessionNotify;
}
inline bool DeviceMessage::has_init_session_notify() const {
  return _internal_has_init_session_notify();
}
inline void DeviceMessage::set_has_init_session_notify() {
  _impl_._oneof_case_[0] = kInitSessionNotify;
}
inline void DeviceMessage::clear_init_session_notify() {
  if (_internal_has_init_session_notify()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.init_session_notify_;
    }
    clear_has_payload();
  }
}
inline ::ams::device::grpc::InitSessionNotify* DeviceMessage::release_init_session_notify() {
  // @@protoc_insertion_point(field_release:ams.device.grpc.DeviceMessage.init_session_notify)
  if (_internal_has_init_session_notify()) {
    clear_has_payload();
    ::ams::device::grpc::InitSessionNotify* temp = _impl_.payload_.init_session_notify_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.init_session_notify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ams::device::grpc::InitSessionNotify& DeviceMessage::_internal_init_session_notify() const {
  return _internal_has_init_session_notify()
      ? *_impl_.payload_.init_session_notify_
      : reinterpret_cast< ::ams::device::grpc::InitSessionNotify&>(::ams::device::grpc::_InitSessionNotify_default_instance_);
}
inline const ::ams::device::grpc::InitSessionNotify& DeviceMessage::init_session_notify() const {
  // @@protoc_insertion_point(field_get:ams.device.grpc.DeviceMessage.init_session_notify)
  return _internal_init_session_notify();
}
inline ::ams::device::grpc::InitSessionNotify* DeviceMessage::unsafe_arena_release_init_session_notify() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ams.device.grpc.DeviceMessage.init_session_notify)
  if (_internal_has_init_session_notify()) {
    clear_has_payload();
    ::ams::device::grpc::InitSessionNotify* temp = _impl_.payload_.init_session_notify_;
    _impl_.payload_.init_session_notify_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DeviceMessage::unsafe_arena_set_allocated_init_session_notify(::ams::device::grpc::InitSessionNotify* init_session_notify) {
  clear_payload();
  if (init_session_notify) {
    set_has_init_session_notify();
    _impl_.payload_.init_session_notify_ = init_session_notify;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ams.device.grpc.DeviceMessage.init_session_notify)
}
inline ::ams::device::grpc::InitSessionNotify* DeviceMessage::_internal_mutable_init_session_notify() {
  if (!_internal_has_init_session_notify()) {
    clear_payload();
    set_has_init_session_notify();
    _impl_.payload_.init_session_notify_ = CreateMaybeMessage< ::ams::device::grpc::InitSessionNotify >(GetArenaForAllocation());
  }
  return _impl_.payload_.init_session_notify_;
}
inline ::ams::device::grpc::InitSessionNotify* DeviceMessage::mutable_init_session_notify() {
  ::ams::device::grpc::InitSessionNotify* _msg = _internal_mutable_init_session_notify();
  // @@protoc_insertion_point(field_mutable:ams.device.grpc.DeviceMessage.init_session_notify)
  return _msg;
}

inline bool DeviceMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void DeviceMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline DeviceMessage::PayloadCase DeviceMessage::payload_case() const {
  return DeviceMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc
}  // namespace device
}  // namespace ams

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ams::device::grpc::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ams::device::grpc::Status>() {
  return ::ams::device::grpc::Status_descriptor();
}
template <> struct is_proto_enum< ::ams::device::grpc::DateTimeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ams::device::grpc::DateTimeType>() {
  return ::ams::device::grpc::DateTimeType_descriptor();
}
template <> struct is_proto_enum< ::ams::device::grpc::NetworkMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ams::device::grpc::NetworkMode>() {
  return ::ams::device::grpc::NetworkMode_descriptor();
}
template <> struct is_proto_enum< ::ams::device::grpc::DayOfWeek> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ams::device::grpc::DayOfWeek>() {
  return ::ams::device::grpc::DayOfWeek_descriptor();
}
template <> struct is_proto_enum< ::ams::device::grpc::OnvifAccessLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ams::device::grpc::OnvifAccessLevel>() {
  return ::ams::device::grpc::OnvifAccessLevel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_device_5fcontrol_2eproto
